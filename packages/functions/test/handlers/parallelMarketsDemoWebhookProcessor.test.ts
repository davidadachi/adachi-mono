import * as firebaseTesting from "@firebase/rules-unit-testing"
import * as admin from "firebase-admin"
import {FirebaseConfig, setEnvForTest} from "../../src/db"
import {parallelMarketsDemoWebhookProcessor} from "../../src"
import {Request} from "express"

import firestore = admin.firestore
import Firestore = firestore.Firestore
import {expectResponse} from "../utils"

interface PmRequest {
  headers: {
    timestamp?: string
    signature?: string
  }
  body: {
    entity: {
      id: string
      type: string
    }
    event: string
    scope: string
  }
  rawBody: Buffer
}

// This is a valid request taken from a test payload using the webhook key for OAuth client
// with id F4eUFc5LDqt6P8Nfjb4av
const VALID_REQUEST: PmRequest = {
  headers: {
    timestamp: "1680634750",
    signature: "bjHm0MvEgSjiwKLa8OQgzmlt24ECoLD0rFUt0sM7lnU=",
  },
  body: {
    entity: {
      id: "test",
      type: "individual",
    },
    event: "data_update",
    scope: "accreditation_status",
  },
  rawBody: Buffer.from(
    `{"entity":{"id":"test","type":"individual"},"event":"data_update","scope":"accreditation_status"}${""}`,
  ),
}

describe("parallelMarketsDemoWebhookProcessor", async () => {
  const projectId = "goldfinch-frontend-test"

  let testFirestore: Firestore
  let testApp: admin.app.App
  let config: Omit<FirebaseConfig, "sentry">

  beforeEach(async () => {
    testApp = firebaseTesting.initializeAdminApp({projectId})
    testFirestore = testApp.firestore()
    config = {
      kyc: {allowed_origins: "http://localhost:3000"},
      slack: {token: "slackToken"},
      persona: {
        allowed_ips: "",
      },
    }
    setEnvForTest(testFirestore, config)
  })

  afterEach(async () => {
    await firebaseTesting.clearFirestoreData({projectId})
  })

  const genRequest = (pmRequest: PmRequest): Request => {
    return {
      // Headers
      get: (key: string) => {
        // This (timestamp, sig) pair is a valid pair generated by sending a test payload from PM to our dev
        // webhook.
        switch (key) {
          case "Parallel-Timestamp":
            return pmRequest.headers.timestamp
          case "Parallel-Signature":
            return pmRequest.headers.signature
          default:
            throw new Error("Invalid Key")
        }
      },
      body: pmRequest.body,
      rawBody: pmRequest.rawBody,
    } as unknown as Request
  }

  describe("valid signature", () => {
    it.skip("returns status 200", async () => {
      await parallelMarketsDemoWebhookProcessor(
        genRequest(VALID_REQUEST),
        expectResponse(200, {status: "valid signature"}),
      )
    })
  })

  describe("missing headers", () => {
    it("returns 400 for missing signature header", async () => {
      await parallelMarketsDemoWebhookProcessor(
        genRequest({
          ...VALID_REQUEST,
          headers: {
            timestamp: VALID_REQUEST.headers.timestamp,
          },
        }),
        expectResponse(400, {status: "missing signature"}),
      )
    })

    it("returns 400 for missing timestamp header", async () => {
      await parallelMarketsDemoWebhookProcessor(
        genRequest({
          ...VALID_REQUEST,
          headers: {
            signature: VALID_REQUEST.headers.signature,
          },
        }),
        expectResponse(400, {status: "missing timestamp"}),
      )
    })
  })

  describe("invalid signature", () => {
    it("returns status 403", async () => {
      await parallelMarketsDemoWebhookProcessor(
        genRequest({
          ...VALID_REQUEST,
          headers: {
            ...VALID_REQUEST.headers,
            signature: VALID_REQUEST.headers.signature + "bad",
          },
        }),
        expectResponse(403, {status: "invalid signature"}),
      )
    })
  })
})
