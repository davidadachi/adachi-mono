{
  "address": "0xba7B8e4ae02C33afF14e472856259DDc46B6DC21",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract Context",
          "name": "_context",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "IndexGreaterThanTokenSupply",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "eligibleAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "nextEpochAmount",
          "type": "uint256"
        }
      ],
      "name": "InvalidHoldingsAdjustment",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoTokensOwned",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoTotalsInFutureEpochs",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "NonexistantToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OneTokenPerAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReadOnly",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "resource",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "accessor",
          "type": "address"
        }
      ],
      "name": "RequiresOperator",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddressInvalid",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eligibleAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nextEpochAmount",
          "type": "uint256"
        }
      ],
      "name": "AdjustedHoldings",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "approved",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "operator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "approved",
          "type": "bool"
        }
      ],
      "name": "ApprovalForAll",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "name": "Checkpoint",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "eligibleAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nextEpochAmount",
          "type": "uint256"
        }
      ],
      "name": "VaultTotalUpdate",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "eligibleAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "nextEpochAmount",
          "type": "uint256"
        }
      ],
      "name": "adjustHoldings",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "baseURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "checkpoint",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "currentTotal",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "currentValueOwnedBy",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "getApproved",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "isApprovedForAll",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "membershipId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        }
      ],
      "name": "positionOwnedBy",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "owner",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "eligibleAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nextEpochAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "createdTimestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "checkpointEpoch",
              "type": "uint256"
            }
          ],
          "internalType": "struct Position",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "safeTransferFrom",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "name": "setApprovalForAll",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "uri",
          "type": "string"
        }
      ],
      "name": "setBaseURI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "id",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenOfOwnerByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "tokenURI",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "epoch",
          "type": "uint256"
        }
      ],
      "name": "totalAtEpoch",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xd5534450e5e62639e6572fe4051d3f76374f76fecb163873e76cafa79cbb6181",
  "receipt": {
    "to": null,
    "from": "0x2Fbf774ec12Bd86a60E563F0653AEee4DEbA0DB8",
    "contractAddress": "0xba7B8e4ae02C33afF14e472856259DDc46B6DC21",
    "transactionIndex": 24,
    "gasUsed": "1356843",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc83bcca40623f02f1ed2e13ffe287a7efc40a273cdec3997a5566b3c20d65ce1",
    "transactionHash": "0xd5534450e5e62639e6572fe4051d3f76374f76fecb163873e76cafa79cbb6181",
    "logs": [],
    "blockNumber": 15992879,
    "cumulativeGasUsed": "3421176",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xd16BC944Bf20c86c4ED47Ce1a330a18538674C83"
  ],
  "solcInputHash": "eac65dc40e06b4b044f441f03029567a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract Context\",\"name\":\"_context\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IndexGreaterThanTokenSupply\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"eligibleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextEpochAmount\",\"type\":\"uint256\"}],\"name\":\"InvalidHoldingsAdjustment\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokensOwned\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTotalsInFutureEpochs\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NonexistantToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OneTokenPerAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReadOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"}],\"name\":\"RequiresOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddressInvalid\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eligibleAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextEpochAmount\",\"type\":\"uint256\"}],\"name\":\"AdjustedHoldings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"Checkpoint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"eligibleAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextEpochAmount\",\"type\":\"uint256\"}],\"name\":\"VaultTotalUpdate\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eligibleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextEpochAmount\",\"type\":\"uint256\"}],\"name\":\"adjustHoldings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"checkpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"currentValueOwnedBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"membershipId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"positionOwnedBy\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"eligibleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextEpochAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"checkpointEpoch\",\"type\":\"uint256\"}],\"internalType\":\"struct Position\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"id\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"totalAtEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Goldfinch\",\"events\":{\"Checkpoint(uint256)\":{\"params\":{\"total\":\"how much is stored in the vault at the current block.timestamp\"}}},\"kind\":\"dev\",\"methods\":{\"adjustHoldings(address,uint256,uint256)\":{\"params\":{\"eligibleAmount\":\"amount of points to apply to the current epoch\",\"nextEpochAmount\":\"amount of points to apply to the next epoch\",\"owner\":\"the owner to checkpoint\"},\"returns\":{\"_0\":\"id of the position\"}},\"balanceOf(address)\":{\"details\":\"Returns the number of tokens in ``owner``'s account.\"},\"checkpoint(address)\":{\"details\":\"to collect rewards, this must be called before `increaseHoldings` or  `decreaseHoldings`. Those functions must call checkpoint internally  so the historical data will be lost otherwise.\",\"params\":{\"owner\":\"the owner to checkpoint\"}},\"currentTotal()\":{\"returns\":{\"_0\":\"total value in the vault as of block.timestamp\"}},\"currentValueOwnedBy(address)\":{\"params\":{\"owner\":\"address owning the positions\"},\"returns\":{\"_0\":\"sum of all positions held by an address\"}},\"name()\":{\"details\":\"Returns the token collection name.\"},\"positionOwnedBy(address)\":{\"returns\":{\"_0\":\"position owned by `owner`\"}},\"symbol()\":{\"details\":\"Returns the token collection symbol.\"},\"tokenByIndex(uint256)\":{\"details\":\"Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens.\"},\"tokenOfOwnerByIndex(address,uint256)\":{\"details\":\"Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\"},\"tokenURI(uint256)\":{\"details\":\"Returns the Uniform Resource Identifier (URI) for `tokenId` token.\"},\"totalAtEpoch(uint256)\":{\"returns\":{\"_0\":\"total value in the vault as of epoch\"}},\"totalSupply()\":{\"details\":\"Returns the total amount of tokens stored by the contract.\"}},\"title\":\"MembershipVault\",\"version\":1},\"userdoc\":{\"errors\":{\"IndexGreaterThanTokenSupply()\":[{\"notice\":\"Thrown when querying token supply with an index greater than the supply\"}],\"InvalidHoldingsAdjustment(uint256,uint256)\":[{\"notice\":\"Thrown when adjusting holdings in an unsupported way\"}],\"NoTokensOwned()\":[{\"notice\":\"Thrown when trying to access tokens from an address with no tokens\"}],\"NoTotalsInFutureEpochs()\":[{\"notice\":\"Thrown when checking totals in future epochs\"}],\"NonexistantToken(uint256)\":[{\"notice\":\"Thrown when requesting a nonexistant token\"}],\"OneTokenPerAddress()\":[{\"notice\":\"Thrown when trying to access more than one token for an address\"}],\"ZeroAddressInvalid()\":[{\"notice\":\"Thrown when depositing from address(0)\"}]},\"events\":{\"AdjustedHoldings(address,uint256,uint256)\":{\"notice\":\"Emitted when an owner has adjusted their holdings in a vault\"},\"Checkpoint(uint256)\":{\"notice\":\"The vault has been checkpointed\"},\"VaultTotalUpdate(uint256,uint256)\":{\"notice\":\"Emitted when the total within the vault has changed\"}},\"kind\":\"user\",\"methods\":{\"adjustHoldings(address,uint256,uint256)\":{\"notice\":\"Record an adjustment in holdings. Eligible assets will update this epoch and  total assets will become eligible the subsequent epoch.\"},\"baseURI()\":{\"notice\":\"base uri for the nft\"},\"checkpoint(address)\":{\"notice\":\"Checkpoint a specific owner & the vault total\"},\"currentTotal()\":{\"notice\":\"Get the total value in the vault as of block.timestamp\"},\"currentValueOwnedBy(address)\":{\"notice\":\"Get the current value of `owner`. This changes depending on the current  block.timestamp as increased holdings are not accounted for until the subsequent epoch.\"},\"positionOwnedBy(address)\":{\"notice\":\"Get the position owned by `owner`\"},\"setBaseURI(string)\":{\"notice\":\"Set the base uri for the contract\"},\"totalAtEpoch(uint256)\":{\"notice\":\"Get the total value in the vault as of epoch\"}},\"notice\":\"Track assets held by owners in a vault, as well as the total held in the vault. Assets  are not accounted for until the next epoch for MEV protection.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/core/membership/MembershipVault.sol\":\"MembershipVault\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\",\"keccak256\":\"0xe6220d2b5a54ac7497313ce4503cca742b09dc5e3a4eb76fb0afff85b1b97a34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC721EnumerableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\\\";\\n\",\"keccak256\":\"0xcbdd61b218c42f20742f8c2522484c8f08af5fc3f45bc19b5d7f63e2f8a470b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/extensions/IERC721MetadataUpgradeable.sol\\\";\\n\",\"keccak256\":\"0x5dfe3cf79db8ac258b674316d81892c642226d6558d48d40d0b440106c6b6619\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721Upgradeable.sol\\\";\\n\",\"keccak256\":\"0x28c8a2c5850343f4fb44847b736df5a89fb16c90971c8c06c8066c04ad9b70df\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf449ca0a763d4b1b4462cf8706857074492f324020a2b9d099181b5383055ad3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xfbb3ca7272af58dc245a20e91a1f68481ee04706fa3fe46d184000efc21f4bad\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x54b0a0b80c447749f769f37fec206cdee23e7466511802191248e95c8250ff9d\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x6dd43e44dbaad99d1863be7f2837085f361efdcb1fde5a9bf84c4efa07f89ed3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0xc7af08df3d3e818ce36f95aa879c13245772fed21b553e6033292ea4edc2a9f3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x1c4860acd323e34a67b3e97faab9aaa55fe8e92b1dcf08b5f47f3468d58ce75c\",\"license\":\"MIT\"},\"contracts/cake/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IAccessControl.sol\\\";\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ncontract AccessControl is Initializable, IAccessControl {\\n  /// @dev Mapping from contract address to contract admin;\\n  mapping(address => address) public admins;\\n\\n  function initialize(address admin) public initializer {\\n    admins[address(this)] = admin;\\n    emit AdminSet(address(this), admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function setAdmin(address resource, address admin) external {\\n    requireSuperAdmin(msg.sender);\\n    admins[resource] = admin;\\n    emit AdminSet(resource, admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireAdmin(address resource, address accessor) public view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n    bool isAdmin = admins[resource] == accessor;\\n    if (!isAdmin) revert RequiresAdmin(resource, accessor);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireSuperAdmin(address accessor) public view {\\n    // The super admin is the admin of this AccessControl contract\\n    requireAdmin({resource: address(this), accessor: accessor});\\n  }\\n}\\n\",\"keccak256\":\"0x1b70acad9e92a3b0898a989d413bb16b5c5707faf84f2eb31354b453385a7b54\",\"license\":\"MIT\"},\"contracts/cake/Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Context} from \\\"./Context.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nusing Routing.Context for Context;\\n\\n/// @title Base contract for application-layer\\n/// @author landakram\\n/// @notice This base contract is what all application-layer contracts should inherit from.\\n///  It provides `Context`, as well as some convenience functions for working with it and\\n///  using access control. All public methods on the inheriting contract should likely\\n///  use one of the modifiers to assert valid callers.\\nabstract contract Base {\\n  error RequiresOperator(address resource, address accessor);\\n  error ZeroAddress();\\n\\n  /// @dev this is safe for proxies as immutable causes the context to be written to\\n  ///  bytecode on deployment. The proxy then treats this as a constant.\\n  Context immutable context;\\n\\n  constructor(Context _context) {\\n    context = _context;\\n  }\\n\\n  modifier onlyOperator(bytes4 operatorId) {\\n    requireOperator(operatorId, msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyOperators(bytes4[2] memory operatorIds) {\\n    requireAnyOperator(operatorIds, msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyAdmin() {\\n    context.accessControl().requireAdmin(address(this), msg.sender);\\n    _;\\n  }\\n\\n  function requireAnyOperator(bytes4[2] memory operatorIds, address accessor) private view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n\\n    bool validOperator = isOperator(operatorIds[0], accessor) || isOperator(operatorIds[1], accessor);\\n\\n    if (!validOperator) revert RequiresOperator(address(this), accessor);\\n  }\\n\\n  function requireOperator(bytes4 operatorId, address accessor) private view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n    if (!isOperator(operatorId, accessor)) revert RequiresOperator(address(this), accessor);\\n  }\\n\\n  function isOperator(bytes4 operatorId, address accessor) private view returns (bool) {\\n    return context.router().contracts(operatorId) == accessor;\\n  }\\n}\\n\",\"keccak256\":\"0x1dbf1ce1916f78d7b98876136dbd0be1fc33afc75a7ad9279dcacaaa57c34bc1\",\"license\":\"MIT\"},\"contracts/cake/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {Router} from \\\"./Router.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nusing Routing.Context for Context;\\n\\n/// @title Entry-point for all application-layer contracts.\\n/// @author landakram\\n/// @notice This contract provides an interface for retrieving other contract addresses and doing access\\n///  control.\\ncontract Context {\\n  /// @notice Used for retrieving other contract addresses.\\n  /// @dev This variable is immutable. This is done to save gas, as it is expected to be referenced\\n  /// in every end-user call with a call-chain length > 0. Note that it is written into the contract\\n  /// bytecode at contract creation time, so if the contract is deployed as the implementation for proxies,\\n  /// every proxy will share the same Router address.\\n  Router public immutable router;\\n\\n  constructor(Router _router) {\\n    router = _router;\\n  }\\n}\\n\",\"keccak256\":\"0xa680415dd02e61f8cd730f3198096d73b40fddb2f7f46136fc20e02a173ec107\",\"license\":\"MIT\"},\"contracts/cake/Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\n\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\n/// @title Router\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ncontract Router is Initializable, IRouter {\\n  /// @notice Mapping of keys to contract addresses. Keys are the first 4 bytes of the keccak of\\n  ///   the contract's name. See Routing.sol for all options.\\n  mapping(bytes4 => address) public contracts;\\n\\n  function initialize(AccessControl accessControl) public initializer {\\n    contracts[Routing.Keys.AccessControl] = address(accessControl);\\n  }\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) public {\\n    AccessControl accessControl = AccessControl(contracts[Routing.Keys.AccessControl]);\\n    accessControl.requireAdmin(address(this), msg.sender);\\n    contracts[key] = addr;\\n    emit SetContract(key, addr);\\n  }\\n}\\n\",\"keccak256\":\"0x686176336adffd914b35e6cc23b551c4af63c43eba9c5416749427a5e02a98b0\",\"license\":\"MIT\"},\"contracts/cake/Routing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable const-name-snakecase\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\n\\nimport {IMembershipVault} from \\\"../interfaces/IMembershipVault.sol\\\";\\nimport {IGFILedger} from \\\"../interfaces/IGFILedger.sol\\\";\\nimport {ICapitalLedger} from \\\"../interfaces/ICapitalLedger.sol\\\";\\nimport {IMembershipDirector} from \\\"../interfaces/IMembershipDirector.sol\\\";\\nimport {IMembershipOrchestrator} from \\\"../interfaces/IMembershipOrchestrator.sol\\\";\\nimport {IMembershipLedger} from \\\"../interfaces/IMembershipLedger.sol\\\";\\nimport {IMembershipCollector} from \\\"../interfaces/IMembershipCollector.sol\\\";\\n\\nimport {ISeniorPool} from \\\"../interfaces/ISeniorPool.sol\\\";\\nimport {IPoolTokens} from \\\"../interfaces/IPoolTokens.sol\\\";\\nimport {IStakingRewards} from \\\"../interfaces/IStakingRewards.sol\\\";\\n\\nimport {IERC20Splitter} from \\\"../interfaces/IERC20Splitter.sol\\\";\\nimport {Context as ContextContract} from \\\"./Context.sol\\\";\\nimport {IAccessControl} from \\\"../interfaces/IAccessControl.sol\\\";\\n\\nimport {Router} from \\\"./Router.sol\\\";\\n\\n/// @title Routing.Keys\\n/// @notice This library is used to define routing keys used by `Router`.\\n/// @dev We use uints instead of enums for several reasons. First, keys can be re-ordered\\n///   or removed. This is useful when routing keys are deprecated; they can be moved to a\\n///   different section of the file. Second, other libraries or contracts can define their\\n///   own routing keys independent of this global mapping. This is useful for test contracts.\\nlibrary Keys {\\n  // Membership\\n  bytes4 internal constant MembershipOrchestrator = bytes4(keccak256(\\\"MembershipOrchestrator\\\"));\\n  bytes4 internal constant MembershipDirector = bytes4(keccak256(\\\"MembershipDirector\\\"));\\n  bytes4 internal constant GFILedger = bytes4(keccak256(\\\"GFILedger\\\"));\\n  bytes4 internal constant CapitalLedger = bytes4(keccak256(\\\"CapitalLedger\\\"));\\n  bytes4 internal constant MembershipCollector = bytes4(keccak256(\\\"MembershipCollector\\\"));\\n  bytes4 internal constant MembershipLedger = bytes4(keccak256(\\\"MembershipLedger\\\"));\\n  bytes4 internal constant MembershipVault = bytes4(keccak256(\\\"MembershipVault\\\"));\\n\\n  // Tokens\\n  bytes4 internal constant GFI = bytes4(keccak256(\\\"GFI\\\"));\\n  bytes4 internal constant FIDU = bytes4(keccak256(\\\"FIDU\\\"));\\n  bytes4 internal constant USDC = bytes4(keccak256(\\\"USDC\\\"));\\n\\n  // Cake\\n  bytes4 internal constant AccessControl = bytes4(keccak256(\\\"AccessControl\\\"));\\n  bytes4 internal constant Router = bytes4(keccak256(\\\"Router\\\"));\\n\\n  // Core\\n  bytes4 internal constant ReserveSplitter = bytes4(keccak256(\\\"ReserveSplitter\\\"));\\n  bytes4 internal constant PoolTokens = bytes4(keccak256(\\\"PoolTokens\\\"));\\n  bytes4 internal constant SeniorPool = bytes4(keccak256(\\\"SeniorPool\\\"));\\n  bytes4 internal constant StakingRewards = bytes4(keccak256(\\\"StakingRewards\\\"));\\n  bytes4 internal constant ProtocolAdmin = bytes4(keccak256(\\\"ProtocolAdmin\\\"));\\n  bytes4 internal constant PauserAdmin = bytes4(keccak256(\\\"PauserAdmin\\\"));\\n}\\n\\n/// @title Routing.Context\\n/// @notice This library provides convenience functions for getting contracts from `Router`.\\nlibrary Context {\\n  function accessControl(ContextContract context) internal view returns (IAccessControl) {\\n    return IAccessControl(context.router().contracts(Keys.AccessControl));\\n  }\\n\\n  function membershipVault(ContextContract context) internal view returns (IMembershipVault) {\\n    return IMembershipVault(context.router().contracts(Keys.MembershipVault));\\n  }\\n\\n  function capitalLedger(ContextContract context) internal view returns (ICapitalLedger) {\\n    return ICapitalLedger(context.router().contracts(Keys.CapitalLedger));\\n  }\\n\\n  function gfiLedger(ContextContract context) internal view returns (IGFILedger) {\\n    return IGFILedger(context.router().contracts(Keys.GFILedger));\\n  }\\n\\n  function gfi(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.GFI));\\n  }\\n\\n  function membershipDirector(ContextContract context) internal view returns (IMembershipDirector) {\\n    return IMembershipDirector(context.router().contracts(Keys.MembershipDirector));\\n  }\\n\\n  function membershipOrchestrator(ContextContract context) internal view returns (IMembershipOrchestrator) {\\n    return IMembershipOrchestrator(context.router().contracts(Keys.MembershipOrchestrator));\\n  }\\n\\n  function stakingRewards(ContextContract context) internal view returns (IStakingRewards) {\\n    return IStakingRewards(context.router().contracts(Keys.StakingRewards));\\n  }\\n\\n  function poolTokens(ContextContract context) internal view returns (IPoolTokens) {\\n    return IPoolTokens(context.router().contracts(Keys.PoolTokens));\\n  }\\n\\n  function seniorPool(ContextContract context) internal view returns (ISeniorPool) {\\n    return ISeniorPool(context.router().contracts(Keys.SeniorPool));\\n  }\\n\\n  function fidu(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.FIDU));\\n  }\\n\\n  function usdc(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.USDC));\\n  }\\n\\n  function reserveSplitter(ContextContract context) internal view returns (IERC20Splitter) {\\n    return IERC20Splitter(context.router().contracts(Keys.ReserveSplitter));\\n  }\\n\\n  function membershipLedger(ContextContract context) internal view returns (IMembershipLedger) {\\n    return IMembershipLedger(context.router().contracts(Keys.MembershipLedger));\\n  }\\n\\n  function membershipCollector(ContextContract context) internal view returns (IMembershipCollector) {\\n    return IMembershipCollector(context.router().contracts(Keys.MembershipCollector));\\n  }\\n\\n  function protocolAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.ProtocolAdmin);\\n  }\\n\\n  function pauserAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.PauserAdmin);\\n  }\\n}\\n\",\"keccak256\":\"0x4a324049c639da20482479082129fc570daa0f06dbdd25fdce46ad401f8ec7c5\",\"license\":\"MIT\"},\"contracts/interfaces/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ninterface IAccessControl {\\n  error RequiresAdmin(address resource, address accessor);\\n  error ZeroAddress();\\n\\n  event AdminSet(address indexed resource, address indexed admin);\\n\\n  /// @notice Set an admin for a given resource\\n  /// @param resource An address which with `admin` should be allowed to administer\\n  /// @param admin An address which should be allowed to administer `resource`\\n  /// @dev This method is only callable by the super-admin (the admin of this AccessControl\\n  ///   contract)\\n  function setAdmin(address resource, address admin) external;\\n\\n  /// @notice Require a valid admin for a given resource\\n  /// @param resource An address that `accessor` is attempting to access\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid admin\\n  function requireAdmin(address resource, address accessor) external view;\\n\\n  /// @notice Require a super-admin. A super-admin is an admin of this AccessControl contract.\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid super-admin\\n  function requireSuperAdmin(address accessor) external view;\\n}\\n\",\"keccak256\":\"0xa77d24e074f86c95657ada01678e9c7136b8769856182428f0f2cb6d191b341f\",\"license\":\"MIT\"},\"contracts/interfaces/ICapitalLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nenum CapitalAssetType {\\n  INVALID,\\n  ERC721\\n}\\n\\ninterface ICapitalLedger {\\n  /**\\n   * @notice Emitted when a new capital erc721 deposit has been made\\n   * @param owner address owning the deposit\\n   * @param assetAddress address of the deposited ERC721\\n   * @param positionId id for the deposit\\n   * @param assetTokenId id of the token from the ERC721 `assetAddress`\\n   * @param usdcEquivalent usdc equivalent value at the time of deposit\\n   */\\n  event CapitalERC721Deposit(\\n    address indexed owner,\\n    address indexed assetAddress,\\n    uint256 positionId,\\n    uint256 assetTokenId,\\n    uint256 usdcEquivalent\\n  );\\n\\n  /**\\n   * @notice Emitted when a new ERC721 capital withdrawal has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the capital position\\n   * @param assetAddress address of the underlying ERC721\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event CapitalERC721Withdrawal(\\n    address indexed owner,\\n    uint256 positionId,\\n    address assetAddress,\\n    uint256 depositTimestamp\\n  );\\n\\n  /// Thrown when called with an invalid asset type for the function. Valid\\n  /// types are defined under CapitalAssetType\\n  error InvalidAssetType(CapitalAssetType);\\n\\n  /**\\n   * @notice Account for a deposit of `id` for the ERC721 asset at `assetAddress`.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param owner address that owns the position\\n   * @param assetAddress address of the ERC20 address\\n   * @param assetTokenId id of the ERC721 asset to add\\n   * @return id of the newly created position\\n   */\\n  function depositERC721(\\n    address owner,\\n    address assetAddress,\\n    uint256 assetTokenId\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Get the id of the ERC721 asset held by position `id`. Pair this with\\n   *  `assetAddressOf` to get the address & id of the nft.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param positionId id of the position\\n   * @return id of the underlying ERC721 asset\\n   */\\n  function erc721IdOf(uint256 positionId) external view returns (uint256);\\n\\n  /**\\n   * @notice Completely withdraw a position\\n   * @param positionId id of the position\\n   */\\n  function withdraw(uint256 positionId) external;\\n\\n  /**\\n   * @notice Get the asset address of the position. Example: For an ERC721 position, this\\n   *  returns the address of that ERC721 contract.\\n   * @param positionId id of the position\\n   * @return asset address of the position\\n   */\\n  function assetAddressOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the number of capital positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return position id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the USDC value of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @param owner address owning the positions\\n   * @return eligibleAmount USDC value of positions eligible for rewards\\n   * @return totalAmount total USDC value of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xfd869b44e49041db9fb9ef2f6c00fcfceb38ba20f26631562cfb48fa2bec12ef\",\"license\":\"MIT\"},\"contracts/interfaces/ICreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICreditLine {\\n  function borrower() external view returns (address);\\n\\n  function limit() external view returns (uint256);\\n\\n  function maxLimit() external view returns (uint256);\\n\\n  function interestApr() external view returns (uint256);\\n\\n  function paymentPeriodInDays() external view returns (uint256);\\n\\n  function principalGracePeriodInDays() external view returns (uint256);\\n\\n  function termInDays() external view returns (uint256);\\n\\n  function lateFeeApr() external view returns (uint256);\\n\\n  function isLate() external view returns (bool);\\n\\n  function withinPrincipalGracePeriod() external view returns (bool);\\n\\n  // Accounting variables\\n  function balance() external view returns (uint256);\\n\\n  function interestOwed() external view returns (uint256);\\n\\n  function principalOwed() external view returns (uint256);\\n\\n  function termEndTime() external view returns (uint256);\\n\\n  function nextDueTime() external view returns (uint256);\\n\\n  function interestAccruedAsOf() external view returns (uint256);\\n\\n  function lastFullPaymentTime() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd54b264344ce302597ee4f04f147000275d05c8fc9612cc21eaff915ff1f30c8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Splitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IERC20Splitter {\\n  function lastDistributionAt() external view returns (uint256);\\n\\n  function distribute() external;\\n\\n  function replacePayees(address[] calldata _payees, uint256[] calldata _shares) external;\\n\\n  function pendingDistributionFor(address payee) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x915a4058d1c4f6e694e1fdbaa708d3ec7e26dba3162f83290d997ec484960972\",\"license\":\"MIT\"},\"contracts/interfaces/IGFILedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IGFILedger {\\n  struct Position {\\n    // Owner of the position\\n    address owner;\\n    // Index of the position in the ownership array\\n    uint256 ownedIndex;\\n    // Amount of GFI held in the position\\n    uint256 amount;\\n    // When the position was deposited\\n    uint256 depositTimestamp;\\n  }\\n\\n  /**\\n   * @notice Emitted when a new GFI deposit has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the deposit\\n   * @param amount how much GFI was deposited\\n   */\\n  event GFIDeposit(address indexed owner, uint256 indexed positionId, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when a new GFI withdrawal has been made. If the remaining amount is 0, the position has bee removed\\n   * @param owner address owning the withdrawn position\\n   * @param positionId id for the position\\n   * @param remainingAmount how much GFI is remaining in the position\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event GFIWithdrawal(\\n    address indexed owner,\\n    uint256 indexed positionId,\\n    uint256 withdrawnAmount,\\n    uint256 remainingAmount,\\n    uint256 depositTimestamp\\n  );\\n\\n  /**\\n   * @notice Account for a new deposit by the owner.\\n   * @param owner address to account for the deposit\\n   * @param amount how much was deposited\\n   * @return how much was deposited\\n   */\\n  function deposit(address owner, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @param amount how much to withdraw\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Get the number of GFI positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return token id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get amount of GFI of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @return eligibleAmount GFI amount of positions eligible for rewards\\n   * @return totalAmount total GFI amount of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xa4aa4178b7ffd3d92d0db9f489cea52b574df2207ae463433472ccd5d4b67372\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipCollector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipCollector {\\n  /// @notice Have the collector distribute `amount` of Fidu to `addr`\\n  /// @param addr address to distribute to\\n  /// @param amount amount to distribute\\n  function distributeFiduTo(address addr, uint256 amount) external;\\n\\n  /// @notice Get the last epoch finalized by the collector. This means the\\n  ///  collector will no longer add rewards to the epoch.\\n  /// @return the last finalized epoch\\n  function lastFinalizedEpoch() external view returns (uint256);\\n\\n  /// @notice Get the rewards associated with `epoch`. This amount may change\\n  ///  until `epoch` has been finalized (is less than or equal to getLastFinalizedEpoch)\\n  /// @return rewards associated with `epoch`\\n  function rewardsForEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n  ///  this will be the fixed, accurate reward for the epoch. For the current and other\\n  ///  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n  ///  moment.\\n  /// @param epoch epoch to estimate the rewards of\\n  /// @return rewards associated with `epoch`\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0x8ea890c7237ee09c340afa47bce4fe6fd2e6d65bce601620edb1513e4b0f3914\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipDirector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipDirector {\\n  /**\\n   * @notice Adjust an `owner`s membership score and position due to the change\\n   *  in their GFI and Capital holdings\\n   * @param owner address who's holdings changed\\n   * @return id of membership position\\n   */\\n  function consumeHoldingsAdjustment(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Collect all membership yield enhancements for the owner.\\n   * @param owner address to claim rewards for\\n   * @return amount of yield enhancements collected\\n   */\\n  function collectRewards(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable for the owner. The return\\n   *  value here is how much would be retrieved by calling `collectRewards`.\\n   * @param owner address to calculate claimable rewards for\\n   * @return the amount of rewards that could be claimed by the owner\\n   */\\n  function claimableRewards(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate the membership score\\n   * @param gfi Amount of gfi\\n   * @param capital Amount of capital in USDC\\n   * @return membership score\\n   */\\n  function calculateMembershipScore(uint256 gfi, uint256 capital) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the current score of `owner`\\n   * @param owner address to check the score of\\n   * @return eligibleScore score that is currently eligible for rewards\\n   * @return totalScore score that will be elgible for rewards next epoch\\n   */\\n  function currentScore(address owner) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc4ad3f9a21473122dc03f92db9f78b3da14468ff17f7892e5feb6fed6f882abd\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipLedger {\\n  /**\\n   * @notice Set `addr`s allocated rewards back to 0\\n   * @param addr address to reset rewards on\\n   */\\n  function resetRewards(address addr) external;\\n\\n  /**\\n   * @notice Allocate `amount` rewards for `addr` but do not send them\\n   * @param addr address to distribute rewards to\\n   * @param amount amount of rewards to allocate for `addr`\\n   * @return rewards total allocated to `addr`\\n   */\\n  function allocateRewardsTo(address addr, uint256 amount) external returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the rewards allocated to a certain `addr`\\n   * @param addr the address to check pending rewards for\\n   * @return rewards pending rewards for `addr`\\n   */\\n  function getPendingRewardsFor(address addr) external view returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the alpha parameter for the cobb douglas function. Will always be in (0,1).\\n   * @return numerator numerator for the alpha param\\n   * @return denominator denominator for the alpha param\\n   */\\n  function alpha() external view returns (uint128 numerator, uint128 denominator);\\n}\\n\",\"keccak256\":\"0x56bfc0d3ed5f532e3f36387d705f047252ba3cbeb8374e4bc51ed59a68197a33\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipOrchestrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nimport {Context} from \\\"../cake/Context.sol\\\";\\n\\nstruct CapitalDeposit {\\n  /// Address of the asset being deposited\\n  /// @dev must be supported in CapitalAssets.sol\\n  address assetAddress;\\n  /// Id of the nft\\n  uint256 id;\\n}\\n\\nstruct Deposit {\\n  /// Amount of gfi to deposit\\n  uint256 gfi;\\n  /// List of capital deposits\\n  CapitalDeposit[] capitalDeposits;\\n}\\n\\nstruct DepositResult {\\n  uint256 membershipId;\\n  uint256 gfiPositionId;\\n  uint256[] capitalPositionIds;\\n}\\n\\nstruct ERC20Withdrawal {\\n  uint256 id;\\n  uint256 amount;\\n}\\n\\nstruct Withdrawal {\\n  /// List of gfi token ids to withdraw\\n  ERC20Withdrawal[] gfiPositions;\\n  /// List of capital token ids to withdraw\\n  uint256[] capitalPositions;\\n}\\n\\n/**\\n * @title MembershipOrchestrator\\n * @notice Externally facing gateway to all Goldfinch membership functionality.\\n * @author Goldfinch\\n */\\ninterface IMembershipOrchestrator {\\n  /**\\n   * @notice Deposit multiple assets defined in `multiDeposit`. Assets can include GFI, Staked Fidu,\\n   *  and others.\\n   * @param deposit struct describing all the assets to deposit\\n   * @return ids all of the ids of the created depoits, in the same order as deposit. If GFI is\\n   *  present, it will be the first id.\\n   */\\n  function deposit(Deposit calldata deposit) external returns (DepositResult memory);\\n\\n  /**\\n   * @notice Withdraw multiple assets defined in `multiWithdraw`. Assets can be GFI or capital\\n   *  positions ids. Caller must have been permitted to act upon all of the positions.\\n   * @param withdrawal all of the GFI and Capital ids to withdraw\\n   */\\n  function withdraw(Withdrawal calldata withdrawal) external;\\n\\n  /**\\n   * @notice Collect all membership rewards for the caller.\\n   * @return how many rewards were collected and sent to caller\\n   */\\n  function collectRewards() external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable at this moment in time for caller.\\n   * @param addr the address to check claimable rewards for\\n   * @return how many rewards could be claimed by a call to `collectRewards`\\n   */\\n  function claimableRewards(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Check the voting power of a given address\\n   * @param addr the address to check the voting power of\\n   * @return the voting power\\n   */\\n  function votingPower(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get all GFI in Membership held by `addr`. This returns the current eligible amount and the\\n   *  total amount of GFI.\\n   * @param addr the owner\\n   * @return eligibleAmount how much GFI is currently eligible for rewards\\n   * @return totalAmount how much GFI is currently eligible for rewards\\n   */\\n  function totalGFIHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get all capital, denominated in USDC, in Membership held by `addr`. This returns the current\\n   *  eligible amount and the total USDC value of capital.\\n   * @param addr the owner\\n   * @return eligibleAmount how much USDC of capital is currently eligible for rewards\\n   * @return totalAmount how much  USDC of capital is currently eligible for rewards\\n   */\\n  function totalCapitalHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get the member score of `addr`\\n   * @param addr the owner\\n   * @return eligibleScore the currently eligible score\\n   * @return totalScore the total score that will be eligible next epoch\\n   *\\n   * @dev if eligibleScore == totalScore then there are no changes between now and the next epoch\\n   */\\n  function memberScoreOf(address addr) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n   *  this will be the fixed, accurate reward for the epoch. For the current and other\\n   *  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n   *  moment.\\n   * @param epoch epoch to estimate the rewards of\\n   * @return rewards associated with `epoch`\\n   */\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate what the Membership Score would be if a `gfi` amount of GFI and `capital` amount\\n   *  of Capital denominated in USDC were deposited.\\n   * @param gfi amount of GFI to estimate with\\n   * @param capital amount of capital to estimate with, denominated in USDC\\n   * @return score the resulting score\\n   */\\n  function calculateMemberScore(uint256 gfi, uint256 capital) external view returns (uint256 score);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc231b961b7ad5e98e45adcc355dd7d3f6f4dd5855486fba35d6f3ef466cbdee0\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\\\";\\n\\nstruct Position {\\n  // address owning the position\\n  address owner;\\n  // how much of the position is eligible as of checkpointEpoch\\n  uint256 eligibleAmount;\\n  // how much of the postion is eligible the epoch after checkpointEpoch\\n  uint256 nextEpochAmount;\\n  // when the position was first created\\n  uint256 createdTimestamp;\\n  // epoch of the last checkpoint\\n  uint256 checkpointEpoch;\\n}\\n\\n/**\\n * @title IMembershipVault\\n * @notice Track assets held by owners in a vault, as well as the total held in the vault. Assets\\n *  are not accounted for until the next epoch for MEV protection.\\n * @author Goldfinch\\n */\\ninterface IMembershipVault is IERC721Upgradeable {\\n  /**\\n   * @notice Emitted when an owner has adjusted their holdings in a vault\\n   * @param owner the owner increasing their holdings\\n   * @param eligibleAmount the new eligible amount\\n   * @param nextEpochAmount the new next epoch amount\\n   */\\n  event AdjustedHoldings(address indexed owner, uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Emitted when the total within the vault has changed\\n   * @param eligibleAmount new current amount\\n   * @param nextEpochAmount new next epoch amount\\n   */\\n  event VaultTotalUpdate(uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Get the current value of `owner`. This changes depending on the current\\n   *  block.timestamp as increased holdings are not accounted for until the subsequent epoch.\\n   * @param owner address owning the positions\\n   * @return sum of all positions held by an address\\n   */\\n  function currentValueOwnedBy(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of block.timestamp\\n   * @return total value in the vault as of block.timestamp\\n   */\\n  function currentTotal() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of epoch\\n   * @return total value in the vault as of epoch\\n   */\\n  function totalAtEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the position owned by `owner`\\n   * @return position owned by `owner`\\n   */\\n  function positionOwnedBy(address owner) external view returns (Position memory);\\n\\n  /**\\n   * @notice Record an adjustment in holdings. Eligible assets will update this epoch and\\n   *  total assets will become eligible the subsequent epoch.\\n   * @param owner the owner to checkpoint\\n   * @param eligibleAmount amount of points to apply to the current epoch\\n   * @param nextEpochAmount amount of points to apply to the next epoch\\n   * @return id of the position\\n   */\\n  function adjustHoldings(\\n    address owner,\\n    uint256 eligibleAmount,\\n    uint256 nextEpochAmount\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Checkpoint a specific owner & the vault total\\n   * @param owner the owner to checkpoint\\n   *\\n   * @dev to collect rewards, this must be called before `increaseHoldings` or\\n   *  `decreaseHoldings`. Those functions must call checkpoint internally\\n   *  so the historical data will be lost otherwise.\\n   */\\n  function checkpoint(address owner) external;\\n}\\n\",\"keccak256\":\"0x5979e109a0a813e0db1de7167625a77f35dab12d184d2eedf1be7ad9706974f7\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolTokens.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./openzeppelin/IERC721.sol\\\";\\n\\ninterface IPoolTokens is IERC721 {\\n  event TokenMinted(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    uint256 tranche\\n  );\\n\\n  event TokenRedeemed(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed,\\n    uint256 tranche\\n  );\\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\\n\\n  struct TokenInfo {\\n    address pool;\\n    uint256 tranche;\\n    uint256 principalAmount;\\n    uint256 principalRedeemed;\\n    uint256 interestRedeemed;\\n  }\\n\\n  struct MintParams {\\n    uint256 principalAmount;\\n    uint256 tranche;\\n  }\\n\\n  function mint(MintParams calldata params, address to) external returns (uint256);\\n\\n  function redeem(\\n    uint256 tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed\\n  ) external;\\n\\n  function withdrawPrincipal(uint256 tokenId, uint256 principalAmount) external;\\n\\n  function burn(uint256 tokenId) external;\\n\\n  function onPoolCreated(address newPool) external;\\n\\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\\n\\n  function validPool(address sender) external view returns (bool);\\n\\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9569823f1e5647f6a627035a341dee918ef58f8b1faefa2a9fd47e75c1f1420f\",\"license\":\"MIT\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title IRouter\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ninterface IRouter {\\n  event SetContract(bytes4 indexed key, address indexed addr);\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) external;\\n}\\n\",\"keccak256\":\"0xe2a04ffb3198fa9de6b8252e1c406eff3dfc0bf7555e2d420bf5e87925fa4d43\",\"license\":\"MIT\"},\"contracts/interfaces/ISeniorPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ITranchedPool.sol\\\";\\n\\nabstract contract ISeniorPool {\\n  uint256 public sharePrice;\\n  uint256 public totalLoansOutstanding;\\n  uint256 public totalWritedowns;\\n\\n  function deposit(uint256 amount) external virtual returns (uint256 depositShares);\\n\\n  function depositWithPermit(\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 depositShares);\\n\\n  function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\\n\\n  function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\\n\\n  function sweepToCompound() public virtual;\\n\\n  function sweepFromCompound() public virtual;\\n\\n  function invest(ITranchedPool pool) public virtual;\\n\\n  function estimateInvestment(ITranchedPool pool) public view virtual returns (uint256);\\n\\n  function redeem(uint256 tokenId) public virtual;\\n\\n  function writedown(uint256 tokenId) public virtual;\\n\\n  function calculateWritedown(uint256 tokenId) public view virtual returns (uint256 writedownAmount);\\n\\n  function assets() public view virtual returns (uint256);\\n\\n  function getNumShares(uint256 amount) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x529b3e34b03c6400e6cd8da7683b6d0daf1c8694dbbff889bd05f1a0b5923e9b\",\"license\":\"MIT\"},\"contracts/interfaces/IStakingRewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC721} from \\\"./openzeppelin/IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"./openzeppelin/IERC721Metadata.sol\\\";\\nimport {IERC721Enumerable} from \\\"./openzeppelin/IERC721Enumerable.sol\\\";\\n\\ninterface IStakingRewards is IERC721, IERC721Metadata, IERC721Enumerable {\\n  function getPosition(uint256 tokenId) external view returns (StakedPosition memory position);\\n\\n  function unstake(uint256 tokenId, uint256 amount) external;\\n\\n  function addToStake(uint256 tokenId, uint256 amount) external;\\n\\n  function stakedBalanceOf(uint256 tokenId) external view returns (uint256);\\n\\n  function depositToCurveAndStakeFrom(\\n    address nftRecipient,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount\\n  ) external;\\n\\n  function kick(uint256 tokenId) external;\\n\\n  function accumulatedRewardsPerToken() external view returns (uint256);\\n\\n  function lastUpdateTime() external view returns (uint256);\\n\\n  /* ========== EVENTS ========== */\\n\\n  event RewardAdded(uint256 reward);\\n  event Staked(\\n    address indexed user,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    StakedPositionType positionType,\\n    uint256 baseTokenExchangeRate\\n  );\\n  event DepositedAndStaked(address indexed user, uint256 depositedAmount, uint256 indexed tokenId, uint256 amount);\\n  event DepositedToCurve(address indexed user, uint256 fiduAmount, uint256 usdcAmount, uint256 tokensReceived);\\n  event DepositedToCurveAndStaked(\\n    address indexed user,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount,\\n    uint256 indexed tokenId,\\n    uint256 amount\\n  );\\n  event Unstaked(address indexed user, uint256 indexed tokenId, uint256 amount, StakedPositionType positionType);\\n  event UnstakedMultiple(address indexed user, uint256[] tokenIds, uint256[] amounts);\\n  event UnstakedAndWithdrew(address indexed user, uint256 usdcReceivedAmount, uint256 indexed tokenId, uint256 amount);\\n  event UnstakedAndWithdrewMultiple(\\n    address indexed user,\\n    uint256 usdcReceivedAmount,\\n    uint256[] tokenIds,\\n    uint256[] amounts\\n  );\\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\\n  event RewardsParametersUpdated(\\n    address indexed who,\\n    uint256 targetCapacity,\\n    uint256 minRate,\\n    uint256 maxRate,\\n    uint256 minRateAtPercent,\\n    uint256 maxRateAtPercent\\n  );\\n  event EffectiveMultiplierUpdated(address indexed who, StakedPositionType positionType, uint256 multiplier);\\n}\\n\\n/// @notice Indicates which ERC20 is staked\\nenum StakedPositionType {\\n  Fidu,\\n  CurveLP\\n}\\n\\nstruct Rewards {\\n  uint256 totalUnvested;\\n  uint256 totalVested;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this was used in the case of slashing.\\n  //   For non-vesting positions, this is unused.\\n  uint256 totalPreviouslyVested;\\n  uint256 totalClaimed;\\n  uint256 startTime;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this is the endTime of the vesting.\\n  //   For non-vesting positions, this is 0.\\n  uint256 endTime;\\n}\\n\\nstruct StakedPosition {\\n  // @notice Staked amount denominated in `stakingToken().decimals()`\\n  uint256 amount;\\n  // @notice Struct describing rewards owed with vesting\\n  Rewards rewards;\\n  // @notice Multiplier applied to staked amount when locking up position\\n  uint256 leverageMultiplier;\\n  // @notice Time in seconds after which position can be unstaked\\n  uint256 lockedUntil;\\n  // @notice Type of the staked position\\n  StakedPositionType positionType;\\n  // @notice Multiplier applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeEffectiveMultiplier()`, which correctly handles old staked positions.\\n  uint256 unsafeEffectiveMultiplier;\\n  // @notice Exchange rate applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeBaseTokenExchangeRate()`, which correctly handles old staked positions.\\n  uint256 unsafeBaseTokenExchangeRate;\\n}\\n\",\"keccak256\":\"0xb001875f3e7a6414f8e72cf25afdd30cd949fd2b0a219a4778b8027ef1d26667\",\"license\":\"MIT\"},\"contracts/interfaces/ITranchedPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {IV2CreditLine} from \\\"./IV2CreditLine.sol\\\";\\n\\nabstract contract ITranchedPool {\\n  IV2CreditLine public creditLine;\\n  uint256 public createdAt;\\n  enum Tranches {\\n    Reserved,\\n    Senior,\\n    Junior\\n  }\\n\\n  struct TrancheInfo {\\n    uint256 id;\\n    uint256 principalDeposited;\\n    uint256 principalSharePrice;\\n    uint256 interestSharePrice;\\n    uint256 lockedUntil;\\n  }\\n\\n  struct PoolSlice {\\n    TrancheInfo seniorTranche;\\n    TrancheInfo juniorTranche;\\n    uint256 totalInterestAccrued;\\n    uint256 principalDeployed;\\n  }\\n\\n  function initialize(\\n    address _config,\\n    address _borrower,\\n    uint256 _juniorFeePercent,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays,\\n    uint256 _fundableAt,\\n    uint256[] calldata _allowedUIDTypes\\n  ) public virtual;\\n\\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\\n\\n  function pay(uint256 amount) external virtual;\\n\\n  function poolSlices(uint256 index) external view virtual returns (PoolSlice memory);\\n\\n  function lockJuniorCapital() external virtual;\\n\\n  function lockPool() external virtual;\\n\\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\\n\\n  function totalJuniorDeposits() external view virtual returns (uint256);\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function setFundableAt(uint256 timestamp) external virtual;\\n\\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\\n\\n  function assess() external virtual;\\n\\n  function depositWithPermit(\\n    uint256 tranche,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 tokenId);\\n\\n  function availableToWithdraw(uint256 tokenId)\\n    external\\n    view\\n    virtual\\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\\n\\n  function withdraw(uint256 tokenId, uint256 amount)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMax(uint256 tokenId)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\\n\\n  function numSlices() external view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x7a21d304a7ba635f4a074488d152c62c6b8b442cc5a5ad85a454621f4baec659\",\"license\":\"MIT\"},\"contracts/interfaces/IV2CreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ICreditLine.sol\\\";\\n\\nabstract contract IV2CreditLine is ICreditLine {\\n  function principal() external view virtual returns (uint256);\\n\\n  function totalInterestAccrued() external view virtual returns (uint256);\\n\\n  function termStartTime() external view virtual returns (uint256);\\n\\n  function setLimit(uint256 newAmount) external virtual;\\n\\n  function setMaxLimit(uint256 newAmount) external virtual;\\n\\n  function setBalance(uint256 newBalance) external virtual;\\n\\n  function setPrincipal(uint256 _principal) external virtual;\\n\\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function assess()\\n    external\\n    virtual\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function initialize(\\n    address _config,\\n    address owner,\\n    address _borrower,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays\\n  ) public virtual;\\n\\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\\n\\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\\n\\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\\n\\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\\n\\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\\n\\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\\n\\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\\n\\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\\n}\\n\",\"keccak256\":\"0xc72be7462ade69ec2d4bb18344cfe1c8b4659bd68314cef013aa5616bfe8f607\",\"license\":\"MIT\"},\"contracts/interfaces/openzeppelin/IERC165.sol\":{\"content\":\"pragma solidity >=0.6.0;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbbdb8f6dfaecd47a0d65bee707877d6974a0e0da6c02403ad5ce00590bd97497\"},\"contracts/interfaces/openzeppelin/IERC721.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >= & reference other >= pragma interfaces.\\n// NOTE: Modified to reference our updated pragma version of IERC165\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of NFTs in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the NFT specified by `tokenId`.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   *\\n   *\\n   * Requirements:\\n   * - `from`, `to` cannot be zero.\\n   * - `tokenId` must be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this\\n   * NFT by either {approve} or {setApprovalForAll}.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Requirements:\\n   * - If the caller is not `from`, it must be approved to move this NFT by\\n   * either {approve} or {setApprovalForAll}.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  function approve(address to, uint256 tokenId) external;\\n\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x2527635bd6ab0d348f5f7d325ef2241a544586bb85dd806053adf1cc409293e5\"},\"contracts/interfaces/openzeppelin/IERC721Enumerable.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x7fd709ba4093899fc4593cb1413132e127773a349a8aef9ce234d62fa36b5fca\"},\"contracts/interfaces/openzeppelin/IERC721Metadata.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x56c56c47d03d0ea452a13842ad2e3e5b81b3689c484efd35a48f3977e9b929d8\"},\"contracts/protocol/core/ERC721NonTransferable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\\\";\\n\\n/**\\n * @title A read only ERC721 token\\n * @notice A abstract registry of NFTs that only allows reading the NFTs and nothing\\n *         else (no minting, transferring, etc). This acts as a \\\"view\\\" into some set\\n *         of NFTs that may not otherwise adhere to the ERC721 standard.\\n * @dev See `Transfer Mechanism` in the following link for the inspiration\\n *      behind this class: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md#rationale\\n */\\n\\nabstract contract ERC721NonTransferable is IERC721Upgradeable {\\n  // Throw if a mutating function is called\\n  error ReadOnly();\\n\\n  function safeTransferFrom(\\n    address,\\n    address,\\n    uint256\\n  ) external pure {\\n    revert ReadOnly();\\n  }\\n\\n  function transferFrom(\\n    address,\\n    address,\\n    uint256\\n  ) external pure {\\n    revert ReadOnly();\\n  }\\n\\n  function approve(address, uint256) external pure {\\n    revert ReadOnly();\\n  }\\n\\n  function getApproved(uint256) external pure returns (address) {\\n    revert ReadOnly();\\n  }\\n\\n  function setApprovalForAll(address, bool) external pure {\\n    revert ReadOnly();\\n  }\\n\\n  function isApprovedForAll(address, address) external pure returns (bool) {\\n    revert ReadOnly();\\n  }\\n\\n  function safeTransferFrom(\\n    address,\\n    address,\\n    uint256,\\n    bytes calldata\\n  ) external pure {\\n    revert ReadOnly();\\n  }\\n}\\n\",\"keccak256\":\"0x39a24138ce15a686d0bd75382d698dd764966946522cedbcc933399bff8caf84\",\"license\":\"MIT\"},\"contracts/protocol/core/ERCInterfaces.sol\":{\"content\":\"pragma solidity ^0.8.16;\\n\\nlibrary ERCInterfaces {\\n  bytes4 internal constant ERC721 = 0x80ac58cd;\\n  bytes4 internal constant ERC721_ENUMERABLE = 0x780e9d63;\\n  bytes4 internal constant ERC165 = 0x01ffc9a7;\\n}\\n\",\"keccak256\":\"0x7ba4ae6ec0ea5dba5d5ac767697c307d9289c63721d6875ca0c6e917fe4e7d79\"},\"contracts/protocol/core/membership/Epochs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary Epochs {\\n  uint256 internal constant EPOCH_SECONDS = 7 days;\\n\\n  /**\\n   * @notice Get the epoch containing the timestamp `s`\\n   * @param s the timestamp\\n   * @return corresponding epoch\\n   */\\n  function fromSeconds(uint256 s) internal pure returns (uint256) {\\n    return s / EPOCH_SECONDS;\\n  }\\n\\n  /**\\n   * @notice Get the current epoch for the block.timestamp\\n   * @return current epoch\\n   */\\n  function current() internal view returns (uint256) {\\n    return fromSeconds(block.timestamp);\\n  }\\n\\n  /**\\n   * @notice Get the start timestamp for the current epoch\\n   * @return current epoch start timestamp\\n   */\\n  function currentEpochStartTimestamp() internal view returns (uint256) {\\n    return startOf(current());\\n  }\\n\\n  /**\\n   * @notice Get the previous epoch given block.timestamp\\n   * @return previous epoch\\n   */\\n  function previous() internal view returns (uint256) {\\n    return current() - 1;\\n  }\\n\\n  /**\\n   * @notice Get the next epoch given block.timestamp\\n   * @return next epoch\\n   */\\n  function next() internal view returns (uint256) {\\n    return current() + 1;\\n  }\\n\\n  /**\\n   * @notice Get the Unix timestamp of the start of `epoch`\\n   * @param epoch the epoch\\n   * @return unix timestamp\\n   */\\n  function startOf(uint256 epoch) internal pure returns (uint256) {\\n    return epoch * EPOCH_SECONDS;\\n  }\\n}\\n\",\"keccak256\":\"0xa1d08c0e15d503ca9fa94d6633109cfc221fd31b0a8889685c8c3582efcd758b\",\"license\":\"MIT\"},\"contracts/protocol/core/membership/MembershipVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable func-name-mixedcase\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721EnumerableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721MetadataUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\n\\nimport {IMembershipVault, Position} from \\\"../../../interfaces/IMembershipVault.sol\\\";\\n\\nimport {Context} from \\\"../../../cake/Context.sol\\\";\\nimport {Base} from \\\"../../../cake/Base.sol\\\";\\nimport \\\"../../../cake/Routing.sol\\\" as Routing;\\n\\nimport {ERC721NonTransferable} from \\\"../ERC721NonTransferable.sol\\\";\\nimport {Epochs} from \\\"./Epochs.sol\\\";\\n\\nimport {ERCInterfaces} from \\\"../ERCInterfaces.sol\\\";\\n\\nusing Routing.Context for Context;\\nusing StringsUpgradeable for uint256;\\n\\n/**\\n * @title MembershipVault\\n * @notice Track assets held by owners in a vault, as well as the total held in the vault. Assets\\n *  are not accounted for until the next epoch for MEV protection.\\n * @author Goldfinch\\n */\\ncontract MembershipVault is\\n  IMembershipVault,\\n  Base,\\n  ERC721NonTransferable,\\n  IERC721EnumerableUpgradeable,\\n  IERC721MetadataUpgradeable,\\n  Initializable\\n{\\n  /// Thrown when depositing from address(0)\\n  error ZeroAddressInvalid();\\n  /// Thrown when trying to access tokens from an address with no tokens\\n  error NoTokensOwned();\\n  /// Thrown when trying to access more than one token for an address\\n  error OneTokenPerAddress();\\n  /// Thrown when querying token supply with an index greater than the supply\\n  error IndexGreaterThanTokenSupply();\\n  /// Thrown when checking totals in future epochs\\n  error NoTotalsInFutureEpochs();\\n  /// Thrown when adjusting holdings in an unsupported way\\n  error InvalidHoldingsAdjustment(uint256 eligibleAmount, uint256 nextEpochAmount);\\n  /// Thrown when requesting a nonexistant token\\n  error NonexistantToken(uint256 tokenId);\\n\\n  /**\\n   * @notice The vault has been checkpointed\\n   * @param total how much is stored in the vault at the current block.timestamp\\n   */\\n  event Checkpoint(uint256 total);\\n\\n  /// @notice Totals by epoch. totalAmounts is always tracking past epochs, the current\\n  ///   epoch, and the next epoch. There are a few cases:\\n  ///   1. Checkpointing\\n  ///      Noop for the same epoch. Checkpointing occurs before any mutative action\\n  ///      so for new epochs, the last-set epoch value (totalAmounts[previousEpoch + 1])\\n  ///      is copied to each epoch up to the current epoch + 1\\n  ///   2. Increasing\\n  ///      Checkpointing already occurred, so current epoch and next epoch\\n  ///      are properly set up. Increasing just updates the next epoch value\\n  ///   3. Decreasing\\n  ///      Checkpointing already occurred like above. Decreasing updates the eligible\\n  ///      and next epoch values\\n  mapping(uint256 => uint256) private totalAmounts;\\n\\n  /// @notice last epoch the vault was checkpointed\\n  uint256 private checkpointEpoch;\\n\\n  /// @notice all positions held by the vault\\n  mapping(uint256 => Position) private positions;\\n\\n  /// @notice owners and their position\\n  mapping(address => uint256) private owners;\\n\\n  /// @notice counter tracking most current membership id\\n  uint256 private membershipIdsTracker;\\n\\n  /// @notice base uri for the nft\\n  string public baseURI;\\n\\n  //solhint-disable-next-line no-empty-blocks\\n  constructor(Context _context) Base(_context) {}\\n\\n  function initialize() public initializer {\\n    checkpointEpoch = Epochs.current();\\n  }\\n\\n  //////////////////////////////////////////////////////////////////\\n  // ERC 721 + Enumerable\\n\\n  function totalSupply() public view returns (uint256) {\\n    return membershipIdsTracker;\\n  }\\n\\n  function ownerOf(uint256 membershipId) external view returns (address owner) {\\n    return positions[membershipId].owner;\\n  }\\n\\n  function balanceOf(address owner) external view returns (uint256) {\\n    return owners[owner] > 0 ? 1 : 0;\\n  }\\n\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\\n    uint256 membershipId = owners[owner];\\n    if (membershipId == 0) revert NoTokensOwned();\\n    if (index > 0) revert OneTokenPerAddress();\\n\\n    return membershipId;\\n  }\\n\\n  function tokenByIndex(uint256 index) external view returns (uint256) {\\n    if (index >= totalSupply()) revert IndexGreaterThanTokenSupply();\\n\\n    return index + 1;\\n  }\\n\\n  function supportsInterface(bytes4 id) external pure override returns (bool) {\\n    return (id == ERCInterfaces.ERC721 || id == ERCInterfaces.ERC721_ENUMERABLE || id == ERCInterfaces.ERC165);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////\\n  // ERC721 Metadata\\n\\n  /// @inheritdoc IERC721MetadataUpgradeable\\n  function name() external pure returns (string memory) {\\n    return \\\"Goldfinch Membership\\\";\\n  }\\n\\n  /// @inheritdoc IERC721MetadataUpgradeable\\n  function symbol() external pure returns (string memory) {\\n    return \\\"GFMEMBER\\\";\\n  }\\n\\n  /// @inheritdoc IERC721MetadataUpgradeable\\n  function tokenURI(uint256 tokenId) external view returns (string memory) {\\n    if (tokenId == 0) revert NonexistantToken(tokenId);\\n    if (tokenId > membershipIdsTracker) revert NonexistantToken(tokenId);\\n\\n    return string(abi.encodePacked(baseURI, tokenId.toString()));\\n  }\\n\\n  /// @notice Set the base uri for the contract\\n  function setBaseURI(string calldata uri) external onlyAdmin {\\n    baseURI = uri;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////\\n  // IMembershipVault\\n\\n  /// @inheritdoc IMembershipVault\\n  function currentValueOwnedBy(address owner) external view override returns (uint256) {\\n    Position memory position = positions[owners[owner]];\\n    if (Epochs.current() > position.checkpointEpoch) {\\n      return position.nextEpochAmount;\\n    }\\n\\n    return position.eligibleAmount;\\n  }\\n\\n  /// @inheritdoc IMembershipVault\\n  function currentTotal() external view override returns (uint256) {\\n    return totalAtEpoch(Epochs.current());\\n  }\\n\\n  /// @inheritdoc IMembershipVault\\n  function totalAtEpoch(uint256 epoch) public view returns (uint256) {\\n    if (epoch > Epochs.next()) revert NoTotalsInFutureEpochs();\\n\\n    if (epoch > checkpointEpoch) {\\n      // If querying for an epoch past the checkpoint, always use the next amount. This is the amount\\n      // that will become eligible for every epoch after `checkpointEpoch`.\\n\\n      return totalAmounts[checkpointEpoch + 1];\\n    }\\n\\n    return totalAmounts[epoch];\\n  }\\n\\n  /// @inheritdoc IMembershipVault\\n  function positionOwnedBy(address owner) external view returns (Position memory) {\\n    return positions[owners[owner]];\\n  }\\n\\n  // @inheritdoc IMembershipVault\\n  function adjustHoldings(\\n    address owner,\\n    uint256 eligibleAmount,\\n    uint256 nextEpochAmount\\n  ) external onlyOperator(Routing.Keys.MembershipDirector) returns (uint256) {\\n    if (nextEpochAmount < eligibleAmount) revert InvalidHoldingsAdjustment(eligibleAmount, nextEpochAmount);\\n\\n    uint256 membershipId = _fetchOrCreateMembership(owner);\\n\\n    _checkpoint(owner);\\n\\n    Position memory position = positions[membershipId];\\n\\n    positions[membershipId].eligibleAmount = eligibleAmount;\\n    positions[membershipId].nextEpochAmount = nextEpochAmount;\\n\\n    totalAmounts[Epochs.current()] = (totalAmounts[Epochs.current()] - position.eligibleAmount) + eligibleAmount;\\n    totalAmounts[Epochs.next()] = (totalAmounts[Epochs.next()] - position.nextEpochAmount) + nextEpochAmount;\\n\\n    emit AdjustedHoldings({owner: owner, eligibleAmount: eligibleAmount, nextEpochAmount: nextEpochAmount});\\n    emit VaultTotalUpdate({\\n      eligibleAmount: totalAmounts[Epochs.current()],\\n      nextEpochAmount: totalAmounts[Epochs.next()]\\n    });\\n\\n    return membershipId;\\n  }\\n\\n  // @inheritdoc IMembershipVault\\n  function checkpoint(address owner) external onlyOperator(Routing.Keys.MembershipDirector) {\\n    return _checkpoint(owner);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////\\n  // Private\\n\\n  function _fetchOrCreateMembership(address owner) private returns (uint256) {\\n    if (owner == address(0)) revert ZeroAddressInvalid();\\n\\n    uint256 membershipId = owners[owner];\\n    if (membershipId > 0) return membershipId;\\n\\n    membershipIdsTracker++;\\n    membershipId = membershipIdsTracker;\\n\\n    positions[membershipId].owner = owner;\\n    positions[membershipId].createdTimestamp = block.timestamp;\\n    positions[membershipId].checkpointEpoch = Epochs.current();\\n\\n    owners[owner] = membershipId;\\n\\n    emit Transfer({from: address(0), to: owner, tokenId: membershipId});\\n\\n    return membershipId;\\n  }\\n\\n  function _checkpoint(address owner) private {\\n    uint256 currentEpoch = Epochs.current();\\n\\n    if (currentEpoch > checkpointEpoch) {\\n      // Promote the last checkpoint's nextAmount to all subsequent epochs up to currentEpoch + 1. This\\n      // guarantees that total[current] and total[next] are always properly set before any operations\\n      // are performed.\\n      uint256 lastCheckpointNextAmount = totalAmounts[checkpointEpoch + 1];\\n      for (uint256 epoch = checkpointEpoch + 2; epoch <= currentEpoch + 1; epoch++) {\\n        totalAmounts[epoch] = lastCheckpointNextAmount;\\n      }\\n\\n      checkpointEpoch = Epochs.current();\\n    }\\n\\n    uint256 membershipId = owners[owner];\\n    if (membershipId > 0) {\\n      // positionId of 0 means that no position exists. This occurs if checkpoint is called\\n      // before a position is created.\\n\\n      Position memory previousPosition = positions[membershipId];\\n\\n      // Promote `nextEpochAmount` to `eligibleAmount` if epochs have progressed\\n      if (currentEpoch > previousPosition.checkpointEpoch) {\\n        positions[membershipId].eligibleAmount = previousPosition.nextEpochAmount;\\n        positions[membershipId].checkpointEpoch = Epochs.current();\\n      }\\n    }\\n\\n    emit Checkpoint(totalAmounts[Epochs.current()]);\\n  }\\n}\\n\",\"keccak256\":\"0x2a856dde31a1a83774793f06a2cbc8a92d225a7bcda7559827c200529e49ac06\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b5060405161182038038061182083398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b60805161178e6100926000396000818161057101526110c2015261178e6000f3fe608060405234801561001057600080fd5b50600436106101635760003560e01c80636352211e116100ce578063a22cb46511610087578063a22cb46514610300578063a350ed481461030e578063a5f2f66714610321578063a972985e1461037a578063b88d4fde1461038d578063c87b56dd1461039b578063e985e9c5146103ae57600080fd5b80636352211e1461027d5780636c0360eb146102a657806370a08231146102ae5780638129fc1c146102c15780639017a13c146102c957806395d89b41146102dc57600080fd5b80632f745c59116101205780632f745c59146102295780633da8bfc91461023c5780633de2d9721461024457806342842e0e1461021b5780634f6ccce71461025757806355f804b31461026a57600080fd5b806301ffc9a71461016857806306fdde0314610190578063081812fc146101c9578063095ea7b3146101f457806318160ddd1461020957806323b872dd1461021b575b600080fd5b61017b6101763660046111bf565b6103bc565b60405190151581526020015b60405180910390f35b6040805180820190915260148152730476f6c6466696e6368204d656d626572736869760641b60208201525b604051610187919061120d565b6101dc6101d7366004611240565b61040e565b6040516001600160a01b039091168152602001610187565b61020761020236600461126e565b610429565b005b6005545b604051908152602001610187565b61020761020236600461129a565b61020d61023736600461126e565b610442565b61020d6104a1565b61020d6102523660046112db565b6104b3565b61020d610265366004611240565b610537565b610207610278366004611341565b61056c565b6101dc61028b366004611240565b6000908152600360205260409020546001600160a01b031690565b6101bc610612565b61020d6102bc3660046112db565b6106a0565b6102076106d0565b61020d6102d7366004611240565b610793565b60408051808201909152600881526723a326a2a6a122a960c11b60208201526101bc565b610207610202366004611383565b61020d61031c3660046113c1565b610803565b61033461032f3660046112db565b610a43565b604051610187919081516001600160a01b031681526020808301519082015260408083015190820152606080830151908201526080918201519181019190915260a00190565b6102076103883660046112db565b610ade565b6102076102023660046113f6565b6101bc6103a9366004611240565b610b16565b61017b6101d7366004611469565b60006001600160e01b031982166380ac58cd60e01b14806103ed57506001600160e01b0319821663780e9d6360e01b145b8061040857506001600160e01b031982166301ffc9a760e01b145b92915050565b6000604051631a850ed760e31b815260040160405180910390fd5b604051631a850ed760e31b815260040160405180910390fd5b6001600160a01b03821660009081526004602052604081205480820361047b576040516334b5d06d60e21b815260040160405180910390fd5b821561049a57604051632316143b60e11b815260040160405180910390fd5b9392505050565b60006104ae6102d7610b94565b905090565b6001600160a01b0380821660009081526004602081815260408084205484526003808352818520825160a08101845281549097168752600181015493870193909352600283015491860191909152810154606085015201546080830181905290919061051d610b94565b111561052d576040015192915050565b6020015192915050565b600061054260055490565b821061056157604051633f7ee38f60e11b815260040160405180910390fd5b6104088260016114ad565b61059e7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610b9f565b604051632a6e138b60e11b81523060048201523360248201526001600160a01b0391909116906354dc27169060440160006040518083038186803b1580156105e557600080fd5b505afa1580156105f9573d6000803e3d6000fd5b506006925061060d9150839050848361155e565b505050565b6006805461061f906114d6565b80601f016020809104026020016040519081016040528092919081815260200182805461064b906114d6565b80156106985780601f1061066d57610100808354040283529160200191610698565b820191906000526020600020905b81548152906001019060200180831161067b57829003601f168201915b505050505081565b6001600160a01b0381166000908152600460205260408120546106c45760006106c7565b60015b60ff1692915050565b600054610100900460ff16806106e9575060005460ff16155b6107515760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b600054610100900460ff16158015610773576000805461ffff19166101011790555b61077b610b94565b6002558015610790576000805461ff00191690555b50565b600061079d610c8f565b8211156107bd57604051630bb92ffd60e21b815260040160405180910390fd5b6002548211156107f0576001600060025460016107da91906114ad565b8152602001908152602001600020549050919050565b5060009081526001602052604090205490565b60007f037db0999be9065c5f1306135b75a6ae2af104ed9f0d72669950e21e87a33f766108308133610ca4565b8383101561085b576040516368caeba760e01b81526004810185905260248101849052604401610748565b600061086686610d03565b905061087186610e02565b6000818152600360208181526040808420815160a08101835281546001600160a01b031681526001808301805483870190815260028501805496850196909652848801546060850152600490940154608084015288885295909452938a905590889055519192889291906108e3610b94565b8152602001908152602001600020546108fc919061161f565b61090691906114ad565b60016000610912610b94565b81526020019081526020016000208190555084816040015160016000610936610c8f565b81526020019081526020016000205461094f919061161f565b61095991906114ad565b60016000610965610c8f565b815260200190815260200160002081905550866001600160a01b03167fb5ac373069545fdd5da402c94d10b968168eb2c09893e9a1a1fd087b2b3b34b187876040516109bb929190918252602082015260400190565b60405180910390a27f32ea6f1ec4de7460c440fd872b28a1f5e867728132b4dcba7af1f3dfef775ba2600160006109f0610b94565b81526020019081526020016000205460016000610a0b610c8f565b815260200190815260200160002054604051610a31929190918252602082015260400190565b60405180910390a15095945050505050565b610a7e6040518060a0016040528060006001600160a01b03168152602001600081526020016000815260200160008152602001600081525090565b506001600160a01b039081166000908152600460208181526040808420548452600380835293819020815160a081018352815490961686526001810154928601929092526002820154908501529182015460608401520154608082015290565b7f037db0999be9065c5f1306135b75a6ae2af104ed9f0d72669950e21e87a33f76610b098133610ca4565b610b1282610e02565b5050565b606081600003610b3c57604051637705f84560e01b815260048101839052602401610748565b600554821115610b6257604051637705f84560e01b815260048101839052602401610748565b6006610b6d83610f9c565b604051602001610b7e929190611632565b6040516020818303038152906040529050919050565b60006104ae426110a5565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bdf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c0391906116b9565b6001600160a01b0316630c0450127f9a671f6643eb8ac838fd3c79576dd800fe704b35ad30189c60f0f14dab948f2a6040518263ffffffff1660e01b8152600401610c4e91906116d6565b602060405180830381865afa158015610c6b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040891906116b9565b6000610c99610b94565b6104ae9060016114ad565b6001600160a01b038116610ccb5760405163d92e233d60e01b815260040160405180910390fd5b610cd582826110b4565b610b125760405163889a56bb60e01b81523060048201526001600160a01b0382166024820152604401610748565b60006001600160a01b038216610d2c57604051630a64406560e11b815260040160405180910390fd5b6001600160a01b0382166000908152600460205260409020548015610d515792915050565b60058054906000610d61836116eb565b9091555050600554600081815260036020819052604090912080546001600160a01b0319166001600160a01b038716178155429101559050610da1610b94565b60008281526003602090815260408083206004908101949094556001600160a01b0387168084529390915280822084905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a492915050565b6000610e0c610b94565b9050600254811115610e94576000600160006002546001610e2d91906114ad565b815260200190815260200160002054905060006002546002610e4f91906114ad565b90505b610e5d8360016114ad565b8111610e8657600081815260016020526040902082905580610e7e816116eb565b915050610e52565b50610e8f610b94565b600255505b6001600160a01b0382166000908152600460205260409020548015610f4457600081815260036020818152604092839020835160a08101855281546001600160a01b0316815260018201549281019290925260028101549382019390935290820154606082015260049091015460808201819052831115610f4257604080820151600084815260036020529190912060010155610f2f610b94565b6000838152600360205260409020600401555b505b7fde5ae8a37da230f7df39b8ea385fa1ab48e7caa55f1c25eaaef1ed8690f3699860016000610f71610b94565b815260200190815260200160002054604051610f8f91815260200190565b60405180910390a1505050565b606081600003610fc35750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610fed5780610fd7816116eb565b9150610fe69050600a8361171a565b9150610fc7565b60008167ffffffffffffffff811115611008576110086114c0565b6040519080825280601f01601f191660200182016040528015611032576020820181803683370190505b5090505b841561109d5761104760018361161f565b9150611054600a8661172e565b61105f9060306114ad565b60f81b81838151811061107457611074611742565b60200101906001600160f81b031916908160001a905350611096600a8661171a565b9450611036565b949350505050565b600061040862093a808361171a565b6000816001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa15801561111e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061114291906116b9565b6001600160a01b0316630c045012856040518263ffffffff1660e01b815260040161116d91906116d6565b602060405180830381865afa15801561118a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ae91906116b9565b6001600160a01b0316149392505050565b6000602082840312156111d157600080fd5b81356001600160e01b03198116811461049a57600080fd5b60005b838110156112045781810151838201526020016111ec565b50506000910152565b602081526000825180602084015261122c8160408501602087016111e9565b601f01601f19169190910160400192915050565b60006020828403121561125257600080fd5b5035919050565b6001600160a01b038116811461079057600080fd5b6000806040838503121561128157600080fd5b823561128c81611259565b946020939093013593505050565b6000806000606084860312156112af57600080fd5b83356112ba81611259565b925060208401356112ca81611259565b929592945050506040919091013590565b6000602082840312156112ed57600080fd5b813561049a81611259565b60008083601f84011261130a57600080fd5b50813567ffffffffffffffff81111561132257600080fd5b60208301915083602082850101111561133a57600080fd5b9250929050565b6000806020838503121561135457600080fd5b823567ffffffffffffffff81111561136b57600080fd5b611377858286016112f8565b90969095509350505050565b6000806040838503121561139657600080fd5b82356113a181611259565b9150602083013580151581146113b657600080fd5b809150509250929050565b6000806000606084860312156113d657600080fd5b83356113e181611259565b95602085013595506040909401359392505050565b60008060008060006080868803121561140e57600080fd5b853561141981611259565b9450602086013561142981611259565b935060408601359250606086013567ffffffffffffffff81111561144c57600080fd5b611458888289016112f8565b969995985093965092949392505050565b6000806040838503121561147c57600080fd5b823561148781611259565b915060208301356113b681611259565b634e487b7160e01b600052601160045260246000fd5b8082018082111561040857610408611497565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806114ea57607f821691505b60208210810361150a57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561060d57600081815260208120601f850160051c810160208610156115375750805b601f850160051c820191505b8181101561155657828155600101611543565b505050505050565b67ffffffffffffffff831115611576576115766114c0565b61158a8361158483546114d6565b83611510565b6000601f8411600181146115be57600085156115a65750838201355b600019600387901b1c1916600186901b178355611618565b600083815260209020601f19861690835b828110156115ef57868501358255602094850194600190920191016115cf565b508682101561160c5760001960f88860031b161c19848701351681555b505060018560011b0183555b5050505050565b8181038181111561040857610408611497565b6000808454611640816114d6565b60018281168015611658576001811461166d5761169c565b60ff198416875282151583028701945061169c565b8860005260208060002060005b858110156116935781548a82015290840190820161167a565b50505082870194505b5050505083516116b08183602088016111e9565b01949350505050565b6000602082840312156116cb57600080fd5b815161049a81611259565b6001600160e01b031991909116815260200190565b6000600182016116fd576116fd611497565b5060010190565b634e487b7160e01b600052601260045260246000fd5b60008261172957611729611704565b500490565b60008261173d5761173d611704565b500690565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220ef774c7db2d4ff1868e41276f302b861e7826ce08df1640db58558ea4ca4741464736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101635760003560e01c80636352211e116100ce578063a22cb46511610087578063a22cb46514610300578063a350ed481461030e578063a5f2f66714610321578063a972985e1461037a578063b88d4fde1461038d578063c87b56dd1461039b578063e985e9c5146103ae57600080fd5b80636352211e1461027d5780636c0360eb146102a657806370a08231146102ae5780638129fc1c146102c15780639017a13c146102c957806395d89b41146102dc57600080fd5b80632f745c59116101205780632f745c59146102295780633da8bfc91461023c5780633de2d9721461024457806342842e0e1461021b5780634f6ccce71461025757806355f804b31461026a57600080fd5b806301ffc9a71461016857806306fdde0314610190578063081812fc146101c9578063095ea7b3146101f457806318160ddd1461020957806323b872dd1461021b575b600080fd5b61017b6101763660046111bf565b6103bc565b60405190151581526020015b60405180910390f35b6040805180820190915260148152730476f6c6466696e6368204d656d626572736869760641b60208201525b604051610187919061120d565b6101dc6101d7366004611240565b61040e565b6040516001600160a01b039091168152602001610187565b61020761020236600461126e565b610429565b005b6005545b604051908152602001610187565b61020761020236600461129a565b61020d61023736600461126e565b610442565b61020d6104a1565b61020d6102523660046112db565b6104b3565b61020d610265366004611240565b610537565b610207610278366004611341565b61056c565b6101dc61028b366004611240565b6000908152600360205260409020546001600160a01b031690565b6101bc610612565b61020d6102bc3660046112db565b6106a0565b6102076106d0565b61020d6102d7366004611240565b610793565b60408051808201909152600881526723a326a2a6a122a960c11b60208201526101bc565b610207610202366004611383565b61020d61031c3660046113c1565b610803565b61033461032f3660046112db565b610a43565b604051610187919081516001600160a01b031681526020808301519082015260408083015190820152606080830151908201526080918201519181019190915260a00190565b6102076103883660046112db565b610ade565b6102076102023660046113f6565b6101bc6103a9366004611240565b610b16565b61017b6101d7366004611469565b60006001600160e01b031982166380ac58cd60e01b14806103ed57506001600160e01b0319821663780e9d6360e01b145b8061040857506001600160e01b031982166301ffc9a760e01b145b92915050565b6000604051631a850ed760e31b815260040160405180910390fd5b604051631a850ed760e31b815260040160405180910390fd5b6001600160a01b03821660009081526004602052604081205480820361047b576040516334b5d06d60e21b815260040160405180910390fd5b821561049a57604051632316143b60e11b815260040160405180910390fd5b9392505050565b60006104ae6102d7610b94565b905090565b6001600160a01b0380821660009081526004602081815260408084205484526003808352818520825160a08101845281549097168752600181015493870193909352600283015491860191909152810154606085015201546080830181905290919061051d610b94565b111561052d576040015192915050565b6020015192915050565b600061054260055490565b821061056157604051633f7ee38f60e11b815260040160405180910390fd5b6104088260016114ad565b61059e7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610b9f565b604051632a6e138b60e11b81523060048201523360248201526001600160a01b0391909116906354dc27169060440160006040518083038186803b1580156105e557600080fd5b505afa1580156105f9573d6000803e3d6000fd5b506006925061060d9150839050848361155e565b505050565b6006805461061f906114d6565b80601f016020809104026020016040519081016040528092919081815260200182805461064b906114d6565b80156106985780601f1061066d57610100808354040283529160200191610698565b820191906000526020600020905b81548152906001019060200180831161067b57829003601f168201915b505050505081565b6001600160a01b0381166000908152600460205260408120546106c45760006106c7565b60015b60ff1692915050565b600054610100900460ff16806106e9575060005460ff16155b6107515760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b600054610100900460ff16158015610773576000805461ffff19166101011790555b61077b610b94565b6002558015610790576000805461ff00191690555b50565b600061079d610c8f565b8211156107bd57604051630bb92ffd60e21b815260040160405180910390fd5b6002548211156107f0576001600060025460016107da91906114ad565b8152602001908152602001600020549050919050565b5060009081526001602052604090205490565b60007f037db0999be9065c5f1306135b75a6ae2af104ed9f0d72669950e21e87a33f766108308133610ca4565b8383101561085b576040516368caeba760e01b81526004810185905260248101849052604401610748565b600061086686610d03565b905061087186610e02565b6000818152600360208181526040808420815160a08101835281546001600160a01b031681526001808301805483870190815260028501805496850196909652848801546060850152600490940154608084015288885295909452938a905590889055519192889291906108e3610b94565b8152602001908152602001600020546108fc919061161f565b61090691906114ad565b60016000610912610b94565b81526020019081526020016000208190555084816040015160016000610936610c8f565b81526020019081526020016000205461094f919061161f565b61095991906114ad565b60016000610965610c8f565b815260200190815260200160002081905550866001600160a01b03167fb5ac373069545fdd5da402c94d10b968168eb2c09893e9a1a1fd087b2b3b34b187876040516109bb929190918252602082015260400190565b60405180910390a27f32ea6f1ec4de7460c440fd872b28a1f5e867728132b4dcba7af1f3dfef775ba2600160006109f0610b94565b81526020019081526020016000205460016000610a0b610c8f565b815260200190815260200160002054604051610a31929190918252602082015260400190565b60405180910390a15095945050505050565b610a7e6040518060a0016040528060006001600160a01b03168152602001600081526020016000815260200160008152602001600081525090565b506001600160a01b039081166000908152600460208181526040808420548452600380835293819020815160a081018352815490961686526001810154928601929092526002820154908501529182015460608401520154608082015290565b7f037db0999be9065c5f1306135b75a6ae2af104ed9f0d72669950e21e87a33f76610b098133610ca4565b610b1282610e02565b5050565b606081600003610b3c57604051637705f84560e01b815260048101839052602401610748565b600554821115610b6257604051637705f84560e01b815260048101839052602401610748565b6006610b6d83610f9c565b604051602001610b7e929190611632565b6040516020818303038152906040529050919050565b60006104ae426110a5565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610bdf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c0391906116b9565b6001600160a01b0316630c0450127f9a671f6643eb8ac838fd3c79576dd800fe704b35ad30189c60f0f14dab948f2a6040518263ffffffff1660e01b8152600401610c4e91906116d6565b602060405180830381865afa158015610c6b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061040891906116b9565b6000610c99610b94565b6104ae9060016114ad565b6001600160a01b038116610ccb5760405163d92e233d60e01b815260040160405180910390fd5b610cd582826110b4565b610b125760405163889a56bb60e01b81523060048201526001600160a01b0382166024820152604401610748565b60006001600160a01b038216610d2c57604051630a64406560e11b815260040160405180910390fd5b6001600160a01b0382166000908152600460205260409020548015610d515792915050565b60058054906000610d61836116eb565b9091555050600554600081815260036020819052604090912080546001600160a01b0319166001600160a01b038716178155429101559050610da1610b94565b60008281526003602090815260408083206004908101949094556001600160a01b0387168084529390915280822084905551839291907fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef908290a492915050565b6000610e0c610b94565b9050600254811115610e94576000600160006002546001610e2d91906114ad565b815260200190815260200160002054905060006002546002610e4f91906114ad565b90505b610e5d8360016114ad565b8111610e8657600081815260016020526040902082905580610e7e816116eb565b915050610e52565b50610e8f610b94565b600255505b6001600160a01b0382166000908152600460205260409020548015610f4457600081815260036020818152604092839020835160a08101855281546001600160a01b0316815260018201549281019290925260028101549382019390935290820154606082015260049091015460808201819052831115610f4257604080820151600084815260036020529190912060010155610f2f610b94565b6000838152600360205260409020600401555b505b7fde5ae8a37da230f7df39b8ea385fa1ab48e7caa55f1c25eaaef1ed8690f3699860016000610f71610b94565b815260200190815260200160002054604051610f8f91815260200190565b60405180910390a1505050565b606081600003610fc35750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610fed5780610fd7816116eb565b9150610fe69050600a8361171a565b9150610fc7565b60008167ffffffffffffffff811115611008576110086114c0565b6040519080825280601f01601f191660200182016040528015611032576020820181803683370190505b5090505b841561109d5761104760018361161f565b9150611054600a8661172e565b61105f9060306114ad565b60f81b81838151811061107457611074611742565b60200101906001600160f81b031916908160001a905350611096600a8661171a565b9450611036565b949350505050565b600061040862093a808361171a565b6000816001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa15801561111e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061114291906116b9565b6001600160a01b0316630c045012856040518263ffffffff1660e01b815260040161116d91906116d6565b602060405180830381865afa15801561118a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ae91906116b9565b6001600160a01b0316149392505050565b6000602082840312156111d157600080fd5b81356001600160e01b03198116811461049a57600080fd5b60005b838110156112045781810151838201526020016111ec565b50506000910152565b602081526000825180602084015261122c8160408501602087016111e9565b601f01601f19169190910160400192915050565b60006020828403121561125257600080fd5b5035919050565b6001600160a01b038116811461079057600080fd5b6000806040838503121561128157600080fd5b823561128c81611259565b946020939093013593505050565b6000806000606084860312156112af57600080fd5b83356112ba81611259565b925060208401356112ca81611259565b929592945050506040919091013590565b6000602082840312156112ed57600080fd5b813561049a81611259565b60008083601f84011261130a57600080fd5b50813567ffffffffffffffff81111561132257600080fd5b60208301915083602082850101111561133a57600080fd5b9250929050565b6000806020838503121561135457600080fd5b823567ffffffffffffffff81111561136b57600080fd5b611377858286016112f8565b90969095509350505050565b6000806040838503121561139657600080fd5b82356113a181611259565b9150602083013580151581146113b657600080fd5b809150509250929050565b6000806000606084860312156113d657600080fd5b83356113e181611259565b95602085013595506040909401359392505050565b60008060008060006080868803121561140e57600080fd5b853561141981611259565b9450602086013561142981611259565b935060408601359250606086013567ffffffffffffffff81111561144c57600080fd5b611458888289016112f8565b969995985093965092949392505050565b6000806040838503121561147c57600080fd5b823561148781611259565b915060208301356113b681611259565b634e487b7160e01b600052601160045260246000fd5b8082018082111561040857610408611497565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806114ea57607f821691505b60208210810361150a57634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561060d57600081815260208120601f850160051c810160208610156115375750805b601f850160051c820191505b8181101561155657828155600101611543565b505050505050565b67ffffffffffffffff831115611576576115766114c0565b61158a8361158483546114d6565b83611510565b6000601f8411600181146115be57600085156115a65750838201355b600019600387901b1c1916600186901b178355611618565b600083815260209020601f19861690835b828110156115ef57868501358255602094850194600190920191016115cf565b508682101561160c5760001960f88860031b161c19848701351681555b505060018560011b0183555b5050505050565b8181038181111561040857610408611497565b6000808454611640816114d6565b60018281168015611658576001811461166d5761169c565b60ff198416875282151583028701945061169c565b8860005260208060002060005b858110156116935781548a82015290840190820161167a565b50505082870194505b5050505083516116b08183602088016111e9565b01949350505050565b6000602082840312156116cb57600080fd5b815161049a81611259565b6001600160e01b031991909116815260200190565b6000600182016116fd576116fd611497565b5060010190565b634e487b7160e01b600052601260045260246000fd5b60008261172957611729611704565b500490565b60008261173d5761173d611704565b500690565b634e487b7160e01b600052603260045260246000fdfea2646970667358221220ef774c7db2d4ff1868e41276f302b861e7826ce08df1640db58558ea4ca4741464736f6c63430008100033",
  "devdoc": {
    "author": "Goldfinch",
    "events": {
      "Checkpoint(uint256)": {
        "params": {
          "total": "how much is stored in the vault at the current block.timestamp"
        }
      }
    },
    "kind": "dev",
    "methods": {
      "adjustHoldings(address,uint256,uint256)": {
        "params": {
          "eligibleAmount": "amount of points to apply to the current epoch",
          "nextEpochAmount": "amount of points to apply to the next epoch",
          "owner": "the owner to checkpoint"
        },
        "returns": {
          "_0": "id of the position"
        }
      },
      "balanceOf(address)": {
        "details": "Returns the number of tokens in ``owner``'s account."
      },
      "checkpoint(address)": {
        "details": "to collect rewards, this must be called before `increaseHoldings` or  `decreaseHoldings`. Those functions must call checkpoint internally  so the historical data will be lost otherwise.",
        "params": {
          "owner": "the owner to checkpoint"
        }
      },
      "currentTotal()": {
        "returns": {
          "_0": "total value in the vault as of block.timestamp"
        }
      },
      "currentValueOwnedBy(address)": {
        "params": {
          "owner": "address owning the positions"
        },
        "returns": {
          "_0": "sum of all positions held by an address"
        }
      },
      "name()": {
        "details": "Returns the token collection name."
      },
      "positionOwnedBy(address)": {
        "returns": {
          "_0": "position owned by `owner`"
        }
      },
      "symbol()": {
        "details": "Returns the token collection symbol."
      },
      "tokenByIndex(uint256)": {
        "details": "Returns a token ID at a given `index` of all the tokens stored by the contract. Use along with {totalSupply} to enumerate all tokens."
      },
      "tokenOfOwnerByIndex(address,uint256)": {
        "details": "Returns a token ID owned by `owner` at a given `index` of its token list. Use along with {balanceOf} to enumerate all of ``owner``'s tokens."
      },
      "tokenURI(uint256)": {
        "details": "Returns the Uniform Resource Identifier (URI) for `tokenId` token."
      },
      "totalAtEpoch(uint256)": {
        "returns": {
          "_0": "total value in the vault as of epoch"
        }
      },
      "totalSupply()": {
        "details": "Returns the total amount of tokens stored by the contract."
      }
    },
    "title": "MembershipVault",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "IndexGreaterThanTokenSupply()": [
        {
          "notice": "Thrown when querying token supply with an index greater than the supply"
        }
      ],
      "InvalidHoldingsAdjustment(uint256,uint256)": [
        {
          "notice": "Thrown when adjusting holdings in an unsupported way"
        }
      ],
      "NoTokensOwned()": [
        {
          "notice": "Thrown when trying to access tokens from an address with no tokens"
        }
      ],
      "NoTotalsInFutureEpochs()": [
        {
          "notice": "Thrown when checking totals in future epochs"
        }
      ],
      "NonexistantToken(uint256)": [
        {
          "notice": "Thrown when requesting a nonexistant token"
        }
      ],
      "OneTokenPerAddress()": [
        {
          "notice": "Thrown when trying to access more than one token for an address"
        }
      ],
      "ZeroAddressInvalid()": [
        {
          "notice": "Thrown when depositing from address(0)"
        }
      ]
    },
    "events": {
      "AdjustedHoldings(address,uint256,uint256)": {
        "notice": "Emitted when an owner has adjusted their holdings in a vault"
      },
      "Checkpoint(uint256)": {
        "notice": "The vault has been checkpointed"
      },
      "VaultTotalUpdate(uint256,uint256)": {
        "notice": "Emitted when the total within the vault has changed"
      }
    },
    "kind": "user",
    "methods": {
      "adjustHoldings(address,uint256,uint256)": {
        "notice": "Record an adjustment in holdings. Eligible assets will update this epoch and  total assets will become eligible the subsequent epoch."
      },
      "baseURI()": {
        "notice": "base uri for the nft"
      },
      "checkpoint(address)": {
        "notice": "Checkpoint a specific owner & the vault total"
      },
      "currentTotal()": {
        "notice": "Get the total value in the vault as of block.timestamp"
      },
      "currentValueOwnedBy(address)": {
        "notice": "Get the current value of `owner`. This changes depending on the current  block.timestamp as increased holdings are not accounted for until the subsequent epoch."
      },
      "positionOwnedBy(address)": {
        "notice": "Get the position owned by `owner`"
      },
      "setBaseURI(string)": {
        "notice": "Set the base uri for the contract"
      },
      "totalAtEpoch(uint256)": {
        "notice": "Get the total value in the vault as of epoch"
      }
    },
    "notice": "Track assets held by owners in a vault, as well as the total held in the vault. Assets  are not accounted for until the next epoch for MEV protection.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 663,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 666,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 13351,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "totalAmounts",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 13354,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "checkpointEpoch",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 13360,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "positions",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_struct(Position)6923_storage)"
      },
      {
        "astId": 13365,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "owners",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 13368,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "membershipIdsTracker",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 13371,
        "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
        "label": "baseURI",
        "offset": 0,
        "slot": "6",
        "type": "t_string_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_struct(Position)6923_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Position)",
        "numberOfBytes": "32",
        "value": "t_struct(Position)6923_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Position)6923_storage": {
        "encoding": "inplace",
        "label": "struct Position",
        "members": [
          {
            "astId": 6914,
            "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6916,
            "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
            "label": "eligibleAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6918,
            "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
            "label": "nextEpochAmount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 6920,
            "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
            "label": "createdTimestamp",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 6922,
            "contract": "contracts/protocol/core/membership/MembershipVault.sol:MembershipVault",
            "label": "checkpointEpoch",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "160"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}