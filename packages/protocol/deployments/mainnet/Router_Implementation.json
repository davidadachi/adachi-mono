{
  "address": "0x0A540cf99FB24926c6EfE88eEf141d7C9aeCFFe2",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes4",
          "name": "key",
          "type": "bytes4"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "SetContract",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "name": "contracts",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract AccessControl",
          "name": "accessControl",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "key",
          "type": "bytes4"
        },
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "setContract",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1576afdfb2d1c98ba762940b44992f2e80e6714e886a0a88882d7433678297fa",
  "receipt": {
    "to": null,
    "from": "0x2Fbf774ec12Bd86a60E563F0653AEee4DEbA0DB8",
    "contractAddress": "0x0A540cf99FB24926c6EfE88eEf141d7C9aeCFFe2",
    "transactionIndex": 22,
    "gasUsed": "249062",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x3146ca4152bcb11f753c6aa3791722b0bad4de5066dc76e1737e9ebcc949a0aa",
    "transactionHash": "0x1576afdfb2d1c98ba762940b44992f2e80e6714e886a0a88882d7433678297fa",
    "logs": [],
    "blockNumber": 15992871,
    "cumulativeGasUsed": "1994104",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "eac65dc40e06b4b044f441f03029567a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"key\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"SetContract\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"contracts\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AccessControl\",\"name\":\"accessControl\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"key\",\"type\":\"bytes4\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"landakram\",\"kind\":\"dev\",\"methods\":{\"setContract(bytes4,address)\":{\"details\":\"This function is only callable by the Router admin\",\"params\":{\"addr\":\"A contract address\",\"key\":\"A routing key (defined in the `Routing.Keys` libary)\"}}},\"title\":\"Router\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"contracts(bytes4)\":{\"notice\":\"Mapping of keys to contract addresses. Keys are the first 4 bytes of the keccak of   the contract's name. See Routing.sol for all options.\"},\"setContract(bytes4,address)\":{\"notice\":\"Associate a routing key to a contract address\"}},\"notice\":\"This contract provides service discovery for contracts using the cake framework.   It can be used in conjunction with the convenience methods defined in the `Routing.Context`   and `Routing.Keys` libraries.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/cake/Router.sol\":\"Router\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\",\"keccak256\":\"0xe6220d2b5a54ac7497313ce4503cca742b09dc5e3a4eb76fb0afff85b1b97a34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721Upgradeable.sol\\\";\\n\",\"keccak256\":\"0x28c8a2c5850343f4fb44847b736df5a89fb16c90971c8c06c8066c04ad9b70df\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf449ca0a763d4b1b4462cf8706857074492f324020a2b9d099181b5383055ad3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xfbb3ca7272af58dc245a20e91a1f68481ee04706fa3fe46d184000efc21f4bad\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x1c4860acd323e34a67b3e97faab9aaa55fe8e92b1dcf08b5f47f3468d58ce75c\",\"license\":\"MIT\"},\"contracts/cake/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IAccessControl.sol\\\";\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ncontract AccessControl is Initializable, IAccessControl {\\n  /// @dev Mapping from contract address to contract admin;\\n  mapping(address => address) public admins;\\n\\n  function initialize(address admin) public initializer {\\n    admins[address(this)] = admin;\\n    emit AdminSet(address(this), admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function setAdmin(address resource, address admin) external {\\n    requireSuperAdmin(msg.sender);\\n    admins[resource] = admin;\\n    emit AdminSet(resource, admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireAdmin(address resource, address accessor) public view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n    bool isAdmin = admins[resource] == accessor;\\n    if (!isAdmin) revert RequiresAdmin(resource, accessor);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireSuperAdmin(address accessor) public view {\\n    // The super admin is the admin of this AccessControl contract\\n    requireAdmin({resource: address(this), accessor: accessor});\\n  }\\n}\\n\",\"keccak256\":\"0x1b70acad9e92a3b0898a989d413bb16b5c5707faf84f2eb31354b453385a7b54\",\"license\":\"MIT\"},\"contracts/cake/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {Router} from \\\"./Router.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nusing Routing.Context for Context;\\n\\n/// @title Entry-point for all application-layer contracts.\\n/// @author landakram\\n/// @notice This contract provides an interface for retrieving other contract addresses and doing access\\n///  control.\\ncontract Context {\\n  /// @notice Used for retrieving other contract addresses.\\n  /// @dev This variable is immutable. This is done to save gas, as it is expected to be referenced\\n  /// in every end-user call with a call-chain length > 0. Note that it is written into the contract\\n  /// bytecode at contract creation time, so if the contract is deployed as the implementation for proxies,\\n  /// every proxy will share the same Router address.\\n  Router public immutable router;\\n\\n  constructor(Router _router) {\\n    router = _router;\\n  }\\n}\\n\",\"keccak256\":\"0xa680415dd02e61f8cd730f3198096d73b40fddb2f7f46136fc20e02a173ec107\",\"license\":\"MIT\"},\"contracts/cake/Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\n\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\n/// @title Router\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ncontract Router is Initializable, IRouter {\\n  /// @notice Mapping of keys to contract addresses. Keys are the first 4 bytes of the keccak of\\n  ///   the contract's name. See Routing.sol for all options.\\n  mapping(bytes4 => address) public contracts;\\n\\n  function initialize(AccessControl accessControl) public initializer {\\n    contracts[Routing.Keys.AccessControl] = address(accessControl);\\n  }\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) public {\\n    AccessControl accessControl = AccessControl(contracts[Routing.Keys.AccessControl]);\\n    accessControl.requireAdmin(address(this), msg.sender);\\n    contracts[key] = addr;\\n    emit SetContract(key, addr);\\n  }\\n}\\n\",\"keccak256\":\"0x686176336adffd914b35e6cc23b551c4af63c43eba9c5416749427a5e02a98b0\",\"license\":\"MIT\"},\"contracts/cake/Routing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable const-name-snakecase\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\n\\nimport {IMembershipVault} from \\\"../interfaces/IMembershipVault.sol\\\";\\nimport {IGFILedger} from \\\"../interfaces/IGFILedger.sol\\\";\\nimport {ICapitalLedger} from \\\"../interfaces/ICapitalLedger.sol\\\";\\nimport {IMembershipDirector} from \\\"../interfaces/IMembershipDirector.sol\\\";\\nimport {IMembershipOrchestrator} from \\\"../interfaces/IMembershipOrchestrator.sol\\\";\\nimport {IMembershipLedger} from \\\"../interfaces/IMembershipLedger.sol\\\";\\nimport {IMembershipCollector} from \\\"../interfaces/IMembershipCollector.sol\\\";\\n\\nimport {ISeniorPool} from \\\"../interfaces/ISeniorPool.sol\\\";\\nimport {IPoolTokens} from \\\"../interfaces/IPoolTokens.sol\\\";\\nimport {IStakingRewards} from \\\"../interfaces/IStakingRewards.sol\\\";\\n\\nimport {IERC20Splitter} from \\\"../interfaces/IERC20Splitter.sol\\\";\\nimport {Context as ContextContract} from \\\"./Context.sol\\\";\\nimport {IAccessControl} from \\\"../interfaces/IAccessControl.sol\\\";\\n\\nimport {Router} from \\\"./Router.sol\\\";\\n\\n/// @title Routing.Keys\\n/// @notice This library is used to define routing keys used by `Router`.\\n/// @dev We use uints instead of enums for several reasons. First, keys can be re-ordered\\n///   or removed. This is useful when routing keys are deprecated; they can be moved to a\\n///   different section of the file. Second, other libraries or contracts can define their\\n///   own routing keys independent of this global mapping. This is useful for test contracts.\\nlibrary Keys {\\n  // Membership\\n  bytes4 internal constant MembershipOrchestrator = bytes4(keccak256(\\\"MembershipOrchestrator\\\"));\\n  bytes4 internal constant MembershipDirector = bytes4(keccak256(\\\"MembershipDirector\\\"));\\n  bytes4 internal constant GFILedger = bytes4(keccak256(\\\"GFILedger\\\"));\\n  bytes4 internal constant CapitalLedger = bytes4(keccak256(\\\"CapitalLedger\\\"));\\n  bytes4 internal constant MembershipCollector = bytes4(keccak256(\\\"MembershipCollector\\\"));\\n  bytes4 internal constant MembershipLedger = bytes4(keccak256(\\\"MembershipLedger\\\"));\\n  bytes4 internal constant MembershipVault = bytes4(keccak256(\\\"MembershipVault\\\"));\\n\\n  // Tokens\\n  bytes4 internal constant GFI = bytes4(keccak256(\\\"GFI\\\"));\\n  bytes4 internal constant FIDU = bytes4(keccak256(\\\"FIDU\\\"));\\n  bytes4 internal constant USDC = bytes4(keccak256(\\\"USDC\\\"));\\n\\n  // Cake\\n  bytes4 internal constant AccessControl = bytes4(keccak256(\\\"AccessControl\\\"));\\n  bytes4 internal constant Router = bytes4(keccak256(\\\"Router\\\"));\\n\\n  // Core\\n  bytes4 internal constant ReserveSplitter = bytes4(keccak256(\\\"ReserveSplitter\\\"));\\n  bytes4 internal constant PoolTokens = bytes4(keccak256(\\\"PoolTokens\\\"));\\n  bytes4 internal constant SeniorPool = bytes4(keccak256(\\\"SeniorPool\\\"));\\n  bytes4 internal constant StakingRewards = bytes4(keccak256(\\\"StakingRewards\\\"));\\n  bytes4 internal constant ProtocolAdmin = bytes4(keccak256(\\\"ProtocolAdmin\\\"));\\n  bytes4 internal constant PauserAdmin = bytes4(keccak256(\\\"PauserAdmin\\\"));\\n}\\n\\n/// @title Routing.Context\\n/// @notice This library provides convenience functions for getting contracts from `Router`.\\nlibrary Context {\\n  function accessControl(ContextContract context) internal view returns (IAccessControl) {\\n    return IAccessControl(context.router().contracts(Keys.AccessControl));\\n  }\\n\\n  function membershipVault(ContextContract context) internal view returns (IMembershipVault) {\\n    return IMembershipVault(context.router().contracts(Keys.MembershipVault));\\n  }\\n\\n  function capitalLedger(ContextContract context) internal view returns (ICapitalLedger) {\\n    return ICapitalLedger(context.router().contracts(Keys.CapitalLedger));\\n  }\\n\\n  function gfiLedger(ContextContract context) internal view returns (IGFILedger) {\\n    return IGFILedger(context.router().contracts(Keys.GFILedger));\\n  }\\n\\n  function gfi(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.GFI));\\n  }\\n\\n  function membershipDirector(ContextContract context) internal view returns (IMembershipDirector) {\\n    return IMembershipDirector(context.router().contracts(Keys.MembershipDirector));\\n  }\\n\\n  function membershipOrchestrator(ContextContract context) internal view returns (IMembershipOrchestrator) {\\n    return IMembershipOrchestrator(context.router().contracts(Keys.MembershipOrchestrator));\\n  }\\n\\n  function stakingRewards(ContextContract context) internal view returns (IStakingRewards) {\\n    return IStakingRewards(context.router().contracts(Keys.StakingRewards));\\n  }\\n\\n  function poolTokens(ContextContract context) internal view returns (IPoolTokens) {\\n    return IPoolTokens(context.router().contracts(Keys.PoolTokens));\\n  }\\n\\n  function seniorPool(ContextContract context) internal view returns (ISeniorPool) {\\n    return ISeniorPool(context.router().contracts(Keys.SeniorPool));\\n  }\\n\\n  function fidu(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.FIDU));\\n  }\\n\\n  function usdc(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.USDC));\\n  }\\n\\n  function reserveSplitter(ContextContract context) internal view returns (IERC20Splitter) {\\n    return IERC20Splitter(context.router().contracts(Keys.ReserveSplitter));\\n  }\\n\\n  function membershipLedger(ContextContract context) internal view returns (IMembershipLedger) {\\n    return IMembershipLedger(context.router().contracts(Keys.MembershipLedger));\\n  }\\n\\n  function membershipCollector(ContextContract context) internal view returns (IMembershipCollector) {\\n    return IMembershipCollector(context.router().contracts(Keys.MembershipCollector));\\n  }\\n\\n  function protocolAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.ProtocolAdmin);\\n  }\\n\\n  function pauserAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.PauserAdmin);\\n  }\\n}\\n\",\"keccak256\":\"0x4a324049c639da20482479082129fc570daa0f06dbdd25fdce46ad401f8ec7c5\",\"license\":\"MIT\"},\"contracts/interfaces/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ninterface IAccessControl {\\n  error RequiresAdmin(address resource, address accessor);\\n  error ZeroAddress();\\n\\n  event AdminSet(address indexed resource, address indexed admin);\\n\\n  /// @notice Set an admin for a given resource\\n  /// @param resource An address which with `admin` should be allowed to administer\\n  /// @param admin An address which should be allowed to administer `resource`\\n  /// @dev This method is only callable by the super-admin (the admin of this AccessControl\\n  ///   contract)\\n  function setAdmin(address resource, address admin) external;\\n\\n  /// @notice Require a valid admin for a given resource\\n  /// @param resource An address that `accessor` is attempting to access\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid admin\\n  function requireAdmin(address resource, address accessor) external view;\\n\\n  /// @notice Require a super-admin. A super-admin is an admin of this AccessControl contract.\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid super-admin\\n  function requireSuperAdmin(address accessor) external view;\\n}\\n\",\"keccak256\":\"0xa77d24e074f86c95657ada01678e9c7136b8769856182428f0f2cb6d191b341f\",\"license\":\"MIT\"},\"contracts/interfaces/ICapitalLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nenum CapitalAssetType {\\n  INVALID,\\n  ERC721\\n}\\n\\ninterface ICapitalLedger {\\n  /**\\n   * @notice Emitted when a new capital erc721 deposit has been made\\n   * @param owner address owning the deposit\\n   * @param assetAddress address of the deposited ERC721\\n   * @param positionId id for the deposit\\n   * @param assetTokenId id of the token from the ERC721 `assetAddress`\\n   * @param usdcEquivalent usdc equivalent value at the time of deposit\\n   */\\n  event CapitalERC721Deposit(\\n    address indexed owner,\\n    address indexed assetAddress,\\n    uint256 positionId,\\n    uint256 assetTokenId,\\n    uint256 usdcEquivalent\\n  );\\n\\n  /**\\n   * @notice Emitted when a new ERC721 capital withdrawal has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the capital position\\n   * @param assetAddress address of the underlying ERC721\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event CapitalERC721Withdrawal(\\n    address indexed owner,\\n    uint256 positionId,\\n    address assetAddress,\\n    uint256 depositTimestamp\\n  );\\n\\n  /// Thrown when called with an invalid asset type for the function. Valid\\n  /// types are defined under CapitalAssetType\\n  error InvalidAssetType(CapitalAssetType);\\n\\n  /**\\n   * @notice Account for a deposit of `id` for the ERC721 asset at `assetAddress`.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param owner address that owns the position\\n   * @param assetAddress address of the ERC20 address\\n   * @param assetTokenId id of the ERC721 asset to add\\n   * @return id of the newly created position\\n   */\\n  function depositERC721(\\n    address owner,\\n    address assetAddress,\\n    uint256 assetTokenId\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Get the id of the ERC721 asset held by position `id`. Pair this with\\n   *  `assetAddressOf` to get the address & id of the nft.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param positionId id of the position\\n   * @return id of the underlying ERC721 asset\\n   */\\n  function erc721IdOf(uint256 positionId) external view returns (uint256);\\n\\n  /**\\n   * @notice Completely withdraw a position\\n   * @param positionId id of the position\\n   */\\n  function withdraw(uint256 positionId) external;\\n\\n  /**\\n   * @notice Get the asset address of the position. Example: For an ERC721 position, this\\n   *  returns the address of that ERC721 contract.\\n   * @param positionId id of the position\\n   * @return asset address of the position\\n   */\\n  function assetAddressOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the number of capital positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return position id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the USDC value of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @param owner address owning the positions\\n   * @return eligibleAmount USDC value of positions eligible for rewards\\n   * @return totalAmount total USDC value of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xfd869b44e49041db9fb9ef2f6c00fcfceb38ba20f26631562cfb48fa2bec12ef\",\"license\":\"MIT\"},\"contracts/interfaces/ICreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICreditLine {\\n  function borrower() external view returns (address);\\n\\n  function limit() external view returns (uint256);\\n\\n  function maxLimit() external view returns (uint256);\\n\\n  function interestApr() external view returns (uint256);\\n\\n  function paymentPeriodInDays() external view returns (uint256);\\n\\n  function principalGracePeriodInDays() external view returns (uint256);\\n\\n  function termInDays() external view returns (uint256);\\n\\n  function lateFeeApr() external view returns (uint256);\\n\\n  function isLate() external view returns (bool);\\n\\n  function withinPrincipalGracePeriod() external view returns (bool);\\n\\n  // Accounting variables\\n  function balance() external view returns (uint256);\\n\\n  function interestOwed() external view returns (uint256);\\n\\n  function principalOwed() external view returns (uint256);\\n\\n  function termEndTime() external view returns (uint256);\\n\\n  function nextDueTime() external view returns (uint256);\\n\\n  function interestAccruedAsOf() external view returns (uint256);\\n\\n  function lastFullPaymentTime() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd54b264344ce302597ee4f04f147000275d05c8fc9612cc21eaff915ff1f30c8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Splitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IERC20Splitter {\\n  function lastDistributionAt() external view returns (uint256);\\n\\n  function distribute() external;\\n\\n  function replacePayees(address[] calldata _payees, uint256[] calldata _shares) external;\\n\\n  function pendingDistributionFor(address payee) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x915a4058d1c4f6e694e1fdbaa708d3ec7e26dba3162f83290d997ec484960972\",\"license\":\"MIT\"},\"contracts/interfaces/IGFILedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IGFILedger {\\n  struct Position {\\n    // Owner of the position\\n    address owner;\\n    // Index of the position in the ownership array\\n    uint256 ownedIndex;\\n    // Amount of GFI held in the position\\n    uint256 amount;\\n    // When the position was deposited\\n    uint256 depositTimestamp;\\n  }\\n\\n  /**\\n   * @notice Emitted when a new GFI deposit has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the deposit\\n   * @param amount how much GFI was deposited\\n   */\\n  event GFIDeposit(address indexed owner, uint256 indexed positionId, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when a new GFI withdrawal has been made. If the remaining amount is 0, the position has bee removed\\n   * @param owner address owning the withdrawn position\\n   * @param positionId id for the position\\n   * @param remainingAmount how much GFI is remaining in the position\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event GFIWithdrawal(\\n    address indexed owner,\\n    uint256 indexed positionId,\\n    uint256 withdrawnAmount,\\n    uint256 remainingAmount,\\n    uint256 depositTimestamp\\n  );\\n\\n  /**\\n   * @notice Account for a new deposit by the owner.\\n   * @param owner address to account for the deposit\\n   * @param amount how much was deposited\\n   * @return how much was deposited\\n   */\\n  function deposit(address owner, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @param amount how much to withdraw\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Get the number of GFI positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return token id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get amount of GFI of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @return eligibleAmount GFI amount of positions eligible for rewards\\n   * @return totalAmount total GFI amount of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xa4aa4178b7ffd3d92d0db9f489cea52b574df2207ae463433472ccd5d4b67372\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipCollector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipCollector {\\n  /// @notice Have the collector distribute `amount` of Fidu to `addr`\\n  /// @param addr address to distribute to\\n  /// @param amount amount to distribute\\n  function distributeFiduTo(address addr, uint256 amount) external;\\n\\n  /// @notice Get the last epoch finalized by the collector. This means the\\n  ///  collector will no longer add rewards to the epoch.\\n  /// @return the last finalized epoch\\n  function lastFinalizedEpoch() external view returns (uint256);\\n\\n  /// @notice Get the rewards associated with `epoch`. This amount may change\\n  ///  until `epoch` has been finalized (is less than or equal to getLastFinalizedEpoch)\\n  /// @return rewards associated with `epoch`\\n  function rewardsForEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n  ///  this will be the fixed, accurate reward for the epoch. For the current and other\\n  ///  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n  ///  moment.\\n  /// @param epoch epoch to estimate the rewards of\\n  /// @return rewards associated with `epoch`\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0x8ea890c7237ee09c340afa47bce4fe6fd2e6d65bce601620edb1513e4b0f3914\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipDirector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipDirector {\\n  /**\\n   * @notice Adjust an `owner`s membership score and position due to the change\\n   *  in their GFI and Capital holdings\\n   * @param owner address who's holdings changed\\n   * @return id of membership position\\n   */\\n  function consumeHoldingsAdjustment(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Collect all membership yield enhancements for the owner.\\n   * @param owner address to claim rewards for\\n   * @return amount of yield enhancements collected\\n   */\\n  function collectRewards(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable for the owner. The return\\n   *  value here is how much would be retrieved by calling `collectRewards`.\\n   * @param owner address to calculate claimable rewards for\\n   * @return the amount of rewards that could be claimed by the owner\\n   */\\n  function claimableRewards(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate the membership score\\n   * @param gfi Amount of gfi\\n   * @param capital Amount of capital in USDC\\n   * @return membership score\\n   */\\n  function calculateMembershipScore(uint256 gfi, uint256 capital) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the current score of `owner`\\n   * @param owner address to check the score of\\n   * @return eligibleScore score that is currently eligible for rewards\\n   * @return totalScore score that will be elgible for rewards next epoch\\n   */\\n  function currentScore(address owner) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc4ad3f9a21473122dc03f92db9f78b3da14468ff17f7892e5feb6fed6f882abd\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipLedger {\\n  /**\\n   * @notice Set `addr`s allocated rewards back to 0\\n   * @param addr address to reset rewards on\\n   */\\n  function resetRewards(address addr) external;\\n\\n  /**\\n   * @notice Allocate `amount` rewards for `addr` but do not send them\\n   * @param addr address to distribute rewards to\\n   * @param amount amount of rewards to allocate for `addr`\\n   * @return rewards total allocated to `addr`\\n   */\\n  function allocateRewardsTo(address addr, uint256 amount) external returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the rewards allocated to a certain `addr`\\n   * @param addr the address to check pending rewards for\\n   * @return rewards pending rewards for `addr`\\n   */\\n  function getPendingRewardsFor(address addr) external view returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the alpha parameter for the cobb douglas function. Will always be in (0,1).\\n   * @return numerator numerator for the alpha param\\n   * @return denominator denominator for the alpha param\\n   */\\n  function alpha() external view returns (uint128 numerator, uint128 denominator);\\n}\\n\",\"keccak256\":\"0x56bfc0d3ed5f532e3f36387d705f047252ba3cbeb8374e4bc51ed59a68197a33\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipOrchestrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nimport {Context} from \\\"../cake/Context.sol\\\";\\n\\nstruct CapitalDeposit {\\n  /// Address of the asset being deposited\\n  /// @dev must be supported in CapitalAssets.sol\\n  address assetAddress;\\n  /// Id of the nft\\n  uint256 id;\\n}\\n\\nstruct Deposit {\\n  /// Amount of gfi to deposit\\n  uint256 gfi;\\n  /// List of capital deposits\\n  CapitalDeposit[] capitalDeposits;\\n}\\n\\nstruct DepositResult {\\n  uint256 membershipId;\\n  uint256 gfiPositionId;\\n  uint256[] capitalPositionIds;\\n}\\n\\nstruct ERC20Withdrawal {\\n  uint256 id;\\n  uint256 amount;\\n}\\n\\nstruct Withdrawal {\\n  /// List of gfi token ids to withdraw\\n  ERC20Withdrawal[] gfiPositions;\\n  /// List of capital token ids to withdraw\\n  uint256[] capitalPositions;\\n}\\n\\n/**\\n * @title MembershipOrchestrator\\n * @notice Externally facing gateway to all Goldfinch membership functionality.\\n * @author Goldfinch\\n */\\ninterface IMembershipOrchestrator {\\n  /**\\n   * @notice Deposit multiple assets defined in `multiDeposit`. Assets can include GFI, Staked Fidu,\\n   *  and others.\\n   * @param deposit struct describing all the assets to deposit\\n   * @return ids all of the ids of the created depoits, in the same order as deposit. If GFI is\\n   *  present, it will be the first id.\\n   */\\n  function deposit(Deposit calldata deposit) external returns (DepositResult memory);\\n\\n  /**\\n   * @notice Withdraw multiple assets defined in `multiWithdraw`. Assets can be GFI or capital\\n   *  positions ids. Caller must have been permitted to act upon all of the positions.\\n   * @param withdrawal all of the GFI and Capital ids to withdraw\\n   */\\n  function withdraw(Withdrawal calldata withdrawal) external;\\n\\n  /**\\n   * @notice Collect all membership rewards for the caller.\\n   * @return how many rewards were collected and sent to caller\\n   */\\n  function collectRewards() external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable at this moment in time for caller.\\n   * @param addr the address to check claimable rewards for\\n   * @return how many rewards could be claimed by a call to `collectRewards`\\n   */\\n  function claimableRewards(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Check the voting power of a given address\\n   * @param addr the address to check the voting power of\\n   * @return the voting power\\n   */\\n  function votingPower(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get all GFI in Membership held by `addr`. This returns the current eligible amount and the\\n   *  total amount of GFI.\\n   * @param addr the owner\\n   * @return eligibleAmount how much GFI is currently eligible for rewards\\n   * @return totalAmount how much GFI is currently eligible for rewards\\n   */\\n  function totalGFIHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get all capital, denominated in USDC, in Membership held by `addr`. This returns the current\\n   *  eligible amount and the total USDC value of capital.\\n   * @param addr the owner\\n   * @return eligibleAmount how much USDC of capital is currently eligible for rewards\\n   * @return totalAmount how much  USDC of capital is currently eligible for rewards\\n   */\\n  function totalCapitalHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get the member score of `addr`\\n   * @param addr the owner\\n   * @return eligibleScore the currently eligible score\\n   * @return totalScore the total score that will be eligible next epoch\\n   *\\n   * @dev if eligibleScore == totalScore then there are no changes between now and the next epoch\\n   */\\n  function memberScoreOf(address addr) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n   *  this will be the fixed, accurate reward for the epoch. For the current and other\\n   *  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n   *  moment.\\n   * @param epoch epoch to estimate the rewards of\\n   * @return rewards associated with `epoch`\\n   */\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate what the Membership Score would be if a `gfi` amount of GFI and `capital` amount\\n   *  of Capital denominated in USDC were deposited.\\n   * @param gfi amount of GFI to estimate with\\n   * @param capital amount of capital to estimate with, denominated in USDC\\n   * @return score the resulting score\\n   */\\n  function calculateMemberScore(uint256 gfi, uint256 capital) external view returns (uint256 score);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc231b961b7ad5e98e45adcc355dd7d3f6f4dd5855486fba35d6f3ef466cbdee0\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\\\";\\n\\nstruct Position {\\n  // address owning the position\\n  address owner;\\n  // how much of the position is eligible as of checkpointEpoch\\n  uint256 eligibleAmount;\\n  // how much of the postion is eligible the epoch after checkpointEpoch\\n  uint256 nextEpochAmount;\\n  // when the position was first created\\n  uint256 createdTimestamp;\\n  // epoch of the last checkpoint\\n  uint256 checkpointEpoch;\\n}\\n\\n/**\\n * @title IMembershipVault\\n * @notice Track assets held by owners in a vault, as well as the total held in the vault. Assets\\n *  are not accounted for until the next epoch for MEV protection.\\n * @author Goldfinch\\n */\\ninterface IMembershipVault is IERC721Upgradeable {\\n  /**\\n   * @notice Emitted when an owner has adjusted their holdings in a vault\\n   * @param owner the owner increasing their holdings\\n   * @param eligibleAmount the new eligible amount\\n   * @param nextEpochAmount the new next epoch amount\\n   */\\n  event AdjustedHoldings(address indexed owner, uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Emitted when the total within the vault has changed\\n   * @param eligibleAmount new current amount\\n   * @param nextEpochAmount new next epoch amount\\n   */\\n  event VaultTotalUpdate(uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Get the current value of `owner`. This changes depending on the current\\n   *  block.timestamp as increased holdings are not accounted for until the subsequent epoch.\\n   * @param owner address owning the positions\\n   * @return sum of all positions held by an address\\n   */\\n  function currentValueOwnedBy(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of block.timestamp\\n   * @return total value in the vault as of block.timestamp\\n   */\\n  function currentTotal() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of epoch\\n   * @return total value in the vault as of epoch\\n   */\\n  function totalAtEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the position owned by `owner`\\n   * @return position owned by `owner`\\n   */\\n  function positionOwnedBy(address owner) external view returns (Position memory);\\n\\n  /**\\n   * @notice Record an adjustment in holdings. Eligible assets will update this epoch and\\n   *  total assets will become eligible the subsequent epoch.\\n   * @param owner the owner to checkpoint\\n   * @param eligibleAmount amount of points to apply to the current epoch\\n   * @param nextEpochAmount amount of points to apply to the next epoch\\n   * @return id of the position\\n   */\\n  function adjustHoldings(\\n    address owner,\\n    uint256 eligibleAmount,\\n    uint256 nextEpochAmount\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Checkpoint a specific owner & the vault total\\n   * @param owner the owner to checkpoint\\n   *\\n   * @dev to collect rewards, this must be called before `increaseHoldings` or\\n   *  `decreaseHoldings`. Those functions must call checkpoint internally\\n   *  so the historical data will be lost otherwise.\\n   */\\n  function checkpoint(address owner) external;\\n}\\n\",\"keccak256\":\"0x5979e109a0a813e0db1de7167625a77f35dab12d184d2eedf1be7ad9706974f7\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolTokens.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./openzeppelin/IERC721.sol\\\";\\n\\ninterface IPoolTokens is IERC721 {\\n  event TokenMinted(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    uint256 tranche\\n  );\\n\\n  event TokenRedeemed(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed,\\n    uint256 tranche\\n  );\\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\\n\\n  struct TokenInfo {\\n    address pool;\\n    uint256 tranche;\\n    uint256 principalAmount;\\n    uint256 principalRedeemed;\\n    uint256 interestRedeemed;\\n  }\\n\\n  struct MintParams {\\n    uint256 principalAmount;\\n    uint256 tranche;\\n  }\\n\\n  function mint(MintParams calldata params, address to) external returns (uint256);\\n\\n  function redeem(\\n    uint256 tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed\\n  ) external;\\n\\n  function withdrawPrincipal(uint256 tokenId, uint256 principalAmount) external;\\n\\n  function burn(uint256 tokenId) external;\\n\\n  function onPoolCreated(address newPool) external;\\n\\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\\n\\n  function validPool(address sender) external view returns (bool);\\n\\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9569823f1e5647f6a627035a341dee918ef58f8b1faefa2a9fd47e75c1f1420f\",\"license\":\"MIT\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title IRouter\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ninterface IRouter {\\n  event SetContract(bytes4 indexed key, address indexed addr);\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) external;\\n}\\n\",\"keccak256\":\"0xe2a04ffb3198fa9de6b8252e1c406eff3dfc0bf7555e2d420bf5e87925fa4d43\",\"license\":\"MIT\"},\"contracts/interfaces/ISeniorPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ITranchedPool.sol\\\";\\n\\nabstract contract ISeniorPool {\\n  uint256 public sharePrice;\\n  uint256 public totalLoansOutstanding;\\n  uint256 public totalWritedowns;\\n\\n  function deposit(uint256 amount) external virtual returns (uint256 depositShares);\\n\\n  function depositWithPermit(\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 depositShares);\\n\\n  function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\\n\\n  function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\\n\\n  function sweepToCompound() public virtual;\\n\\n  function sweepFromCompound() public virtual;\\n\\n  function invest(ITranchedPool pool) public virtual;\\n\\n  function estimateInvestment(ITranchedPool pool) public view virtual returns (uint256);\\n\\n  function redeem(uint256 tokenId) public virtual;\\n\\n  function writedown(uint256 tokenId) public virtual;\\n\\n  function calculateWritedown(uint256 tokenId) public view virtual returns (uint256 writedownAmount);\\n\\n  function assets() public view virtual returns (uint256);\\n\\n  function getNumShares(uint256 amount) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x529b3e34b03c6400e6cd8da7683b6d0daf1c8694dbbff889bd05f1a0b5923e9b\",\"license\":\"MIT\"},\"contracts/interfaces/IStakingRewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC721} from \\\"./openzeppelin/IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"./openzeppelin/IERC721Metadata.sol\\\";\\nimport {IERC721Enumerable} from \\\"./openzeppelin/IERC721Enumerable.sol\\\";\\n\\ninterface IStakingRewards is IERC721, IERC721Metadata, IERC721Enumerable {\\n  function getPosition(uint256 tokenId) external view returns (StakedPosition memory position);\\n\\n  function unstake(uint256 tokenId, uint256 amount) external;\\n\\n  function addToStake(uint256 tokenId, uint256 amount) external;\\n\\n  function stakedBalanceOf(uint256 tokenId) external view returns (uint256);\\n\\n  function depositToCurveAndStakeFrom(\\n    address nftRecipient,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount\\n  ) external;\\n\\n  function kick(uint256 tokenId) external;\\n\\n  function accumulatedRewardsPerToken() external view returns (uint256);\\n\\n  function lastUpdateTime() external view returns (uint256);\\n\\n  /* ========== EVENTS ========== */\\n\\n  event RewardAdded(uint256 reward);\\n  event Staked(\\n    address indexed user,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    StakedPositionType positionType,\\n    uint256 baseTokenExchangeRate\\n  );\\n  event DepositedAndStaked(address indexed user, uint256 depositedAmount, uint256 indexed tokenId, uint256 amount);\\n  event DepositedToCurve(address indexed user, uint256 fiduAmount, uint256 usdcAmount, uint256 tokensReceived);\\n  event DepositedToCurveAndStaked(\\n    address indexed user,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount,\\n    uint256 indexed tokenId,\\n    uint256 amount\\n  );\\n  event Unstaked(address indexed user, uint256 indexed tokenId, uint256 amount, StakedPositionType positionType);\\n  event UnstakedMultiple(address indexed user, uint256[] tokenIds, uint256[] amounts);\\n  event UnstakedAndWithdrew(address indexed user, uint256 usdcReceivedAmount, uint256 indexed tokenId, uint256 amount);\\n  event UnstakedAndWithdrewMultiple(\\n    address indexed user,\\n    uint256 usdcReceivedAmount,\\n    uint256[] tokenIds,\\n    uint256[] amounts\\n  );\\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\\n  event RewardsParametersUpdated(\\n    address indexed who,\\n    uint256 targetCapacity,\\n    uint256 minRate,\\n    uint256 maxRate,\\n    uint256 minRateAtPercent,\\n    uint256 maxRateAtPercent\\n  );\\n  event EffectiveMultiplierUpdated(address indexed who, StakedPositionType positionType, uint256 multiplier);\\n}\\n\\n/// @notice Indicates which ERC20 is staked\\nenum StakedPositionType {\\n  Fidu,\\n  CurveLP\\n}\\n\\nstruct Rewards {\\n  uint256 totalUnvested;\\n  uint256 totalVested;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this was used in the case of slashing.\\n  //   For non-vesting positions, this is unused.\\n  uint256 totalPreviouslyVested;\\n  uint256 totalClaimed;\\n  uint256 startTime;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this is the endTime of the vesting.\\n  //   For non-vesting positions, this is 0.\\n  uint256 endTime;\\n}\\n\\nstruct StakedPosition {\\n  // @notice Staked amount denominated in `stakingToken().decimals()`\\n  uint256 amount;\\n  // @notice Struct describing rewards owed with vesting\\n  Rewards rewards;\\n  // @notice Multiplier applied to staked amount when locking up position\\n  uint256 leverageMultiplier;\\n  // @notice Time in seconds after which position can be unstaked\\n  uint256 lockedUntil;\\n  // @notice Type of the staked position\\n  StakedPositionType positionType;\\n  // @notice Multiplier applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeEffectiveMultiplier()`, which correctly handles old staked positions.\\n  uint256 unsafeEffectiveMultiplier;\\n  // @notice Exchange rate applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeBaseTokenExchangeRate()`, which correctly handles old staked positions.\\n  uint256 unsafeBaseTokenExchangeRate;\\n}\\n\",\"keccak256\":\"0xb001875f3e7a6414f8e72cf25afdd30cd949fd2b0a219a4778b8027ef1d26667\",\"license\":\"MIT\"},\"contracts/interfaces/ITranchedPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {IV2CreditLine} from \\\"./IV2CreditLine.sol\\\";\\n\\nabstract contract ITranchedPool {\\n  IV2CreditLine public creditLine;\\n  uint256 public createdAt;\\n  enum Tranches {\\n    Reserved,\\n    Senior,\\n    Junior\\n  }\\n\\n  struct TrancheInfo {\\n    uint256 id;\\n    uint256 principalDeposited;\\n    uint256 principalSharePrice;\\n    uint256 interestSharePrice;\\n    uint256 lockedUntil;\\n  }\\n\\n  struct PoolSlice {\\n    TrancheInfo seniorTranche;\\n    TrancheInfo juniorTranche;\\n    uint256 totalInterestAccrued;\\n    uint256 principalDeployed;\\n  }\\n\\n  function initialize(\\n    address _config,\\n    address _borrower,\\n    uint256 _juniorFeePercent,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays,\\n    uint256 _fundableAt,\\n    uint256[] calldata _allowedUIDTypes\\n  ) public virtual;\\n\\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\\n\\n  function pay(uint256 amount) external virtual;\\n\\n  function poolSlices(uint256 index) external view virtual returns (PoolSlice memory);\\n\\n  function lockJuniorCapital() external virtual;\\n\\n  function lockPool() external virtual;\\n\\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\\n\\n  function totalJuniorDeposits() external view virtual returns (uint256);\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function setFundableAt(uint256 timestamp) external virtual;\\n\\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\\n\\n  function assess() external virtual;\\n\\n  function depositWithPermit(\\n    uint256 tranche,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 tokenId);\\n\\n  function availableToWithdraw(uint256 tokenId)\\n    external\\n    view\\n    virtual\\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\\n\\n  function withdraw(uint256 tokenId, uint256 amount)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMax(uint256 tokenId)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\\n\\n  function numSlices() external view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x7a21d304a7ba635f4a074488d152c62c6b8b442cc5a5ad85a454621f4baec659\",\"license\":\"MIT\"},\"contracts/interfaces/IV2CreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ICreditLine.sol\\\";\\n\\nabstract contract IV2CreditLine is ICreditLine {\\n  function principal() external view virtual returns (uint256);\\n\\n  function totalInterestAccrued() external view virtual returns (uint256);\\n\\n  function termStartTime() external view virtual returns (uint256);\\n\\n  function setLimit(uint256 newAmount) external virtual;\\n\\n  function setMaxLimit(uint256 newAmount) external virtual;\\n\\n  function setBalance(uint256 newBalance) external virtual;\\n\\n  function setPrincipal(uint256 _principal) external virtual;\\n\\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function assess()\\n    external\\n    virtual\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function initialize(\\n    address _config,\\n    address owner,\\n    address _borrower,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays\\n  ) public virtual;\\n\\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\\n\\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\\n\\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\\n\\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\\n\\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\\n\\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\\n\\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\\n\\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\\n}\\n\",\"keccak256\":\"0xc72be7462ade69ec2d4bb18344cfe1c8b4659bd68314cef013aa5616bfe8f607\",\"license\":\"MIT\"},\"contracts/interfaces/openzeppelin/IERC165.sol\":{\"content\":\"pragma solidity >=0.6.0;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbbdb8f6dfaecd47a0d65bee707877d6974a0e0da6c02403ad5ce00590bd97497\"},\"contracts/interfaces/openzeppelin/IERC721.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >= & reference other >= pragma interfaces.\\n// NOTE: Modified to reference our updated pragma version of IERC165\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of NFTs in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the NFT specified by `tokenId`.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   *\\n   *\\n   * Requirements:\\n   * - `from`, `to` cannot be zero.\\n   * - `tokenId` must be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this\\n   * NFT by either {approve} or {setApprovalForAll}.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Requirements:\\n   * - If the caller is not `from`, it must be approved to move this NFT by\\n   * either {approve} or {setApprovalForAll}.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  function approve(address to, uint256 tokenId) external;\\n\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x2527635bd6ab0d348f5f7d325ef2241a544586bb85dd806053adf1cc409293e5\"},\"contracts/interfaces/openzeppelin/IERC721Enumerable.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x7fd709ba4093899fc4593cb1413132e127773a349a8aef9ce234d62fa36b5fca\"},\"contracts/interfaces/openzeppelin/IERC721Metadata.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x56c56c47d03d0ea452a13842ad2e3e5b81b3689c484efd35a48f3977e9b929d8\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b5061038b806100206000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c80630c04501214610046578063803fe83e1461008b578063c4d66de8146100a0575b600080fd5b61006f6100543660046102c7565b6001602052600090815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b61009e610099366004610301565b6100b3565b005b61009e6100ae366004610338565b6101a8565b634d338fb360e11b60005260016020527f464486f5ada59117002db44fc2e81c950f36818416e60d642245c28d6136cfde54604051632a6e138b60e11b81523060048201523360248201526001600160a01b039091169081906354dc27169060440160006040518083038186803b15801561012d57600080fd5b505afa158015610141573d6000803e3d6000fd5b505050506001600160e01b0319831660008181526001602052604080822080546001600160a01b0319166001600160a01b03871690811790915590519092917f85e6f4175f6948ee141dece520c69e2c164f0cd3219c6a9c280e3b8690b841f391a3505050565b600054610100900460ff16806101c1575060005460ff16155b6102285760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840160405180910390fd5b600054610100900460ff1615801561024a576000805461ffff19166101011790555b634d338fb360e11b60005260016020527f464486f5ada59117002db44fc2e81c950f36818416e60d642245c28d6136cfde80546001600160a01b0319166001600160a01b03841617905580156102a6576000805461ff00191690555b5050565b80356001600160e01b0319811681146102c257600080fd5b919050565b6000602082840312156102d957600080fd5b6102e2826102aa565b9392505050565b6001600160a01b03811681146102fe57600080fd5b50565b6000806040838503121561031457600080fd5b61031d836102aa565b9150602083013561032d816102e9565b809150509250929050565b60006020828403121561034a57600080fd5b81356102e2816102e956fea264697066735822122043be5f6ed1f71b99d579ddccae1e2e3b751d49b3dca2d19d94772fae5e4ec4d364736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c80630c04501214610046578063803fe83e1461008b578063c4d66de8146100a0575b600080fd5b61006f6100543660046102c7565b6001602052600090815260409020546001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b61009e610099366004610301565b6100b3565b005b61009e6100ae366004610338565b6101a8565b634d338fb360e11b60005260016020527f464486f5ada59117002db44fc2e81c950f36818416e60d642245c28d6136cfde54604051632a6e138b60e11b81523060048201523360248201526001600160a01b039091169081906354dc27169060440160006040518083038186803b15801561012d57600080fd5b505afa158015610141573d6000803e3d6000fd5b505050506001600160e01b0319831660008181526001602052604080822080546001600160a01b0319166001600160a01b03871690811790915590519092917f85e6f4175f6948ee141dece520c69e2c164f0cd3219c6a9c280e3b8690b841f391a3505050565b600054610100900460ff16806101c1575060005460ff16155b6102285760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840160405180910390fd5b600054610100900460ff1615801561024a576000805461ffff19166101011790555b634d338fb360e11b60005260016020527f464486f5ada59117002db44fc2e81c950f36818416e60d642245c28d6136cfde80546001600160a01b0319166001600160a01b03841617905580156102a6576000805461ff00191690555b5050565b80356001600160e01b0319811681146102c257600080fd5b919050565b6000602082840312156102d957600080fd5b6102e2826102aa565b9392505050565b6001600160a01b03811681146102fe57600080fd5b50565b6000806040838503121561031457600080fd5b61031d836102aa565b9150602083013561032d816102e9565b809150509250929050565b60006020828403121561034a57600080fd5b81356102e2816102e956fea264697066735822122043be5f6ed1f71b99d579ddccae1e2e3b751d49b3dca2d19d94772fae5e4ec4d364736f6c63430008100033",
  "devdoc": {
    "author": "landakram",
    "kind": "dev",
    "methods": {
      "setContract(bytes4,address)": {
        "details": "This function is only callable by the Router admin",
        "params": {
          "addr": "A contract address",
          "key": "A routing key (defined in the `Routing.Keys` libary)"
        }
      }
    },
    "title": "Router",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "contracts(bytes4)": {
        "notice": "Mapping of keys to contract addresses. Keys are the first 4 bytes of the keccak of   the contract's name. See Routing.sol for all options."
      },
      "setContract(bytes4,address)": {
        "notice": "Associate a routing key to a contract address"
      }
    },
    "notice": "This contract provides service discovery for contracts using the cake framework.   It can be used in conjunction with the convenience methods defined in the `Routing.Context`   and `Routing.Keys` libraries.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 663,
        "contract": "contracts/cake/Router.sol:Router",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 666,
        "contract": "contracts/cake/Router.sol:Router",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 5225,
        "contract": "contracts/cake/Router.sol:Router",
        "label": "contracts",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes4,t_address)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_mapping(t_bytes4,t_address)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      }
    }
  }
}