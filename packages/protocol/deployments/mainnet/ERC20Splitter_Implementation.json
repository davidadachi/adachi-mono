{
  "address": "0xe7ab44418A0B80ed1748d4A58067EA9DF0d84dfa",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract Context",
          "name": "_context",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "_erc20",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "IntraBlockDistribution",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidReceiver",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LengthMismatch",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "resource",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "accessor",
          "type": "address"
        }
      ],
      "name": "RequiresOperator",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "total",
          "type": "uint256"
        }
      ],
      "name": "Distributed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Paused",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "payee",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "share",
          "type": "uint256"
        }
      ],
      "name": "PayeeAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "Unpaused",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "distribute",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "erc20",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lastDistributionAt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "paused",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "payees",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "payee",
          "type": "address"
        }
      ],
      "name": "pendingDistributionFor",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "_payees",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "_shares",
          "type": "uint256[]"
        }
      ],
      "name": "replacePayees",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "shares",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalShares",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "unpause",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xcf723c45072f74e22fd321a89016ac28208c135feb8c44a11a1aedf9920f770e",
  "receipt": {
    "to": null,
    "from": "0x2Fbf774ec12Bd86a60E563F0653AEee4DEbA0DB8",
    "contractAddress": "0xe7ab44418A0B80ed1748d4A58067EA9DF0d84dfa",
    "transactionIndex": 19,
    "gasUsed": "1083915",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xbad6e1dd7a6614eb8ab4832b52c19874b47e53ce2c4d03565c2b3a73d8d330ca",
    "transactionHash": "0xcf723c45072f74e22fd321a89016ac28208c135feb8c44a11a1aedf9920f770e",
    "logs": [],
    "blockNumber": 15992889,
    "cumulativeGasUsed": "3643037",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xd16BC944Bf20c86c4ED47Ce1a330a18538674C83",
    "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"
  ],
  "solcInputHash": "eac65dc40e06b4b044f441f03029567a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract Context\",\"name\":\"_context\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_erc20\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IntraBlockDistribution\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"}],\"name\":\"RequiresOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"Distributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"share\",\"type\":\"uint256\"}],\"name\":\"PayeeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"erc20\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDistributionAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payees\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"pendingDistributionFor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"}],\"name\":\"replacePayees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"shares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"landakram\",\"kind\":\"dev\",\"methods\":{\"paused()\":{\"details\":\"Returns true if the contract is paused, and false otherwise.\"},\"replacePayees(address[],uint256[])\":{\"params\":{\"_payees\":\"An array of addresses to receive distributions\",\"_shares\":\"An array of shares (ordered by `_payees`) to use for distributions\"}}},\"title\":\"ERC20Splitter\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"distribute()\":{\"notice\":\"Distribute the current balance to payees. If a payee is a smart contract   implementing `IERC20SplitterReceiver`, then its `onReceive` handler function will   be called after it receives its share.\"},\"erc20()\":{\"notice\":\"The ERC20 that is distributed to payees\"},\"lastDistributionAt()\":{\"notice\":\"The block.timestamp when `distribute` was last called\"},\"payees(uint256)\":{\"notice\":\"A list of payees\"},\"replacePayees(address[],uint256[])\":{\"notice\":\"Replace all current payees with a new set of payees and shares\"},\"shares(address)\":{\"notice\":\"Payee shares\"},\"totalShares()\":{\"notice\":\"The total number of shares in the splitter. A payee's proportion   of the split can be calculated as its share / totalShares.\"}},\"notice\":\"Splits the ERC20 balance of this contract amongst a list of payees.   Unlike similar splitter contracts, all shares of the balance are distributed   in a single `distribute` transaction. If a payee is a smart contract implementing   `IERC20SplitterReceiver`, then its `onReceive` handler function will be called   after it receives its share.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/core/membership/ERC20Splitter.sol\":\"ERC20Splitter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\",\"keccak256\":\"0xe6220d2b5a54ac7497313ce4503cca742b09dc5e3a4eb76fb0afff85b1b97a34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721Upgradeable.sol\\\";\\n\",\"keccak256\":\"0x28c8a2c5850343f4fb44847b736df5a89fb16c90971c8c06c8066c04ad9b70df\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal initializer {\\n        __Context_init_unchained();\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal initializer {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x742c0fbab73bf595ca40025f6e81cb48dbd5e133950717f7befd062a925c0148\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf449ca0a763d4b1b4462cf8706857074492f324020a2b9d099181b5383055ad3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xfbb3ca7272af58dc245a20e91a1f68481ee04706fa3fe46d184000efc21f4bad\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal initializer {\\n        __Context_init_unchained();\\n    }\\n\\n    function __Context_init_unchained() internal initializer {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x062b5a0f7cc6b0528fa350033759f3a15ba42afb57423d7c593753860f2c82e0\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x1c4860acd323e34a67b3e97faab9aaa55fe8e92b1dcf08b5f47f3468d58ce75c\",\"license\":\"MIT\"},\"contracts/cake/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IAccessControl.sol\\\";\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ncontract AccessControl is Initializable, IAccessControl {\\n  /// @dev Mapping from contract address to contract admin;\\n  mapping(address => address) public admins;\\n\\n  function initialize(address admin) public initializer {\\n    admins[address(this)] = admin;\\n    emit AdminSet(address(this), admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function setAdmin(address resource, address admin) external {\\n    requireSuperAdmin(msg.sender);\\n    admins[resource] = admin;\\n    emit AdminSet(resource, admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireAdmin(address resource, address accessor) public view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n    bool isAdmin = admins[resource] == accessor;\\n    if (!isAdmin) revert RequiresAdmin(resource, accessor);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireSuperAdmin(address accessor) public view {\\n    // The super admin is the admin of this AccessControl contract\\n    requireAdmin({resource: address(this), accessor: accessor});\\n  }\\n}\\n\",\"keccak256\":\"0x1b70acad9e92a3b0898a989d413bb16b5c5707faf84f2eb31354b453385a7b54\",\"license\":\"MIT\"},\"contracts/cake/Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Context} from \\\"./Context.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nusing Routing.Context for Context;\\n\\n/// @title Base contract for application-layer\\n/// @author landakram\\n/// @notice This base contract is what all application-layer contracts should inherit from.\\n///  It provides `Context`, as well as some convenience functions for working with it and\\n///  using access control. All public methods on the inheriting contract should likely\\n///  use one of the modifiers to assert valid callers.\\nabstract contract Base {\\n  error RequiresOperator(address resource, address accessor);\\n  error ZeroAddress();\\n\\n  /// @dev this is safe for proxies as immutable causes the context to be written to\\n  ///  bytecode on deployment. The proxy then treats this as a constant.\\n  Context immutable context;\\n\\n  constructor(Context _context) {\\n    context = _context;\\n  }\\n\\n  modifier onlyOperator(bytes4 operatorId) {\\n    requireOperator(operatorId, msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyOperators(bytes4[2] memory operatorIds) {\\n    requireAnyOperator(operatorIds, msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyAdmin() {\\n    context.accessControl().requireAdmin(address(this), msg.sender);\\n    _;\\n  }\\n\\n  function requireAnyOperator(bytes4[2] memory operatorIds, address accessor) private view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n\\n    bool validOperator = isOperator(operatorIds[0], accessor) || isOperator(operatorIds[1], accessor);\\n\\n    if (!validOperator) revert RequiresOperator(address(this), accessor);\\n  }\\n\\n  function requireOperator(bytes4 operatorId, address accessor) private view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n    if (!isOperator(operatorId, accessor)) revert RequiresOperator(address(this), accessor);\\n  }\\n\\n  function isOperator(bytes4 operatorId, address accessor) private view returns (bool) {\\n    return context.router().contracts(operatorId) == accessor;\\n  }\\n}\\n\",\"keccak256\":\"0x1dbf1ce1916f78d7b98876136dbd0be1fc33afc75a7ad9279dcacaaa57c34bc1\",\"license\":\"MIT\"},\"contracts/cake/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {Router} from \\\"./Router.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nusing Routing.Context for Context;\\n\\n/// @title Entry-point for all application-layer contracts.\\n/// @author landakram\\n/// @notice This contract provides an interface for retrieving other contract addresses and doing access\\n///  control.\\ncontract Context {\\n  /// @notice Used for retrieving other contract addresses.\\n  /// @dev This variable is immutable. This is done to save gas, as it is expected to be referenced\\n  /// in every end-user call with a call-chain length > 0. Note that it is written into the contract\\n  /// bytecode at contract creation time, so if the contract is deployed as the implementation for proxies,\\n  /// every proxy will share the same Router address.\\n  Router public immutable router;\\n\\n  constructor(Router _router) {\\n    router = _router;\\n  }\\n}\\n\",\"keccak256\":\"0xa680415dd02e61f8cd730f3198096d73b40fddb2f7f46136fc20e02a173ec107\",\"license\":\"MIT\"},\"contracts/cake/Pausable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n// solhint-disable-next-line max-line-length\\nimport {PausableUpgradeable as OZPausableUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\n\\nimport {Base} from \\\"./Base.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nabstract contract PausableUpgradeable is Base, OZPausableUpgradeable {\\n  function pause() external onlyOperators([Routing.Keys.PauserAdmin, Routing.Keys.ProtocolAdmin]) {\\n    _pause();\\n  }\\n\\n  function unpause() external onlyOperators([Routing.Keys.PauserAdmin, Routing.Keys.ProtocolAdmin]) {\\n    _unpause();\\n  }\\n}\\n\",\"keccak256\":\"0x9981af99a8be883cd8ef83abf60d0286d0f4b9ea70b013b1a0c32bcc54b3d6c8\",\"license\":\"MIT\"},\"contracts/cake/Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\n\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\n/// @title Router\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ncontract Router is Initializable, IRouter {\\n  /// @notice Mapping of keys to contract addresses. Keys are the first 4 bytes of the keccak of\\n  ///   the contract's name. See Routing.sol for all options.\\n  mapping(bytes4 => address) public contracts;\\n\\n  function initialize(AccessControl accessControl) public initializer {\\n    contracts[Routing.Keys.AccessControl] = address(accessControl);\\n  }\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) public {\\n    AccessControl accessControl = AccessControl(contracts[Routing.Keys.AccessControl]);\\n    accessControl.requireAdmin(address(this), msg.sender);\\n    contracts[key] = addr;\\n    emit SetContract(key, addr);\\n  }\\n}\\n\",\"keccak256\":\"0x686176336adffd914b35e6cc23b551c4af63c43eba9c5416749427a5e02a98b0\",\"license\":\"MIT\"},\"contracts/cake/Routing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable const-name-snakecase\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\n\\nimport {IMembershipVault} from \\\"../interfaces/IMembershipVault.sol\\\";\\nimport {IGFILedger} from \\\"../interfaces/IGFILedger.sol\\\";\\nimport {ICapitalLedger} from \\\"../interfaces/ICapitalLedger.sol\\\";\\nimport {IMembershipDirector} from \\\"../interfaces/IMembershipDirector.sol\\\";\\nimport {IMembershipOrchestrator} from \\\"../interfaces/IMembershipOrchestrator.sol\\\";\\nimport {IMembershipLedger} from \\\"../interfaces/IMembershipLedger.sol\\\";\\nimport {IMembershipCollector} from \\\"../interfaces/IMembershipCollector.sol\\\";\\n\\nimport {ISeniorPool} from \\\"../interfaces/ISeniorPool.sol\\\";\\nimport {IPoolTokens} from \\\"../interfaces/IPoolTokens.sol\\\";\\nimport {IStakingRewards} from \\\"../interfaces/IStakingRewards.sol\\\";\\n\\nimport {IERC20Splitter} from \\\"../interfaces/IERC20Splitter.sol\\\";\\nimport {Context as ContextContract} from \\\"./Context.sol\\\";\\nimport {IAccessControl} from \\\"../interfaces/IAccessControl.sol\\\";\\n\\nimport {Router} from \\\"./Router.sol\\\";\\n\\n/// @title Routing.Keys\\n/// @notice This library is used to define routing keys used by `Router`.\\n/// @dev We use uints instead of enums for several reasons. First, keys can be re-ordered\\n///   or removed. This is useful when routing keys are deprecated; they can be moved to a\\n///   different section of the file. Second, other libraries or contracts can define their\\n///   own routing keys independent of this global mapping. This is useful for test contracts.\\nlibrary Keys {\\n  // Membership\\n  bytes4 internal constant MembershipOrchestrator = bytes4(keccak256(\\\"MembershipOrchestrator\\\"));\\n  bytes4 internal constant MembershipDirector = bytes4(keccak256(\\\"MembershipDirector\\\"));\\n  bytes4 internal constant GFILedger = bytes4(keccak256(\\\"GFILedger\\\"));\\n  bytes4 internal constant CapitalLedger = bytes4(keccak256(\\\"CapitalLedger\\\"));\\n  bytes4 internal constant MembershipCollector = bytes4(keccak256(\\\"MembershipCollector\\\"));\\n  bytes4 internal constant MembershipLedger = bytes4(keccak256(\\\"MembershipLedger\\\"));\\n  bytes4 internal constant MembershipVault = bytes4(keccak256(\\\"MembershipVault\\\"));\\n\\n  // Tokens\\n  bytes4 internal constant GFI = bytes4(keccak256(\\\"GFI\\\"));\\n  bytes4 internal constant FIDU = bytes4(keccak256(\\\"FIDU\\\"));\\n  bytes4 internal constant USDC = bytes4(keccak256(\\\"USDC\\\"));\\n\\n  // Cake\\n  bytes4 internal constant AccessControl = bytes4(keccak256(\\\"AccessControl\\\"));\\n  bytes4 internal constant Router = bytes4(keccak256(\\\"Router\\\"));\\n\\n  // Core\\n  bytes4 internal constant ReserveSplitter = bytes4(keccak256(\\\"ReserveSplitter\\\"));\\n  bytes4 internal constant PoolTokens = bytes4(keccak256(\\\"PoolTokens\\\"));\\n  bytes4 internal constant SeniorPool = bytes4(keccak256(\\\"SeniorPool\\\"));\\n  bytes4 internal constant StakingRewards = bytes4(keccak256(\\\"StakingRewards\\\"));\\n  bytes4 internal constant ProtocolAdmin = bytes4(keccak256(\\\"ProtocolAdmin\\\"));\\n  bytes4 internal constant PauserAdmin = bytes4(keccak256(\\\"PauserAdmin\\\"));\\n}\\n\\n/// @title Routing.Context\\n/// @notice This library provides convenience functions for getting contracts from `Router`.\\nlibrary Context {\\n  function accessControl(ContextContract context) internal view returns (IAccessControl) {\\n    return IAccessControl(context.router().contracts(Keys.AccessControl));\\n  }\\n\\n  function membershipVault(ContextContract context) internal view returns (IMembershipVault) {\\n    return IMembershipVault(context.router().contracts(Keys.MembershipVault));\\n  }\\n\\n  function capitalLedger(ContextContract context) internal view returns (ICapitalLedger) {\\n    return ICapitalLedger(context.router().contracts(Keys.CapitalLedger));\\n  }\\n\\n  function gfiLedger(ContextContract context) internal view returns (IGFILedger) {\\n    return IGFILedger(context.router().contracts(Keys.GFILedger));\\n  }\\n\\n  function gfi(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.GFI));\\n  }\\n\\n  function membershipDirector(ContextContract context) internal view returns (IMembershipDirector) {\\n    return IMembershipDirector(context.router().contracts(Keys.MembershipDirector));\\n  }\\n\\n  function membershipOrchestrator(ContextContract context) internal view returns (IMembershipOrchestrator) {\\n    return IMembershipOrchestrator(context.router().contracts(Keys.MembershipOrchestrator));\\n  }\\n\\n  function stakingRewards(ContextContract context) internal view returns (IStakingRewards) {\\n    return IStakingRewards(context.router().contracts(Keys.StakingRewards));\\n  }\\n\\n  function poolTokens(ContextContract context) internal view returns (IPoolTokens) {\\n    return IPoolTokens(context.router().contracts(Keys.PoolTokens));\\n  }\\n\\n  function seniorPool(ContextContract context) internal view returns (ISeniorPool) {\\n    return ISeniorPool(context.router().contracts(Keys.SeniorPool));\\n  }\\n\\n  function fidu(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.FIDU));\\n  }\\n\\n  function usdc(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.USDC));\\n  }\\n\\n  function reserveSplitter(ContextContract context) internal view returns (IERC20Splitter) {\\n    return IERC20Splitter(context.router().contracts(Keys.ReserveSplitter));\\n  }\\n\\n  function membershipLedger(ContextContract context) internal view returns (IMembershipLedger) {\\n    return IMembershipLedger(context.router().contracts(Keys.MembershipLedger));\\n  }\\n\\n  function membershipCollector(ContextContract context) internal view returns (IMembershipCollector) {\\n    return IMembershipCollector(context.router().contracts(Keys.MembershipCollector));\\n  }\\n\\n  function protocolAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.ProtocolAdmin);\\n  }\\n\\n  function pauserAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.PauserAdmin);\\n  }\\n}\\n\",\"keccak256\":\"0x4a324049c639da20482479082129fc570daa0f06dbdd25fdce46ad401f8ec7c5\",\"license\":\"MIT\"},\"contracts/interfaces/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ninterface IAccessControl {\\n  error RequiresAdmin(address resource, address accessor);\\n  error ZeroAddress();\\n\\n  event AdminSet(address indexed resource, address indexed admin);\\n\\n  /// @notice Set an admin for a given resource\\n  /// @param resource An address which with `admin` should be allowed to administer\\n  /// @param admin An address which should be allowed to administer `resource`\\n  /// @dev This method is only callable by the super-admin (the admin of this AccessControl\\n  ///   contract)\\n  function setAdmin(address resource, address admin) external;\\n\\n  /// @notice Require a valid admin for a given resource\\n  /// @param resource An address that `accessor` is attempting to access\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid admin\\n  function requireAdmin(address resource, address accessor) external view;\\n\\n  /// @notice Require a super-admin. A super-admin is an admin of this AccessControl contract.\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid super-admin\\n  function requireSuperAdmin(address accessor) external view;\\n}\\n\",\"keccak256\":\"0xa77d24e074f86c95657ada01678e9c7136b8769856182428f0f2cb6d191b341f\",\"license\":\"MIT\"},\"contracts/interfaces/ICapitalLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nenum CapitalAssetType {\\n  INVALID,\\n  ERC721\\n}\\n\\ninterface ICapitalLedger {\\n  /**\\n   * @notice Emitted when a new capital erc721 deposit has been made\\n   * @param owner address owning the deposit\\n   * @param assetAddress address of the deposited ERC721\\n   * @param positionId id for the deposit\\n   * @param assetTokenId id of the token from the ERC721 `assetAddress`\\n   * @param usdcEquivalent usdc equivalent value at the time of deposit\\n   */\\n  event CapitalERC721Deposit(\\n    address indexed owner,\\n    address indexed assetAddress,\\n    uint256 positionId,\\n    uint256 assetTokenId,\\n    uint256 usdcEquivalent\\n  );\\n\\n  /**\\n   * @notice Emitted when a new ERC721 capital withdrawal has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the capital position\\n   * @param assetAddress address of the underlying ERC721\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event CapitalERC721Withdrawal(\\n    address indexed owner,\\n    uint256 positionId,\\n    address assetAddress,\\n    uint256 depositTimestamp\\n  );\\n\\n  /// Thrown when called with an invalid asset type for the function. Valid\\n  /// types are defined under CapitalAssetType\\n  error InvalidAssetType(CapitalAssetType);\\n\\n  /**\\n   * @notice Account for a deposit of `id` for the ERC721 asset at `assetAddress`.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param owner address that owns the position\\n   * @param assetAddress address of the ERC20 address\\n   * @param assetTokenId id of the ERC721 asset to add\\n   * @return id of the newly created position\\n   */\\n  function depositERC721(\\n    address owner,\\n    address assetAddress,\\n    uint256 assetTokenId\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Get the id of the ERC721 asset held by position `id`. Pair this with\\n   *  `assetAddressOf` to get the address & id of the nft.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param positionId id of the position\\n   * @return id of the underlying ERC721 asset\\n   */\\n  function erc721IdOf(uint256 positionId) external view returns (uint256);\\n\\n  /**\\n   * @notice Completely withdraw a position\\n   * @param positionId id of the position\\n   */\\n  function withdraw(uint256 positionId) external;\\n\\n  /**\\n   * @notice Get the asset address of the position. Example: For an ERC721 position, this\\n   *  returns the address of that ERC721 contract.\\n   * @param positionId id of the position\\n   * @return asset address of the position\\n   */\\n  function assetAddressOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the number of capital positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return position id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the USDC value of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @param owner address owning the positions\\n   * @return eligibleAmount USDC value of positions eligible for rewards\\n   * @return totalAmount total USDC value of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xfd869b44e49041db9fb9ef2f6c00fcfceb38ba20f26631562cfb48fa2bec12ef\",\"license\":\"MIT\"},\"contracts/interfaces/ICreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICreditLine {\\n  function borrower() external view returns (address);\\n\\n  function limit() external view returns (uint256);\\n\\n  function maxLimit() external view returns (uint256);\\n\\n  function interestApr() external view returns (uint256);\\n\\n  function paymentPeriodInDays() external view returns (uint256);\\n\\n  function principalGracePeriodInDays() external view returns (uint256);\\n\\n  function termInDays() external view returns (uint256);\\n\\n  function lateFeeApr() external view returns (uint256);\\n\\n  function isLate() external view returns (bool);\\n\\n  function withinPrincipalGracePeriod() external view returns (bool);\\n\\n  // Accounting variables\\n  function balance() external view returns (uint256);\\n\\n  function interestOwed() external view returns (uint256);\\n\\n  function principalOwed() external view returns (uint256);\\n\\n  function termEndTime() external view returns (uint256);\\n\\n  function nextDueTime() external view returns (uint256);\\n\\n  function interestAccruedAsOf() external view returns (uint256);\\n\\n  function lastFullPaymentTime() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd54b264344ce302597ee4f04f147000275d05c8fc9612cc21eaff915ff1f30c8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Splitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IERC20Splitter {\\n  function lastDistributionAt() external view returns (uint256);\\n\\n  function distribute() external;\\n\\n  function replacePayees(address[] calldata _payees, uint256[] calldata _shares) external;\\n\\n  function pendingDistributionFor(address payee) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x915a4058d1c4f6e694e1fdbaa708d3ec7e26dba3162f83290d997ec484960972\",\"license\":\"MIT\"},\"contracts/interfaces/IGFILedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IGFILedger {\\n  struct Position {\\n    // Owner of the position\\n    address owner;\\n    // Index of the position in the ownership array\\n    uint256 ownedIndex;\\n    // Amount of GFI held in the position\\n    uint256 amount;\\n    // When the position was deposited\\n    uint256 depositTimestamp;\\n  }\\n\\n  /**\\n   * @notice Emitted when a new GFI deposit has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the deposit\\n   * @param amount how much GFI was deposited\\n   */\\n  event GFIDeposit(address indexed owner, uint256 indexed positionId, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when a new GFI withdrawal has been made. If the remaining amount is 0, the position has bee removed\\n   * @param owner address owning the withdrawn position\\n   * @param positionId id for the position\\n   * @param remainingAmount how much GFI is remaining in the position\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event GFIWithdrawal(\\n    address indexed owner,\\n    uint256 indexed positionId,\\n    uint256 withdrawnAmount,\\n    uint256 remainingAmount,\\n    uint256 depositTimestamp\\n  );\\n\\n  /**\\n   * @notice Account for a new deposit by the owner.\\n   * @param owner address to account for the deposit\\n   * @param amount how much was deposited\\n   * @return how much was deposited\\n   */\\n  function deposit(address owner, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @param amount how much to withdraw\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Get the number of GFI positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return token id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get amount of GFI of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @return eligibleAmount GFI amount of positions eligible for rewards\\n   * @return totalAmount total GFI amount of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xa4aa4178b7ffd3d92d0db9f489cea52b574df2207ae463433472ccd5d4b67372\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipCollector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipCollector {\\n  /// @notice Have the collector distribute `amount` of Fidu to `addr`\\n  /// @param addr address to distribute to\\n  /// @param amount amount to distribute\\n  function distributeFiduTo(address addr, uint256 amount) external;\\n\\n  /// @notice Get the last epoch finalized by the collector. This means the\\n  ///  collector will no longer add rewards to the epoch.\\n  /// @return the last finalized epoch\\n  function lastFinalizedEpoch() external view returns (uint256);\\n\\n  /// @notice Get the rewards associated with `epoch`. This amount may change\\n  ///  until `epoch` has been finalized (is less than or equal to getLastFinalizedEpoch)\\n  /// @return rewards associated with `epoch`\\n  function rewardsForEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n  ///  this will be the fixed, accurate reward for the epoch. For the current and other\\n  ///  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n  ///  moment.\\n  /// @param epoch epoch to estimate the rewards of\\n  /// @return rewards associated with `epoch`\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0x8ea890c7237ee09c340afa47bce4fe6fd2e6d65bce601620edb1513e4b0f3914\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipDirector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipDirector {\\n  /**\\n   * @notice Adjust an `owner`s membership score and position due to the change\\n   *  in their GFI and Capital holdings\\n   * @param owner address who's holdings changed\\n   * @return id of membership position\\n   */\\n  function consumeHoldingsAdjustment(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Collect all membership yield enhancements for the owner.\\n   * @param owner address to claim rewards for\\n   * @return amount of yield enhancements collected\\n   */\\n  function collectRewards(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable for the owner. The return\\n   *  value here is how much would be retrieved by calling `collectRewards`.\\n   * @param owner address to calculate claimable rewards for\\n   * @return the amount of rewards that could be claimed by the owner\\n   */\\n  function claimableRewards(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate the membership score\\n   * @param gfi Amount of gfi\\n   * @param capital Amount of capital in USDC\\n   * @return membership score\\n   */\\n  function calculateMembershipScore(uint256 gfi, uint256 capital) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the current score of `owner`\\n   * @param owner address to check the score of\\n   * @return eligibleScore score that is currently eligible for rewards\\n   * @return totalScore score that will be elgible for rewards next epoch\\n   */\\n  function currentScore(address owner) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc4ad3f9a21473122dc03f92db9f78b3da14468ff17f7892e5feb6fed6f882abd\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipLedger {\\n  /**\\n   * @notice Set `addr`s allocated rewards back to 0\\n   * @param addr address to reset rewards on\\n   */\\n  function resetRewards(address addr) external;\\n\\n  /**\\n   * @notice Allocate `amount` rewards for `addr` but do not send them\\n   * @param addr address to distribute rewards to\\n   * @param amount amount of rewards to allocate for `addr`\\n   * @return rewards total allocated to `addr`\\n   */\\n  function allocateRewardsTo(address addr, uint256 amount) external returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the rewards allocated to a certain `addr`\\n   * @param addr the address to check pending rewards for\\n   * @return rewards pending rewards for `addr`\\n   */\\n  function getPendingRewardsFor(address addr) external view returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the alpha parameter for the cobb douglas function. Will always be in (0,1).\\n   * @return numerator numerator for the alpha param\\n   * @return denominator denominator for the alpha param\\n   */\\n  function alpha() external view returns (uint128 numerator, uint128 denominator);\\n}\\n\",\"keccak256\":\"0x56bfc0d3ed5f532e3f36387d705f047252ba3cbeb8374e4bc51ed59a68197a33\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipOrchestrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nimport {Context} from \\\"../cake/Context.sol\\\";\\n\\nstruct CapitalDeposit {\\n  /// Address of the asset being deposited\\n  /// @dev must be supported in CapitalAssets.sol\\n  address assetAddress;\\n  /// Id of the nft\\n  uint256 id;\\n}\\n\\nstruct Deposit {\\n  /// Amount of gfi to deposit\\n  uint256 gfi;\\n  /// List of capital deposits\\n  CapitalDeposit[] capitalDeposits;\\n}\\n\\nstruct DepositResult {\\n  uint256 membershipId;\\n  uint256 gfiPositionId;\\n  uint256[] capitalPositionIds;\\n}\\n\\nstruct ERC20Withdrawal {\\n  uint256 id;\\n  uint256 amount;\\n}\\n\\nstruct Withdrawal {\\n  /// List of gfi token ids to withdraw\\n  ERC20Withdrawal[] gfiPositions;\\n  /// List of capital token ids to withdraw\\n  uint256[] capitalPositions;\\n}\\n\\n/**\\n * @title MembershipOrchestrator\\n * @notice Externally facing gateway to all Goldfinch membership functionality.\\n * @author Goldfinch\\n */\\ninterface IMembershipOrchestrator {\\n  /**\\n   * @notice Deposit multiple assets defined in `multiDeposit`. Assets can include GFI, Staked Fidu,\\n   *  and others.\\n   * @param deposit struct describing all the assets to deposit\\n   * @return ids all of the ids of the created depoits, in the same order as deposit. If GFI is\\n   *  present, it will be the first id.\\n   */\\n  function deposit(Deposit calldata deposit) external returns (DepositResult memory);\\n\\n  /**\\n   * @notice Withdraw multiple assets defined in `multiWithdraw`. Assets can be GFI or capital\\n   *  positions ids. Caller must have been permitted to act upon all of the positions.\\n   * @param withdrawal all of the GFI and Capital ids to withdraw\\n   */\\n  function withdraw(Withdrawal calldata withdrawal) external;\\n\\n  /**\\n   * @notice Collect all membership rewards for the caller.\\n   * @return how many rewards were collected and sent to caller\\n   */\\n  function collectRewards() external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable at this moment in time for caller.\\n   * @param addr the address to check claimable rewards for\\n   * @return how many rewards could be claimed by a call to `collectRewards`\\n   */\\n  function claimableRewards(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Check the voting power of a given address\\n   * @param addr the address to check the voting power of\\n   * @return the voting power\\n   */\\n  function votingPower(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get all GFI in Membership held by `addr`. This returns the current eligible amount and the\\n   *  total amount of GFI.\\n   * @param addr the owner\\n   * @return eligibleAmount how much GFI is currently eligible for rewards\\n   * @return totalAmount how much GFI is currently eligible for rewards\\n   */\\n  function totalGFIHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get all capital, denominated in USDC, in Membership held by `addr`. This returns the current\\n   *  eligible amount and the total USDC value of capital.\\n   * @param addr the owner\\n   * @return eligibleAmount how much USDC of capital is currently eligible for rewards\\n   * @return totalAmount how much  USDC of capital is currently eligible for rewards\\n   */\\n  function totalCapitalHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get the member score of `addr`\\n   * @param addr the owner\\n   * @return eligibleScore the currently eligible score\\n   * @return totalScore the total score that will be eligible next epoch\\n   *\\n   * @dev if eligibleScore == totalScore then there are no changes between now and the next epoch\\n   */\\n  function memberScoreOf(address addr) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n   *  this will be the fixed, accurate reward for the epoch. For the current and other\\n   *  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n   *  moment.\\n   * @param epoch epoch to estimate the rewards of\\n   * @return rewards associated with `epoch`\\n   */\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate what the Membership Score would be if a `gfi` amount of GFI and `capital` amount\\n   *  of Capital denominated in USDC were deposited.\\n   * @param gfi amount of GFI to estimate with\\n   * @param capital amount of capital to estimate with, denominated in USDC\\n   * @return score the resulting score\\n   */\\n  function calculateMemberScore(uint256 gfi, uint256 capital) external view returns (uint256 score);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc231b961b7ad5e98e45adcc355dd7d3f6f4dd5855486fba35d6f3ef466cbdee0\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\\\";\\n\\nstruct Position {\\n  // address owning the position\\n  address owner;\\n  // how much of the position is eligible as of checkpointEpoch\\n  uint256 eligibleAmount;\\n  // how much of the postion is eligible the epoch after checkpointEpoch\\n  uint256 nextEpochAmount;\\n  // when the position was first created\\n  uint256 createdTimestamp;\\n  // epoch of the last checkpoint\\n  uint256 checkpointEpoch;\\n}\\n\\n/**\\n * @title IMembershipVault\\n * @notice Track assets held by owners in a vault, as well as the total held in the vault. Assets\\n *  are not accounted for until the next epoch for MEV protection.\\n * @author Goldfinch\\n */\\ninterface IMembershipVault is IERC721Upgradeable {\\n  /**\\n   * @notice Emitted when an owner has adjusted their holdings in a vault\\n   * @param owner the owner increasing their holdings\\n   * @param eligibleAmount the new eligible amount\\n   * @param nextEpochAmount the new next epoch amount\\n   */\\n  event AdjustedHoldings(address indexed owner, uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Emitted when the total within the vault has changed\\n   * @param eligibleAmount new current amount\\n   * @param nextEpochAmount new next epoch amount\\n   */\\n  event VaultTotalUpdate(uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Get the current value of `owner`. This changes depending on the current\\n   *  block.timestamp as increased holdings are not accounted for until the subsequent epoch.\\n   * @param owner address owning the positions\\n   * @return sum of all positions held by an address\\n   */\\n  function currentValueOwnedBy(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of block.timestamp\\n   * @return total value in the vault as of block.timestamp\\n   */\\n  function currentTotal() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of epoch\\n   * @return total value in the vault as of epoch\\n   */\\n  function totalAtEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the position owned by `owner`\\n   * @return position owned by `owner`\\n   */\\n  function positionOwnedBy(address owner) external view returns (Position memory);\\n\\n  /**\\n   * @notice Record an adjustment in holdings. Eligible assets will update this epoch and\\n   *  total assets will become eligible the subsequent epoch.\\n   * @param owner the owner to checkpoint\\n   * @param eligibleAmount amount of points to apply to the current epoch\\n   * @param nextEpochAmount amount of points to apply to the next epoch\\n   * @return id of the position\\n   */\\n  function adjustHoldings(\\n    address owner,\\n    uint256 eligibleAmount,\\n    uint256 nextEpochAmount\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Checkpoint a specific owner & the vault total\\n   * @param owner the owner to checkpoint\\n   *\\n   * @dev to collect rewards, this must be called before `increaseHoldings` or\\n   *  `decreaseHoldings`. Those functions must call checkpoint internally\\n   *  so the historical data will be lost otherwise.\\n   */\\n  function checkpoint(address owner) external;\\n}\\n\",\"keccak256\":\"0x5979e109a0a813e0db1de7167625a77f35dab12d184d2eedf1be7ad9706974f7\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolTokens.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./openzeppelin/IERC721.sol\\\";\\n\\ninterface IPoolTokens is IERC721 {\\n  event TokenMinted(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    uint256 tranche\\n  );\\n\\n  event TokenRedeemed(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed,\\n    uint256 tranche\\n  );\\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\\n\\n  struct TokenInfo {\\n    address pool;\\n    uint256 tranche;\\n    uint256 principalAmount;\\n    uint256 principalRedeemed;\\n    uint256 interestRedeemed;\\n  }\\n\\n  struct MintParams {\\n    uint256 principalAmount;\\n    uint256 tranche;\\n  }\\n\\n  function mint(MintParams calldata params, address to) external returns (uint256);\\n\\n  function redeem(\\n    uint256 tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed\\n  ) external;\\n\\n  function withdrawPrincipal(uint256 tokenId, uint256 principalAmount) external;\\n\\n  function burn(uint256 tokenId) external;\\n\\n  function onPoolCreated(address newPool) external;\\n\\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\\n\\n  function validPool(address sender) external view returns (bool);\\n\\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9569823f1e5647f6a627035a341dee918ef58f8b1faefa2a9fd47e75c1f1420f\",\"license\":\"MIT\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title IRouter\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ninterface IRouter {\\n  event SetContract(bytes4 indexed key, address indexed addr);\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) external;\\n}\\n\",\"keccak256\":\"0xe2a04ffb3198fa9de6b8252e1c406eff3dfc0bf7555e2d420bf5e87925fa4d43\",\"license\":\"MIT\"},\"contracts/interfaces/ISeniorPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ITranchedPool.sol\\\";\\n\\nabstract contract ISeniorPool {\\n  uint256 public sharePrice;\\n  uint256 public totalLoansOutstanding;\\n  uint256 public totalWritedowns;\\n\\n  function deposit(uint256 amount) external virtual returns (uint256 depositShares);\\n\\n  function depositWithPermit(\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 depositShares);\\n\\n  function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\\n\\n  function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\\n\\n  function sweepToCompound() public virtual;\\n\\n  function sweepFromCompound() public virtual;\\n\\n  function invest(ITranchedPool pool) public virtual;\\n\\n  function estimateInvestment(ITranchedPool pool) public view virtual returns (uint256);\\n\\n  function redeem(uint256 tokenId) public virtual;\\n\\n  function writedown(uint256 tokenId) public virtual;\\n\\n  function calculateWritedown(uint256 tokenId) public view virtual returns (uint256 writedownAmount);\\n\\n  function assets() public view virtual returns (uint256);\\n\\n  function getNumShares(uint256 amount) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x529b3e34b03c6400e6cd8da7683b6d0daf1c8694dbbff889bd05f1a0b5923e9b\",\"license\":\"MIT\"},\"contracts/interfaces/IStakingRewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC721} from \\\"./openzeppelin/IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"./openzeppelin/IERC721Metadata.sol\\\";\\nimport {IERC721Enumerable} from \\\"./openzeppelin/IERC721Enumerable.sol\\\";\\n\\ninterface IStakingRewards is IERC721, IERC721Metadata, IERC721Enumerable {\\n  function getPosition(uint256 tokenId) external view returns (StakedPosition memory position);\\n\\n  function unstake(uint256 tokenId, uint256 amount) external;\\n\\n  function addToStake(uint256 tokenId, uint256 amount) external;\\n\\n  function stakedBalanceOf(uint256 tokenId) external view returns (uint256);\\n\\n  function depositToCurveAndStakeFrom(\\n    address nftRecipient,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount\\n  ) external;\\n\\n  function kick(uint256 tokenId) external;\\n\\n  function accumulatedRewardsPerToken() external view returns (uint256);\\n\\n  function lastUpdateTime() external view returns (uint256);\\n\\n  /* ========== EVENTS ========== */\\n\\n  event RewardAdded(uint256 reward);\\n  event Staked(\\n    address indexed user,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    StakedPositionType positionType,\\n    uint256 baseTokenExchangeRate\\n  );\\n  event DepositedAndStaked(address indexed user, uint256 depositedAmount, uint256 indexed tokenId, uint256 amount);\\n  event DepositedToCurve(address indexed user, uint256 fiduAmount, uint256 usdcAmount, uint256 tokensReceived);\\n  event DepositedToCurveAndStaked(\\n    address indexed user,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount,\\n    uint256 indexed tokenId,\\n    uint256 amount\\n  );\\n  event Unstaked(address indexed user, uint256 indexed tokenId, uint256 amount, StakedPositionType positionType);\\n  event UnstakedMultiple(address indexed user, uint256[] tokenIds, uint256[] amounts);\\n  event UnstakedAndWithdrew(address indexed user, uint256 usdcReceivedAmount, uint256 indexed tokenId, uint256 amount);\\n  event UnstakedAndWithdrewMultiple(\\n    address indexed user,\\n    uint256 usdcReceivedAmount,\\n    uint256[] tokenIds,\\n    uint256[] amounts\\n  );\\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\\n  event RewardsParametersUpdated(\\n    address indexed who,\\n    uint256 targetCapacity,\\n    uint256 minRate,\\n    uint256 maxRate,\\n    uint256 minRateAtPercent,\\n    uint256 maxRateAtPercent\\n  );\\n  event EffectiveMultiplierUpdated(address indexed who, StakedPositionType positionType, uint256 multiplier);\\n}\\n\\n/// @notice Indicates which ERC20 is staked\\nenum StakedPositionType {\\n  Fidu,\\n  CurveLP\\n}\\n\\nstruct Rewards {\\n  uint256 totalUnvested;\\n  uint256 totalVested;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this was used in the case of slashing.\\n  //   For non-vesting positions, this is unused.\\n  uint256 totalPreviouslyVested;\\n  uint256 totalClaimed;\\n  uint256 startTime;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this is the endTime of the vesting.\\n  //   For non-vesting positions, this is 0.\\n  uint256 endTime;\\n}\\n\\nstruct StakedPosition {\\n  // @notice Staked amount denominated in `stakingToken().decimals()`\\n  uint256 amount;\\n  // @notice Struct describing rewards owed with vesting\\n  Rewards rewards;\\n  // @notice Multiplier applied to staked amount when locking up position\\n  uint256 leverageMultiplier;\\n  // @notice Time in seconds after which position can be unstaked\\n  uint256 lockedUntil;\\n  // @notice Type of the staked position\\n  StakedPositionType positionType;\\n  // @notice Multiplier applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeEffectiveMultiplier()`, which correctly handles old staked positions.\\n  uint256 unsafeEffectiveMultiplier;\\n  // @notice Exchange rate applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeBaseTokenExchangeRate()`, which correctly handles old staked positions.\\n  uint256 unsafeBaseTokenExchangeRate;\\n}\\n\",\"keccak256\":\"0xb001875f3e7a6414f8e72cf25afdd30cd949fd2b0a219a4778b8027ef1d26667\",\"license\":\"MIT\"},\"contracts/interfaces/ITranchedPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {IV2CreditLine} from \\\"./IV2CreditLine.sol\\\";\\n\\nabstract contract ITranchedPool {\\n  IV2CreditLine public creditLine;\\n  uint256 public createdAt;\\n  enum Tranches {\\n    Reserved,\\n    Senior,\\n    Junior\\n  }\\n\\n  struct TrancheInfo {\\n    uint256 id;\\n    uint256 principalDeposited;\\n    uint256 principalSharePrice;\\n    uint256 interestSharePrice;\\n    uint256 lockedUntil;\\n  }\\n\\n  struct PoolSlice {\\n    TrancheInfo seniorTranche;\\n    TrancheInfo juniorTranche;\\n    uint256 totalInterestAccrued;\\n    uint256 principalDeployed;\\n  }\\n\\n  function initialize(\\n    address _config,\\n    address _borrower,\\n    uint256 _juniorFeePercent,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays,\\n    uint256 _fundableAt,\\n    uint256[] calldata _allowedUIDTypes\\n  ) public virtual;\\n\\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\\n\\n  function pay(uint256 amount) external virtual;\\n\\n  function poolSlices(uint256 index) external view virtual returns (PoolSlice memory);\\n\\n  function lockJuniorCapital() external virtual;\\n\\n  function lockPool() external virtual;\\n\\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\\n\\n  function totalJuniorDeposits() external view virtual returns (uint256);\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function setFundableAt(uint256 timestamp) external virtual;\\n\\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\\n\\n  function assess() external virtual;\\n\\n  function depositWithPermit(\\n    uint256 tranche,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 tokenId);\\n\\n  function availableToWithdraw(uint256 tokenId)\\n    external\\n    view\\n    virtual\\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\\n\\n  function withdraw(uint256 tokenId, uint256 amount)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMax(uint256 tokenId)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\\n\\n  function numSlices() external view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x7a21d304a7ba635f4a074488d152c62c6b8b442cc5a5ad85a454621f4baec659\",\"license\":\"MIT\"},\"contracts/interfaces/IV2CreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ICreditLine.sol\\\";\\n\\nabstract contract IV2CreditLine is ICreditLine {\\n  function principal() external view virtual returns (uint256);\\n\\n  function totalInterestAccrued() external view virtual returns (uint256);\\n\\n  function termStartTime() external view virtual returns (uint256);\\n\\n  function setLimit(uint256 newAmount) external virtual;\\n\\n  function setMaxLimit(uint256 newAmount) external virtual;\\n\\n  function setBalance(uint256 newBalance) external virtual;\\n\\n  function setPrincipal(uint256 _principal) external virtual;\\n\\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function assess()\\n    external\\n    virtual\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function initialize(\\n    address _config,\\n    address owner,\\n    address _borrower,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays\\n  ) public virtual;\\n\\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\\n\\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\\n\\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\\n\\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\\n\\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\\n\\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\\n\\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\\n\\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\\n}\\n\",\"keccak256\":\"0xc72be7462ade69ec2d4bb18344cfe1c8b4659bd68314cef013aa5616bfe8f607\",\"license\":\"MIT\"},\"contracts/interfaces/openzeppelin/IERC165.sol\":{\"content\":\"pragma solidity >=0.6.0;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbbdb8f6dfaecd47a0d65bee707877d6974a0e0da6c02403ad5ce00590bd97497\"},\"contracts/interfaces/openzeppelin/IERC721.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >= & reference other >= pragma interfaces.\\n// NOTE: Modified to reference our updated pragma version of IERC165\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of NFTs in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the NFT specified by `tokenId`.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   *\\n   *\\n   * Requirements:\\n   * - `from`, `to` cannot be zero.\\n   * - `tokenId` must be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this\\n   * NFT by either {approve} or {setApprovalForAll}.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Requirements:\\n   * - If the caller is not `from`, it must be approved to move this NFT by\\n   * either {approve} or {setApprovalForAll}.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  function approve(address to, uint256 tokenId) external;\\n\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x2527635bd6ab0d348f5f7d325ef2241a544586bb85dd806053adf1cc409293e5\"},\"contracts/interfaces/openzeppelin/IERC721Enumerable.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x7fd709ba4093899fc4593cb1413132e127773a349a8aef9ce234d62fa36b5fca\"},\"contracts/interfaces/openzeppelin/IERC721Metadata.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x56c56c47d03d0ea452a13842ad2e3e5b81b3689c484efd35a48f3977e9b929d8\"},\"contracts/protocol/core/membership/ERC20Splitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"openzeppelin-contracts/contracts/utils/Address.sol\\\";\\n\\nimport {Context} from \\\"../../../cake/Context.sol\\\";\\nimport {Base} from \\\"../../../cake/Base.sol\\\";\\nimport {PausableUpgradeable} from \\\"../../../cake/Pausable.sol\\\";\\nimport {IERC20Splitter} from \\\"../../../interfaces/IERC20Splitter.sol\\\";\\n\\nusing Address for address;\\nusing SafeERC20 for IERC20;\\n\\ninterface IERC20SplitterReceiver {\\n  function onReceive(uint256 amount) external returns (bytes4 retval);\\n}\\n\\n/// @title ERC20Splitter\\n/// @author landakram\\n/// @notice Splits the ERC20 balance of this contract amongst a list of payees.\\n///   Unlike similar splitter contracts, all shares of the balance are distributed\\n///   in a single `distribute` transaction. If a payee is a smart contract implementing\\n///   `IERC20SplitterReceiver`, then its `onReceive` handler function will be called\\n///   after it receives its share.\\ncontract ERC20Splitter is IERC20Splitter, Base, PausableUpgradeable {\\n  error LengthMismatch();\\n  error InvalidReceiver();\\n  error IntraBlockDistribution();\\n\\n  event Distributed(uint256 total);\\n  event PayeeAdded(address indexed payee, uint256 share);\\n\\n  /// @notice The total number of shares in the splitter. A payee's proportion\\n  ///   of the split can be calculated as its share / totalShares.\\n  uint256 public totalShares;\\n\\n  /// @notice A list of payees\\n  address[] public payees;\\n\\n  /// @notice Payee shares\\n  mapping(address => uint256) public shares;\\n\\n  /// @notice The ERC20 that is distributed to payees\\n  IERC20 public immutable erc20;\\n\\n  /// @notice The block.timestamp when `distribute` was last called\\n  uint256 public lastDistributionAt;\\n\\n  constructor(Context _context, IERC20 _erc20) Base(_context) {\\n    erc20 = _erc20;\\n  }\\n\\n  function initialize() external initializer {\\n    __Pausable_init_unchained();\\n  }\\n\\n  function pendingDistributionFor(address payee) external view returns (uint256) {\\n    return (erc20.balanceOf(address(this)) * shares[payee]) / totalShares;\\n  }\\n\\n  /// @notice Distribute the current balance to payees. If a payee is a smart contract\\n  ///   implementing `IERC20SplitterReceiver`, then its `onReceive` handler function will\\n  ///   be called after it receives its share.\\n  function distribute() external whenNotPaused {\\n    if (lastDistributionAt == block.timestamp) revert IntraBlockDistribution();\\n\\n    lastDistributionAt = block.timestamp;\\n\\n    uint256 totalToDistribute = erc20.balanceOf(address(this));\\n\\n    for (uint256 i = 0; i < payees.length; i++) {\\n      address payee = payees[i];\\n      uint256 share = shares[payee];\\n\\n      // Due to integer division, this could result in some dust being left over in the\\n      // contract. This is acceptable as the dust will be included in the next distribution.\\n      uint256 owedToPayee = (totalToDistribute * share) / totalShares;\\n      if (owedToPayee > 0) {\\n        erc20.safeTransfer(payee, owedToPayee);\\n      }\\n\\n      if (payee.isContract()) {\\n        // Call this even if there is nothing owed to payee. Some recipients may still need\\n        // to account for the event.\\n        triggerOnReceive(payee, owedToPayee);\\n      }\\n    }\\n\\n    emit Distributed(totalToDistribute);\\n  }\\n\\n  function triggerOnReceive(address payee, uint256 amount) internal {\\n    try IERC20SplitterReceiver(payee).onReceive(amount) returns (bytes4 retval) {\\n      if (retval != IERC20SplitterReceiver.onReceive.selector) revert InvalidReceiver();\\n    } catch (bytes memory reason) {\\n      // A zero-length reason means the payee does not implement IERC20SplitterReceiver.\\n      // In that case, just continue.\\n      if (reason.length > 0) {\\n        assembly {\\n          revert(add(32, reason), mload(reason))\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Replace all current payees with a new set of payees and shares\\n  /// @param _payees An array of addresses to receive distributions\\n  /// @param _shares An array of shares (ordered by `_payees`) to use for distributions\\n  function replacePayees(address[] calldata _payees, uint256[] calldata _shares) external onlyAdmin {\\n    delete payees;\\n    _setUpPayees(_payees, _shares);\\n  }\\n\\n  function _setUpPayees(address[] calldata _payees, uint256[] calldata _shares) internal {\\n    if (_payees.length != _shares.length) revert LengthMismatch();\\n\\n    totalShares = 0;\\n    payees = _payees;\\n\\n    for (uint256 i = 0; i < _shares.length; i++) {\\n      address payee = _payees[i];\\n      uint256 share = _shares[i];\\n      shares[payee] = share;\\n      totalShares += share;\\n      emit PayeeAdded({payee: payee, share: share});\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xc4005057cb0801371d6cd4a25bf860417b26f1849b844000b99c6ab04fcf372c\",\"license\":\"MIT\"},\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"openzeppelin-contracts/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238\",\"license\":\"MIT\"},\"openzeppelin-contracts/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60c060405234801561001057600080fd5b5060405161137738038061137783398101604081905261002f9161005e565b6001600160a01b039182166080521660a052610098565b6001600160a01b038116811461005b57600080fd5b50565b6000806040838503121561007157600080fd5b825161007c81610046565b602084015190925061008d81610046565b809150509250929050565b60805160a05161129e6100d960003960008181610140015281816102810152818161049801526105870152600081816101a80152610b3a015261129e6000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c8063785e9e8611610071578063785e9e861461013b5780638129fc1c146101625780638456cb591461016a5780639035508714610172578063ce7c2ac21461017b578063e4fc6b6d1461019b57600080fd5b8063259e97d6146100b95780633a98ef39146100ce5780633cae0ecc146100ea5780633f4ba83a146100fd5780635c975abb1461010557806363037b0c1461011b575b600080fd5b6100cc6100c7366004610f7b565b6101a3565b005b6100d760655481565b6040519081526020015b60405180910390f35b6100d76100f8366004610ffc565b610254565b6100cc610326565b60335460ff1660405190151581526020016100e1565b61012e610129366004611020565b61035c565b6040516100e19190611039565b61012e7f000000000000000000000000000000000000000000000000000000000000000081565b6100cc610386565b6100cc610402565b6100d760685481565b6100d7610189366004610ffc565b60676020526000908152604090205481565b6100cc610435565b6101d57f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610615565b604051632a6e138b60e11b81523060048201523360248201526001600160a01b0391909116906354dc27169060440160006040518083038186803b15801561021c57600080fd5b505afa158015610230573d6000803e3d6000fd5b50505050606660006102429190610e99565b61024e84848484610705565b50505050565b600060655460676000846001600160a01b03166001600160a01b03168152602001908152602001600020547f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016102cb9190611039565b602060405180830381865afa1580156102e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030c919061104d565b610316919061107c565b610320919061109b565b92915050565b6040805180820190915263580b2a9160e01b8152633828b3cf60e21b60208201526103518133610828565b6103596108a9565b50565b6066818154811061036c57600080fd5b6000918252602090912001546001600160a01b0316905081565b600054610100900460ff168061039f575060005460ff16155b6103c45760405162461bcd60e51b81526004016103bb906110bd565b60405180910390fd5b600054610100900460ff161580156103e6576000805461ffff19166101011790555b6103ee610936565b8015610359576000805461ff001916905550565b6040805180820190915263580b2a9160e01b8152633828b3cf60e21b602082015261042d8133610828565b6103596109ab565b60335460ff16156104585760405162461bcd60e51b81526004016103bb9061110b565b426068540361047a5760405163bdb009db60e01b815260040160405180910390fd5b426068556040516370a0823160e01b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a08231906104cd903090600401611039565b602060405180830381865afa1580156104ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050e919061104d565b905060005b6066548110156105de5760006066828154811061053257610532611135565b60009182526020808320909101546001600160a01b0316808352606790915260408220546065549193509190610568838761107c565b610572919061109b565b905080156105ae576105ae6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168483610a03565b6001600160a01b0383163b156105c8576105c88382610a55565b50505080806105d69061114b565b915050610513565b506040518181527fddc9c30275a04c48091f24199f9c405765de34d979d6847f5b9798a57232d2e59060200160405180910390a150565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610655573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106799190611164565b6001600160a01b0316630c0450127f9a671f6643eb8ac838fd3c79576dd800fe704b35ad30189c60f0f14dab948f2a6040518263ffffffff1660e01b81526004016106c49190611181565b602060405180830381865afa1580156106e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103209190611164565b828114610728576040516001621398b960e31b0319815260040160405180910390fd5b600060655561073960668585610eb7565b5060005b8181101561082157600085858381811061075957610759611135565b905060200201602081019061076e9190610ffc565b9050600084848481811061078457610784611135565b9050602002013590508060676000846001600160a01b03166001600160a01b031681526020019081526020016000208190555080606560008282546107c99190611196565b90915550506040518181526001600160a01b038316907f40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac9060200160405180910390a2505080806108199061114b565b91505061073d565b5050505050565b6001600160a01b03811661084f5760405163d92e233d60e01b815260040160405180910390fd5b600061086283825b602002015183610b2c565b806108735750610873836001610857565b9050806108a45760405163889a56bb60e01b81523060048201526001600160a01b03831660248201526044016103bb565b505050565b60335460ff166108f25760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016103bb565b6033805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b60405161092c9190611039565b60405180910390a1565b600054610100900460ff168061094f575060005460ff16155b61096b5760405162461bcd60e51b81526004016103bb906110bd565b600054610100900460ff1615801561098d576000805461ffff19166101011790555b6033805460ff191690558015610359576000805461ff001916905550565b60335460ff16156109ce5760405162461bcd60e51b81526004016103bb9061110b565b6033805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25861091f3390565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526108a4908490610c37565b604051637b35092760e11b8152600481018290526001600160a01b0383169063f66a124e906024016020604051808303816000875af1925050508015610ab8575060408051601f3d908101601f19168201909252610ab5918101906111a9565b60015b610afb573d808015610ae6576040519150601f19603f3d011682016040523d82523d6000602084013e610aeb565b606091505b508051156108a457805181602001fd5b6001600160e01b03198116637b35092760e11b146108a457604051631e4ec46b60e01b815260040160405180910390fd5b6000816001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b96573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bba9190611164565b6001600160a01b0316630c045012856040518263ffffffff1660e01b8152600401610be59190611181565b602060405180830381865afa158015610c02573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c269190611164565b6001600160a01b0316149392505050565b6000610c8c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316610d099092919063ffffffff16565b8051909150156108a45780806020019051810190610caa91906111d3565b6108a45760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016103bb565b6060610d188484600085610d20565b949350505050565b606082471015610d815760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016103bb565b600080866001600160a01b03168587604051610d9d9190611219565b60006040518083038185875af1925050503d8060008114610dda576040519150601f19603f3d011682016040523d82523d6000602084013e610ddf565b606091505b5091509150610df087838387610dfb565b979650505050505050565b60608315610e6a578251600003610e63576001600160a01b0385163b610e635760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103bb565b5081610d18565b610d188383815115610e7f5781518083602001fd5b8060405162461bcd60e51b81526004016103bb9190611235565b50805460008255906000526020600020908101906103599190610f1a565b828054828255906000526020600020908101928215610f0a579160200282015b82811115610f0a5781546001600160a01b0319166001600160a01b03843516178255602090920191600190910190610ed7565b50610f16929150610f1a565b5090565b5b80821115610f165760008155600101610f1b565b60008083601f840112610f4157600080fd5b50813567ffffffffffffffff811115610f5957600080fd5b6020830191508360208260051b8501011115610f7457600080fd5b9250929050565b60008060008060408587031215610f9157600080fd5b843567ffffffffffffffff80821115610fa957600080fd5b610fb588838901610f2f565b90965094506020870135915080821115610fce57600080fd5b50610fdb87828801610f2f565b95989497509550505050565b6001600160a01b038116811461035957600080fd5b60006020828403121561100e57600080fd5b813561101981610fe7565b9392505050565b60006020828403121561103257600080fd5b5035919050565b6001600160a01b0391909116815260200190565b60006020828403121561105f57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161561109657611096611066565b500290565b6000826110b857634e487b7160e01b600052601260045260246000fd5b500490565b6020808252602e908201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160408201526d191e481a5b9a5d1a585b1a5e995960921b606082015260800190565b60208082526010908201526f14185d5cd8589b194e881c185d5cd95960821b604082015260600190565b634e487b7160e01b600052603260045260246000fd5b60006001820161115d5761115d611066565b5060010190565b60006020828403121561117657600080fd5b815161101981610fe7565b6001600160e01b031991909116815260200190565b8082018082111561032057610320611066565b6000602082840312156111bb57600080fd5b81516001600160e01b03198116811461101957600080fd5b6000602082840312156111e557600080fd5b8151801515811461101957600080fd5b60005b838110156112105781810151838201526020016111f8565b50506000910152565b6000825161122b8184602087016111f5565b9190910192915050565b60208152600082518060208401526112548160408501602087016111f5565b601f01601f1916919091016040019291505056fea26469706673582212200e401bbd376b5ec13015cb96f9a192fc31e62b242172f343971345a682805cf164736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100b45760003560e01c8063785e9e8611610071578063785e9e861461013b5780638129fc1c146101625780638456cb591461016a5780639035508714610172578063ce7c2ac21461017b578063e4fc6b6d1461019b57600080fd5b8063259e97d6146100b95780633a98ef39146100ce5780633cae0ecc146100ea5780633f4ba83a146100fd5780635c975abb1461010557806363037b0c1461011b575b600080fd5b6100cc6100c7366004610f7b565b6101a3565b005b6100d760655481565b6040519081526020015b60405180910390f35b6100d76100f8366004610ffc565b610254565b6100cc610326565b60335460ff1660405190151581526020016100e1565b61012e610129366004611020565b61035c565b6040516100e19190611039565b61012e7f000000000000000000000000000000000000000000000000000000000000000081565b6100cc610386565b6100cc610402565b6100d760685481565b6100d7610189366004610ffc565b60676020526000908152604090205481565b6100cc610435565b6101d57f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610615565b604051632a6e138b60e11b81523060048201523360248201526001600160a01b0391909116906354dc27169060440160006040518083038186803b15801561021c57600080fd5b505afa158015610230573d6000803e3d6000fd5b50505050606660006102429190610e99565b61024e84848484610705565b50505050565b600060655460676000846001600160a01b03166001600160a01b03168152602001908152602001600020547f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016102cb9190611039565b602060405180830381865afa1580156102e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061030c919061104d565b610316919061107c565b610320919061109b565b92915050565b6040805180820190915263580b2a9160e01b8152633828b3cf60e21b60208201526103518133610828565b6103596108a9565b50565b6066818154811061036c57600080fd5b6000918252602090912001546001600160a01b0316905081565b600054610100900460ff168061039f575060005460ff16155b6103c45760405162461bcd60e51b81526004016103bb906110bd565b60405180910390fd5b600054610100900460ff161580156103e6576000805461ffff19166101011790555b6103ee610936565b8015610359576000805461ff001916905550565b6040805180820190915263580b2a9160e01b8152633828b3cf60e21b602082015261042d8133610828565b6103596109ab565b60335460ff16156104585760405162461bcd60e51b81526004016103bb9061110b565b426068540361047a5760405163bdb009db60e01b815260040160405180910390fd5b426068556040516370a0823160e01b81526000906001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906370a08231906104cd903090600401611039565b602060405180830381865afa1580156104ea573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050e919061104d565b905060005b6066548110156105de5760006066828154811061053257610532611135565b60009182526020808320909101546001600160a01b0316808352606790915260408220546065549193509190610568838761107c565b610572919061109b565b905080156105ae576105ae6001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000168483610a03565b6001600160a01b0383163b156105c8576105c88382610a55565b50505080806105d69061114b565b915050610513565b506040518181527fddc9c30275a04c48091f24199f9c405765de34d979d6847f5b9798a57232d2e59060200160405180910390a150565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610655573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106799190611164565b6001600160a01b0316630c0450127f9a671f6643eb8ac838fd3c79576dd800fe704b35ad30189c60f0f14dab948f2a6040518263ffffffff1660e01b81526004016106c49190611181565b602060405180830381865afa1580156106e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103209190611164565b828114610728576040516001621398b960e31b0319815260040160405180910390fd5b600060655561073960668585610eb7565b5060005b8181101561082157600085858381811061075957610759611135565b905060200201602081019061076e9190610ffc565b9050600084848481811061078457610784611135565b9050602002013590508060676000846001600160a01b03166001600160a01b031681526020019081526020016000208190555080606560008282546107c99190611196565b90915550506040518181526001600160a01b038316907f40c340f65e17194d14ddddb073d3c9f888e3cb52b5aae0c6c7706b4fbc905fac9060200160405180910390a2505080806108199061114b565b91505061073d565b5050505050565b6001600160a01b03811661084f5760405163d92e233d60e01b815260040160405180910390fd5b600061086283825b602002015183610b2c565b806108735750610873836001610857565b9050806108a45760405163889a56bb60e01b81523060048201526001600160a01b03831660248201526044016103bb565b505050565b60335460ff166108f25760405162461bcd60e51b815260206004820152601460248201527314185d5cd8589b194e881b9bdd081c185d5cd95960621b60448201526064016103bb565b6033805460ff191690557f5db9ee0a495bf2e6ff9c91a7834c1ba4fdd244a5e8aa4e537bd38aeae4b073aa335b60405161092c9190611039565b60405180910390a1565b600054610100900460ff168061094f575060005460ff16155b61096b5760405162461bcd60e51b81526004016103bb906110bd565b600054610100900460ff1615801561098d576000805461ffff19166101011790555b6033805460ff191690558015610359576000805461ff001916905550565b60335460ff16156109ce5760405162461bcd60e51b81526004016103bb9061110b565b6033805460ff191660011790557f62e78cea01bee320cd4e420270b5ea74000d11b0c9f74754ebdbfc544b05a25861091f3390565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526108a4908490610c37565b604051637b35092760e11b8152600481018290526001600160a01b0383169063f66a124e906024016020604051808303816000875af1925050508015610ab8575060408051601f3d908101601f19168201909252610ab5918101906111a9565b60015b610afb573d808015610ae6576040519150601f19603f3d011682016040523d82523d6000602084013e610aeb565b606091505b508051156108a457805181602001fd5b6001600160e01b03198116637b35092760e11b146108a457604051631e4ec46b60e01b815260040160405180910390fd5b6000816001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b96573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bba9190611164565b6001600160a01b0316630c045012856040518263ffffffff1660e01b8152600401610be59190611181565b602060405180830381865afa158015610c02573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c269190611164565b6001600160a01b0316149392505050565b6000610c8c826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316610d099092919063ffffffff16565b8051909150156108a45780806020019051810190610caa91906111d3565b6108a45760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016103bb565b6060610d188484600085610d20565b949350505050565b606082471015610d815760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016103bb565b600080866001600160a01b03168587604051610d9d9190611219565b60006040518083038185875af1925050503d8060008114610dda576040519150601f19603f3d011682016040523d82523d6000602084013e610ddf565b606091505b5091509150610df087838387610dfb565b979650505050505050565b60608315610e6a578251600003610e63576001600160a01b0385163b610e635760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103bb565b5081610d18565b610d188383815115610e7f5781518083602001fd5b8060405162461bcd60e51b81526004016103bb9190611235565b50805460008255906000526020600020908101906103599190610f1a565b828054828255906000526020600020908101928215610f0a579160200282015b82811115610f0a5781546001600160a01b0319166001600160a01b03843516178255602090920191600190910190610ed7565b50610f16929150610f1a565b5090565b5b80821115610f165760008155600101610f1b565b60008083601f840112610f4157600080fd5b50813567ffffffffffffffff811115610f5957600080fd5b6020830191508360208260051b8501011115610f7457600080fd5b9250929050565b60008060008060408587031215610f9157600080fd5b843567ffffffffffffffff80821115610fa957600080fd5b610fb588838901610f2f565b90965094506020870135915080821115610fce57600080fd5b50610fdb87828801610f2f565b95989497509550505050565b6001600160a01b038116811461035957600080fd5b60006020828403121561100e57600080fd5b813561101981610fe7565b9392505050565b60006020828403121561103257600080fd5b5035919050565b6001600160a01b0391909116815260200190565b60006020828403121561105f57600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b600081600019048311821515161561109657611096611066565b500290565b6000826110b857634e487b7160e01b600052601260045260246000fd5b500490565b6020808252602e908201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160408201526d191e481a5b9a5d1a585b1a5e995960921b606082015260800190565b60208082526010908201526f14185d5cd8589b194e881c185d5cd95960821b604082015260600190565b634e487b7160e01b600052603260045260246000fd5b60006001820161115d5761115d611066565b5060010190565b60006020828403121561117657600080fd5b815161101981610fe7565b6001600160e01b031991909116815260200190565b8082018082111561032057610320611066565b6000602082840312156111bb57600080fd5b81516001600160e01b03198116811461101957600080fd5b6000602082840312156111e557600080fd5b8151801515811461101957600080fd5b60005b838110156112105781810151838201526020016111f8565b50506000910152565b6000825161122b8184602087016111f5565b9190910192915050565b60208152600082518060208401526112548160408501602087016111f5565b601f01601f1916919091016040019291505056fea26469706673582212200e401bbd376b5ec13015cb96f9a192fc31e62b242172f343971345a682805cf164736f6c63430008100033",
  "devdoc": {
    "author": "landakram",
    "kind": "dev",
    "methods": {
      "paused()": {
        "details": "Returns true if the contract is paused, and false otherwise."
      },
      "replacePayees(address[],uint256[])": {
        "params": {
          "_payees": "An array of addresses to receive distributions",
          "_shares": "An array of shares (ordered by `_payees`) to use for distributions"
        }
      }
    },
    "title": "ERC20Splitter",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "distribute()": {
        "notice": "Distribute the current balance to payees. If a payee is a smart contract   implementing `IERC20SplitterReceiver`, then its `onReceive` handler function will   be called after it receives its share."
      },
      "erc20()": {
        "notice": "The ERC20 that is distributed to payees"
      },
      "lastDistributionAt()": {
        "notice": "The block.timestamp when `distribute` was last called"
      },
      "payees(uint256)": {
        "notice": "A list of payees"
      },
      "replacePayees(address[],uint256[])": {
        "notice": "Replace all current payees with a new set of payees and shares"
      },
      "shares(address)": {
        "notice": "Payee shares"
      },
      "totalShares()": {
        "notice": "The total number of shares in the splitter. A payee's proportion   of the split can be calculated as its share / totalShares."
      }
    },
    "notice": "Splits the ERC20 balance of this contract amongst a list of payees.   Unlike similar splitter contracts, all shares of the balance are distributed   in a single `distribute` transaction. If a payee is a smart contract implementing   `IERC20SplitterReceiver`, then its `onReceive` handler function will be called   after it receives its share.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 663,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 666,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 3021,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "__gap",
        "offset": 0,
        "slot": "1",
        "type": "t_array(t_uint256)50_storage"
      },
      {
        "astId": 724,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "_paused",
        "offset": 0,
        "slot": "51",
        "type": "t_bool"
      },
      {
        "astId": 815,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "__gap",
        "offset": 0,
        "slot": "52",
        "type": "t_array(t_uint256)49_storage"
      },
      {
        "astId": 9786,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "totalShares",
        "offset": 0,
        "slot": "101",
        "type": "t_uint256"
      },
      {
        "astId": 9790,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "payees",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_address)dyn_storage"
      },
      {
        "astId": 9795,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "shares",
        "offset": 0,
        "slot": "103",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 9802,
        "contract": "contracts/protocol/core/membership/ERC20Splitter.sol:ERC20Splitter",
        "label": "lastDistributionAt",
        "offset": 0,
        "slot": "104",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_address)dyn_storage": {
        "base": "t_address",
        "encoding": "dynamic_array",
        "label": "address[]",
        "numberOfBytes": "32"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)50_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[50]",
        "numberOfBytes": "1600"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}