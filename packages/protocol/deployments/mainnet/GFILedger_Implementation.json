{
  "address": "0x8d0C4E704be667E4320B81F6dD35adDAd3C135E0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract Context",
          "name": "_context",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "IndexGreaterThanTokenSupply",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "epoch",
          "type": "uint256"
        }
      ],
      "name": "InvalidDepositEpoch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidOwnerIndex",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "requested",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "max",
          "type": "uint256"
        }
      ],
      "name": "InvalidWithdrawAmount",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "resource",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "accessor",
          "type": "address"
        }
      ],
      "name": "RequiresOperator",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroDepositAmount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "GFIDeposit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "withdrawnAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "remainingAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "depositTimestamp",
          "type": "uint256"
        }
      ],
      "name": "GFIWithdrawal",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "deposit",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "ownerOf",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "positions",
      "outputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "ownedIndex",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "depositTimestamp",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "owner",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "tokenOfOwnerByIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "addr",
          "type": "address"
        }
      ],
      "name": "totalsOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "eligibleAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "totalAmount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "positionId",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdraw",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x18fbf4e65aebe87982b8077a8586d7e086fad81231a878b0cdb3b153ded5aab5",
  "receipt": {
    "to": null,
    "from": "0x2Fbf774ec12Bd86a60E563F0653AEee4DEbA0DB8",
    "contractAddress": "0x8d0C4E704be667E4320B81F6dD35adDAd3C135E0",
    "transactionIndex": 27,
    "gasUsed": "1066089",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb1116c1f6ab2ae99d49205e412ec4808edeb88829761bea529b2ee7ba08a75a4",
    "transactionHash": "0x18fbf4e65aebe87982b8077a8586d7e086fad81231a878b0cdb3b153ded5aab5",
    "logs": [],
    "blockNumber": 15992883,
    "cumulativeGasUsed": "3835590",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xd16BC944Bf20c86c4ED47Ce1a330a18538674C83"
  ],
  "solcInputHash": "eac65dc40e06b4b044f441f03029567a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.16+commit.07a7930e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract Context\",\"name\":\"_context\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IndexGreaterThanTokenSupply\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"InvalidDepositEpoch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOwnerIndex\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"InvalidWithdrawAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"resource\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"accessor\",\"type\":\"address\"}],\"name\":\"RequiresOperator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroDepositAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"GFIDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"remainingAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositTimestamp\",\"type\":\"uint256\"}],\"name\":\"GFIWithdrawal\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"positions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ownedIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"totalsOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"eligibleAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"positionId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Goldfinch\",\"kind\":\"dev\",\"methods\":{\"balanceOf(address)\":{\"params\":{\"addr\":\"address\"},\"returns\":{\"balance\":\"positions held by address\"}},\"deposit(address,uint256)\":{\"params\":{\"amount\":\"how much was deposited\",\"owner\":\"address to account for the deposit\"},\"returns\":{\"positionId\":\"how much was deposited\"}},\"ownerOf(uint256)\":{\"params\":{\"positionId\":\"id of the position\"},\"returns\":{\"_0\":\"owner of the position\"}},\"tokenByIndex(uint256)\":{\"details\":\"Returns a position ID at a given `index` of all the positions stored by the contract.use with {totalSupply} to enumerate all positions\",\"params\":{\"index\":\"index to get the position ID at\"},\"returns\":{\"_0\":\"token id\"}},\"tokenOfOwnerByIndex(address,uint256)\":{\"details\":\"use with {balanceOf} to enumerate all of `owner`'s positions\",\"params\":{\"index\":\"index of the owner's balance to get the position ID of\",\"owner\":\"owner of the positions\"},\"returns\":{\"_0\":\"position id\"}},\"totalSupply()\":{\"returns\":{\"_0\":\"number of positions in the ledger\"}},\"totalsOf(address)\":{\"details\":\"this is used by Membership to determine how much is eligible in  the current epoch vs the next epoch.\",\"returns\":{\"eligibleAmount\":\"GFI amount of positions eligible for rewards\",\"totalAmount\":\"total GFI amount of positions\"}},\"withdraw(uint256)\":{\"params\":{\"positionId\":\"id of the position\"},\"returns\":{\"_0\":\"how much was withdrawn\"}},\"withdraw(uint256,uint256)\":{\"params\":{\"amount\":\"how much to withdraw\",\"positionId\":\"id of the position\"},\"returns\":{\"_0\":\"how much was withdrawn\"}}},\"title\":\"GFILedger\",\"version\":1},\"userdoc\":{\"errors\":{\"IndexGreaterThanTokenSupply()\":[{\"notice\":\"Thrown when querying token supply with an index greater than the supply\"}],\"InvalidOwnerIndex()\":[{\"notice\":\"Thrown when depositing from address(0)\"}],\"InvalidWithdrawAmount(uint256,uint256)\":[{\"notice\":\"Thrown when withdrawing an invalid amount for a position\"}],\"ZeroDepositAmount()\":[{\"notice\":\"Thrown when depositing zero GFI for a position\"}]},\"events\":{\"GFIDeposit(address,uint256,uint256)\":{\"notice\":\"Emitted when a new GFI deposit has been made\"},\"GFIWithdrawal(address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Emitted when a new GFI withdrawal has been made. If the remaining amount is 0, the position has bee removed\"}},\"kind\":\"user\",\"methods\":{\"balanceOf(address)\":{\"notice\":\"Get the number of GFI positions held by an address\"},\"constructor\":{\"notice\":\"Construct the contract\"},\"deposit(address,uint256)\":{\"notice\":\"Account for a new deposit by the owner.\"},\"ownerOf(uint256)\":{\"notice\":\"Get the owner of a given position.\"},\"tokenOfOwnerByIndex(address,uint256)\":{\"notice\":\"Returns a position ID owned by `owner` at a given `index` of its position list\"},\"totalSupply()\":{\"notice\":\"Total number of positions in the ledger\"},\"totalsOf(address)\":{\"notice\":\"Get amount of GFI of `owner`s positions, reporting what is currently  eligible and the total amount.\"},\"withdraw(uint256)\":{\"notice\":\"Account for a new withdraw by the owner.\"},\"withdraw(uint256,uint256)\":{\"notice\":\"Account for a new withdraw by the owner.\"}},\"notice\":\"Track GFI held by owners and ensure the GFI has been accounted for.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/protocol/core/membership/GFILedger.sol\":\"GFILedger\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC20/IERC20Upgradeable.sol\\\";\\n\",\"keccak256\":\"0xe6220d2b5a54ac7497313ce4503cca742b09dc5e3a4eb76fb0afff85b1b97a34\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721Upgradeable.sol\\\";\\n\",\"keccak256\":\"0x28c8a2c5850343f4fb44847b736df5a89fb16c90971c8c06c8066c04ad9b70df\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        require(_initializing || !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8b2abd85d0ece7e866e100e9d47ca9cbec93c87cf71a8d267b2b93eb81f7d5e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf449ca0a763d4b1b4462cf8706857074492f324020a2b9d099181b5383055ad3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xc7d7fe7d5ed5068742927e37b400591153dbe8526cd942cfcf5dbb971ba5e8e2\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0xfbb3ca7272af58dc245a20e91a1f68481ee04706fa3fe46d184000efc21f4bad\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x946f08c0a132c5877d458d7af7956da60607f20a5c03dd75760708c848aae6b7\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x1c4860acd323e34a67b3e97faab9aaa55fe8e92b1dcf08b5f47f3468d58ce75c\",\"license\":\"MIT\"},\"contracts/cake/AccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/IAccessControl.sol\\\";\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ncontract AccessControl is Initializable, IAccessControl {\\n  /// @dev Mapping from contract address to contract admin;\\n  mapping(address => address) public admins;\\n\\n  function initialize(address admin) public initializer {\\n    admins[address(this)] = admin;\\n    emit AdminSet(address(this), admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function setAdmin(address resource, address admin) external {\\n    requireSuperAdmin(msg.sender);\\n    admins[resource] = admin;\\n    emit AdminSet(resource, admin);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireAdmin(address resource, address accessor) public view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n    bool isAdmin = admins[resource] == accessor;\\n    if (!isAdmin) revert RequiresAdmin(resource, accessor);\\n  }\\n\\n  /// @inheritdoc IAccessControl\\n  function requireSuperAdmin(address accessor) public view {\\n    // The super admin is the admin of this AccessControl contract\\n    requireAdmin({resource: address(this), accessor: accessor});\\n  }\\n}\\n\",\"keccak256\":\"0x1b70acad9e92a3b0898a989d413bb16b5c5707faf84f2eb31354b453385a7b54\",\"license\":\"MIT\"},\"contracts/cake/Base.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {Context} from \\\"./Context.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nusing Routing.Context for Context;\\n\\n/// @title Base contract for application-layer\\n/// @author landakram\\n/// @notice This base contract is what all application-layer contracts should inherit from.\\n///  It provides `Context`, as well as some convenience functions for working with it and\\n///  using access control. All public methods on the inheriting contract should likely\\n///  use one of the modifiers to assert valid callers.\\nabstract contract Base {\\n  error RequiresOperator(address resource, address accessor);\\n  error ZeroAddress();\\n\\n  /// @dev this is safe for proxies as immutable causes the context to be written to\\n  ///  bytecode on deployment. The proxy then treats this as a constant.\\n  Context immutable context;\\n\\n  constructor(Context _context) {\\n    context = _context;\\n  }\\n\\n  modifier onlyOperator(bytes4 operatorId) {\\n    requireOperator(operatorId, msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyOperators(bytes4[2] memory operatorIds) {\\n    requireAnyOperator(operatorIds, msg.sender);\\n    _;\\n  }\\n\\n  modifier onlyAdmin() {\\n    context.accessControl().requireAdmin(address(this), msg.sender);\\n    _;\\n  }\\n\\n  function requireAnyOperator(bytes4[2] memory operatorIds, address accessor) private view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n\\n    bool validOperator = isOperator(operatorIds[0], accessor) || isOperator(operatorIds[1], accessor);\\n\\n    if (!validOperator) revert RequiresOperator(address(this), accessor);\\n  }\\n\\n  function requireOperator(bytes4 operatorId, address accessor) private view {\\n    if (accessor == address(0)) revert ZeroAddress();\\n    if (!isOperator(operatorId, accessor)) revert RequiresOperator(address(this), accessor);\\n  }\\n\\n  function isOperator(bytes4 operatorId, address accessor) private view returns (bool) {\\n    return context.router().contracts(operatorId) == accessor;\\n  }\\n}\\n\",\"keccak256\":\"0x1dbf1ce1916f78d7b98876136dbd0be1fc33afc75a7ad9279dcacaaa57c34bc1\",\"license\":\"MIT\"},\"contracts/cake/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {Router} from \\\"./Router.sol\\\";\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\nusing Routing.Context for Context;\\n\\n/// @title Entry-point for all application-layer contracts.\\n/// @author landakram\\n/// @notice This contract provides an interface for retrieving other contract addresses and doing access\\n///  control.\\ncontract Context {\\n  /// @notice Used for retrieving other contract addresses.\\n  /// @dev This variable is immutable. This is done to save gas, as it is expected to be referenced\\n  /// in every end-user call with a call-chain length > 0. Note that it is written into the contract\\n  /// bytecode at contract creation time, so if the contract is deployed as the implementation for proxies,\\n  /// every proxy will share the same Router address.\\n  Router public immutable router;\\n\\n  constructor(Router _router) {\\n    router = _router;\\n  }\\n}\\n\",\"keccak256\":\"0xa680415dd02e61f8cd730f3198096d73b40fddb2f7f46136fc20e02a173ec107\",\"license\":\"MIT\"},\"contracts/cake/Router.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport {AccessControl} from \\\"./AccessControl.sol\\\";\\nimport {IRouter} from \\\"../interfaces/IRouter.sol\\\";\\n\\nimport \\\"./Routing.sol\\\" as Routing;\\n\\n/// @title Router\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ncontract Router is Initializable, IRouter {\\n  /// @notice Mapping of keys to contract addresses. Keys are the first 4 bytes of the keccak of\\n  ///   the contract's name. See Routing.sol for all options.\\n  mapping(bytes4 => address) public contracts;\\n\\n  function initialize(AccessControl accessControl) public initializer {\\n    contracts[Routing.Keys.AccessControl] = address(accessControl);\\n  }\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) public {\\n    AccessControl accessControl = AccessControl(contracts[Routing.Keys.AccessControl]);\\n    accessControl.requireAdmin(address(this), msg.sender);\\n    contracts[key] = addr;\\n    emit SetContract(key, addr);\\n  }\\n}\\n\",\"keccak256\":\"0x686176336adffd914b35e6cc23b551c4af63c43eba9c5416749427a5e02a98b0\",\"license\":\"MIT\"},\"contracts/cake/Routing.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable const-name-snakecase\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\n\\nimport {IMembershipVault} from \\\"../interfaces/IMembershipVault.sol\\\";\\nimport {IGFILedger} from \\\"../interfaces/IGFILedger.sol\\\";\\nimport {ICapitalLedger} from \\\"../interfaces/ICapitalLedger.sol\\\";\\nimport {IMembershipDirector} from \\\"../interfaces/IMembershipDirector.sol\\\";\\nimport {IMembershipOrchestrator} from \\\"../interfaces/IMembershipOrchestrator.sol\\\";\\nimport {IMembershipLedger} from \\\"../interfaces/IMembershipLedger.sol\\\";\\nimport {IMembershipCollector} from \\\"../interfaces/IMembershipCollector.sol\\\";\\n\\nimport {ISeniorPool} from \\\"../interfaces/ISeniorPool.sol\\\";\\nimport {IPoolTokens} from \\\"../interfaces/IPoolTokens.sol\\\";\\nimport {IStakingRewards} from \\\"../interfaces/IStakingRewards.sol\\\";\\n\\nimport {IERC20Splitter} from \\\"../interfaces/IERC20Splitter.sol\\\";\\nimport {Context as ContextContract} from \\\"./Context.sol\\\";\\nimport {IAccessControl} from \\\"../interfaces/IAccessControl.sol\\\";\\n\\nimport {Router} from \\\"./Router.sol\\\";\\n\\n/// @title Routing.Keys\\n/// @notice This library is used to define routing keys used by `Router`.\\n/// @dev We use uints instead of enums for several reasons. First, keys can be re-ordered\\n///   or removed. This is useful when routing keys are deprecated; they can be moved to a\\n///   different section of the file. Second, other libraries or contracts can define their\\n///   own routing keys independent of this global mapping. This is useful for test contracts.\\nlibrary Keys {\\n  // Membership\\n  bytes4 internal constant MembershipOrchestrator = bytes4(keccak256(\\\"MembershipOrchestrator\\\"));\\n  bytes4 internal constant MembershipDirector = bytes4(keccak256(\\\"MembershipDirector\\\"));\\n  bytes4 internal constant GFILedger = bytes4(keccak256(\\\"GFILedger\\\"));\\n  bytes4 internal constant CapitalLedger = bytes4(keccak256(\\\"CapitalLedger\\\"));\\n  bytes4 internal constant MembershipCollector = bytes4(keccak256(\\\"MembershipCollector\\\"));\\n  bytes4 internal constant MembershipLedger = bytes4(keccak256(\\\"MembershipLedger\\\"));\\n  bytes4 internal constant MembershipVault = bytes4(keccak256(\\\"MembershipVault\\\"));\\n\\n  // Tokens\\n  bytes4 internal constant GFI = bytes4(keccak256(\\\"GFI\\\"));\\n  bytes4 internal constant FIDU = bytes4(keccak256(\\\"FIDU\\\"));\\n  bytes4 internal constant USDC = bytes4(keccak256(\\\"USDC\\\"));\\n\\n  // Cake\\n  bytes4 internal constant AccessControl = bytes4(keccak256(\\\"AccessControl\\\"));\\n  bytes4 internal constant Router = bytes4(keccak256(\\\"Router\\\"));\\n\\n  // Core\\n  bytes4 internal constant ReserveSplitter = bytes4(keccak256(\\\"ReserveSplitter\\\"));\\n  bytes4 internal constant PoolTokens = bytes4(keccak256(\\\"PoolTokens\\\"));\\n  bytes4 internal constant SeniorPool = bytes4(keccak256(\\\"SeniorPool\\\"));\\n  bytes4 internal constant StakingRewards = bytes4(keccak256(\\\"StakingRewards\\\"));\\n  bytes4 internal constant ProtocolAdmin = bytes4(keccak256(\\\"ProtocolAdmin\\\"));\\n  bytes4 internal constant PauserAdmin = bytes4(keccak256(\\\"PauserAdmin\\\"));\\n}\\n\\n/// @title Routing.Context\\n/// @notice This library provides convenience functions for getting contracts from `Router`.\\nlibrary Context {\\n  function accessControl(ContextContract context) internal view returns (IAccessControl) {\\n    return IAccessControl(context.router().contracts(Keys.AccessControl));\\n  }\\n\\n  function membershipVault(ContextContract context) internal view returns (IMembershipVault) {\\n    return IMembershipVault(context.router().contracts(Keys.MembershipVault));\\n  }\\n\\n  function capitalLedger(ContextContract context) internal view returns (ICapitalLedger) {\\n    return ICapitalLedger(context.router().contracts(Keys.CapitalLedger));\\n  }\\n\\n  function gfiLedger(ContextContract context) internal view returns (IGFILedger) {\\n    return IGFILedger(context.router().contracts(Keys.GFILedger));\\n  }\\n\\n  function gfi(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.GFI));\\n  }\\n\\n  function membershipDirector(ContextContract context) internal view returns (IMembershipDirector) {\\n    return IMembershipDirector(context.router().contracts(Keys.MembershipDirector));\\n  }\\n\\n  function membershipOrchestrator(ContextContract context) internal view returns (IMembershipOrchestrator) {\\n    return IMembershipOrchestrator(context.router().contracts(Keys.MembershipOrchestrator));\\n  }\\n\\n  function stakingRewards(ContextContract context) internal view returns (IStakingRewards) {\\n    return IStakingRewards(context.router().contracts(Keys.StakingRewards));\\n  }\\n\\n  function poolTokens(ContextContract context) internal view returns (IPoolTokens) {\\n    return IPoolTokens(context.router().contracts(Keys.PoolTokens));\\n  }\\n\\n  function seniorPool(ContextContract context) internal view returns (ISeniorPool) {\\n    return ISeniorPool(context.router().contracts(Keys.SeniorPool));\\n  }\\n\\n  function fidu(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.FIDU));\\n  }\\n\\n  function usdc(ContextContract context) internal view returns (IERC20Upgradeable) {\\n    return IERC20Upgradeable(context.router().contracts(Keys.USDC));\\n  }\\n\\n  function reserveSplitter(ContextContract context) internal view returns (IERC20Splitter) {\\n    return IERC20Splitter(context.router().contracts(Keys.ReserveSplitter));\\n  }\\n\\n  function membershipLedger(ContextContract context) internal view returns (IMembershipLedger) {\\n    return IMembershipLedger(context.router().contracts(Keys.MembershipLedger));\\n  }\\n\\n  function membershipCollector(ContextContract context) internal view returns (IMembershipCollector) {\\n    return IMembershipCollector(context.router().contracts(Keys.MembershipCollector));\\n  }\\n\\n  function protocolAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.ProtocolAdmin);\\n  }\\n\\n  function pauserAdmin(ContextContract context) internal view returns (address) {\\n    return context.router().contracts(Keys.PauserAdmin);\\n  }\\n}\\n\",\"keccak256\":\"0x4a324049c639da20482479082129fc570daa0f06dbdd25fdce46ad401f8ec7c5\",\"license\":\"MIT\"},\"contracts/interfaces/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title Cake access control\\n/// @author landakram\\n/// @notice This contact centralizes contract-to-contract access control using a simple\\n/// access-control list. There are two types of actors: operators and admins. Operators\\n/// are callers involved in a regular end-user tx. This would likely be another Goldfinch\\n/// contract for which the current contract is a dependency. Admins are callers allowed\\n/// for specific admin actions (like changing parameters, topping up funds, etc.).\\ninterface IAccessControl {\\n  error RequiresAdmin(address resource, address accessor);\\n  error ZeroAddress();\\n\\n  event AdminSet(address indexed resource, address indexed admin);\\n\\n  /// @notice Set an admin for a given resource\\n  /// @param resource An address which with `admin` should be allowed to administer\\n  /// @param admin An address which should be allowed to administer `resource`\\n  /// @dev This method is only callable by the super-admin (the admin of this AccessControl\\n  ///   contract)\\n  function setAdmin(address resource, address admin) external;\\n\\n  /// @notice Require a valid admin for a given resource\\n  /// @param resource An address that `accessor` is attempting to access\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid admin\\n  function requireAdmin(address resource, address accessor) external view;\\n\\n  /// @notice Require a super-admin. A super-admin is an admin of this AccessControl contract.\\n  /// @param accessor An address on which to assert access control checks\\n  /// @dev This method reverts when `accessor` is not a valid super-admin\\n  function requireSuperAdmin(address accessor) external view;\\n}\\n\",\"keccak256\":\"0xa77d24e074f86c95657ada01678e9c7136b8769856182428f0f2cb6d191b341f\",\"license\":\"MIT\"},\"contracts/interfaces/ICapitalLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nenum CapitalAssetType {\\n  INVALID,\\n  ERC721\\n}\\n\\ninterface ICapitalLedger {\\n  /**\\n   * @notice Emitted when a new capital erc721 deposit has been made\\n   * @param owner address owning the deposit\\n   * @param assetAddress address of the deposited ERC721\\n   * @param positionId id for the deposit\\n   * @param assetTokenId id of the token from the ERC721 `assetAddress`\\n   * @param usdcEquivalent usdc equivalent value at the time of deposit\\n   */\\n  event CapitalERC721Deposit(\\n    address indexed owner,\\n    address indexed assetAddress,\\n    uint256 positionId,\\n    uint256 assetTokenId,\\n    uint256 usdcEquivalent\\n  );\\n\\n  /**\\n   * @notice Emitted when a new ERC721 capital withdrawal has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the capital position\\n   * @param assetAddress address of the underlying ERC721\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event CapitalERC721Withdrawal(\\n    address indexed owner,\\n    uint256 positionId,\\n    address assetAddress,\\n    uint256 depositTimestamp\\n  );\\n\\n  /// Thrown when called with an invalid asset type for the function. Valid\\n  /// types are defined under CapitalAssetType\\n  error InvalidAssetType(CapitalAssetType);\\n\\n  /**\\n   * @notice Account for a deposit of `id` for the ERC721 asset at `assetAddress`.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param owner address that owns the position\\n   * @param assetAddress address of the ERC20 address\\n   * @param assetTokenId id of the ERC721 asset to add\\n   * @return id of the newly created position\\n   */\\n  function depositERC721(\\n    address owner,\\n    address assetAddress,\\n    uint256 assetTokenId\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Get the id of the ERC721 asset held by position `id`. Pair this with\\n   *  `assetAddressOf` to get the address & id of the nft.\\n   * @dev reverts with InvalidAssetType if `assetAddress` is not an ERC721\\n   * @param positionId id of the position\\n   * @return id of the underlying ERC721 asset\\n   */\\n  function erc721IdOf(uint256 positionId) external view returns (uint256);\\n\\n  /**\\n   * @notice Completely withdraw a position\\n   * @param positionId id of the position\\n   */\\n  function withdraw(uint256 positionId) external;\\n\\n  /**\\n   * @notice Get the asset address of the position. Example: For an ERC721 position, this\\n   *  returns the address of that ERC721 contract.\\n   * @param positionId id of the position\\n   * @return asset address of the position\\n   */\\n  function assetAddressOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the number of capital positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return position id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the USDC value of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @param owner address owning the positions\\n   * @return eligibleAmount USDC value of positions eligible for rewards\\n   * @return totalAmount total USDC value of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xfd869b44e49041db9fb9ef2f6c00fcfceb38ba20f26631562cfb48fa2bec12ef\",\"license\":\"MIT\"},\"contracts/interfaces/ICreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\ninterface ICreditLine {\\n  function borrower() external view returns (address);\\n\\n  function limit() external view returns (uint256);\\n\\n  function maxLimit() external view returns (uint256);\\n\\n  function interestApr() external view returns (uint256);\\n\\n  function paymentPeriodInDays() external view returns (uint256);\\n\\n  function principalGracePeriodInDays() external view returns (uint256);\\n\\n  function termInDays() external view returns (uint256);\\n\\n  function lateFeeApr() external view returns (uint256);\\n\\n  function isLate() external view returns (bool);\\n\\n  function withinPrincipalGracePeriod() external view returns (bool);\\n\\n  // Accounting variables\\n  function balance() external view returns (uint256);\\n\\n  function interestOwed() external view returns (uint256);\\n\\n  function principalOwed() external view returns (uint256);\\n\\n  function termEndTime() external view returns (uint256);\\n\\n  function nextDueTime() external view returns (uint256);\\n\\n  function interestAccruedAsOf() external view returns (uint256);\\n\\n  function lastFullPaymentTime() external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xd54b264344ce302597ee4f04f147000275d05c8fc9612cc21eaff915ff1f30c8\",\"license\":\"MIT\"},\"contracts/interfaces/IERC20Splitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IERC20Splitter {\\n  function lastDistributionAt() external view returns (uint256);\\n\\n  function distribute() external;\\n\\n  function replacePayees(address[] calldata _payees, uint256[] calldata _shares) external;\\n\\n  function pendingDistributionFor(address payee) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x915a4058d1c4f6e694e1fdbaa708d3ec7e26dba3162f83290d997ec484960972\",\"license\":\"MIT\"},\"contracts/interfaces/IGFILedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IGFILedger {\\n  struct Position {\\n    // Owner of the position\\n    address owner;\\n    // Index of the position in the ownership array\\n    uint256 ownedIndex;\\n    // Amount of GFI held in the position\\n    uint256 amount;\\n    // When the position was deposited\\n    uint256 depositTimestamp;\\n  }\\n\\n  /**\\n   * @notice Emitted when a new GFI deposit has been made\\n   * @param owner address owning the deposit\\n   * @param positionId id for the deposit\\n   * @param amount how much GFI was deposited\\n   */\\n  event GFIDeposit(address indexed owner, uint256 indexed positionId, uint256 amount);\\n\\n  /**\\n   * @notice Emitted when a new GFI withdrawal has been made. If the remaining amount is 0, the position has bee removed\\n   * @param owner address owning the withdrawn position\\n   * @param positionId id for the position\\n   * @param remainingAmount how much GFI is remaining in the position\\n   * @param depositTimestamp block.timestamp of the original deposit\\n   */\\n  event GFIWithdrawal(\\n    address indexed owner,\\n    uint256 indexed positionId,\\n    uint256 withdrawnAmount,\\n    uint256 remainingAmount,\\n    uint256 depositTimestamp\\n  );\\n\\n  /**\\n   * @notice Account for a new deposit by the owner.\\n   * @param owner address to account for the deposit\\n   * @param amount how much was deposited\\n   * @return how much was deposited\\n   */\\n  function deposit(address owner, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId) external returns (uint256);\\n\\n  /**\\n   * @notice Account for a new withdraw by the owner.\\n   * @param positionId id of the position\\n   * @param amount how much to withdraw\\n   * @return how much was withdrawn\\n   */\\n  function withdraw(uint256 positionId, uint256 amount) external returns (uint256);\\n\\n  /**\\n   * @notice Get the number of GFI positions held by an address\\n   * @param addr address\\n   * @return positions held by address\\n   */\\n  function balanceOf(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the owner of a given position.\\n   * @param positionId id of the position\\n   * @return owner of the position\\n   */\\n  function ownerOf(uint256 positionId) external view returns (address);\\n\\n  /**\\n   * @notice Total number of positions in the ledger\\n   * @return number of positions in the ledger\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns a position ID owned by `owner` at a given `index` of its position list\\n   * @param owner owner of the positions\\n   * @param index index of the owner's balance to get the position ID of\\n   * @return position id\\n   *\\n   * @dev use with {balanceOf} to enumerate all of `owner`'s positions\\n   */\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns a position ID at a given `index` of all the positions stored by the contract.\\n   * @param index index to get the position ID at\\n   * @return token id\\n   *\\n   * @dev use with {totalSupply} to enumerate all positions\\n   */\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n\\n  /**\\n   * @notice Get amount of GFI of `owner`s positions, reporting what is currently\\n   *  eligible and the total amount.\\n   * @return eligibleAmount GFI amount of positions eligible for rewards\\n   * @return totalAmount total GFI amount of positions\\n   *\\n   * @dev this is used by Membership to determine how much is eligible in\\n   *  the current epoch vs the next epoch.\\n   */\\n  function totalsOf(address owner) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n}\\n\",\"keccak256\":\"0xa4aa4178b7ffd3d92d0db9f489cea52b574df2207ae463433472ccd5d4b67372\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipCollector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipCollector {\\n  /// @notice Have the collector distribute `amount` of Fidu to `addr`\\n  /// @param addr address to distribute to\\n  /// @param amount amount to distribute\\n  function distributeFiduTo(address addr, uint256 amount) external;\\n\\n  /// @notice Get the last epoch finalized by the collector. This means the\\n  ///  collector will no longer add rewards to the epoch.\\n  /// @return the last finalized epoch\\n  function lastFinalizedEpoch() external view returns (uint256);\\n\\n  /// @notice Get the rewards associated with `epoch`. This amount may change\\n  ///  until `epoch` has been finalized (is less than or equal to getLastFinalizedEpoch)\\n  /// @return rewards associated with `epoch`\\n  function rewardsForEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n  ///  this will be the fixed, accurate reward for the epoch. For the current and other\\n  ///  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n  ///  moment.\\n  /// @param epoch epoch to estimate the rewards of\\n  /// @return rewards associated with `epoch`\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0x8ea890c7237ee09c340afa47bce4fe6fd2e6d65bce601620edb1513e4b0f3914\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipDirector.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipDirector {\\n  /**\\n   * @notice Adjust an `owner`s membership score and position due to the change\\n   *  in their GFI and Capital holdings\\n   * @param owner address who's holdings changed\\n   * @return id of membership position\\n   */\\n  function consumeHoldingsAdjustment(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Collect all membership yield enhancements for the owner.\\n   * @param owner address to claim rewards for\\n   * @return amount of yield enhancements collected\\n   */\\n  function collectRewards(address owner) external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable for the owner. The return\\n   *  value here is how much would be retrieved by calling `collectRewards`.\\n   * @param owner address to calculate claimable rewards for\\n   * @return the amount of rewards that could be claimed by the owner\\n   */\\n  function claimableRewards(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate the membership score\\n   * @param gfi Amount of gfi\\n   * @param capital Amount of capital in USDC\\n   * @return membership score\\n   */\\n  function calculateMembershipScore(uint256 gfi, uint256 capital) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the current score of `owner`\\n   * @param owner address to check the score of\\n   * @return eligibleScore score that is currently eligible for rewards\\n   * @return totalScore score that will be elgible for rewards next epoch\\n   */\\n  function currentScore(address owner) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc4ad3f9a21473122dc03f92db9f78b3da14468ff17f7892e5feb6fed6f882abd\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipLedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\ninterface IMembershipLedger {\\n  /**\\n   * @notice Set `addr`s allocated rewards back to 0\\n   * @param addr address to reset rewards on\\n   */\\n  function resetRewards(address addr) external;\\n\\n  /**\\n   * @notice Allocate `amount` rewards for `addr` but do not send them\\n   * @param addr address to distribute rewards to\\n   * @param amount amount of rewards to allocate for `addr`\\n   * @return rewards total allocated to `addr`\\n   */\\n  function allocateRewardsTo(address addr, uint256 amount) external returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the rewards allocated to a certain `addr`\\n   * @param addr the address to check pending rewards for\\n   * @return rewards pending rewards for `addr`\\n   */\\n  function getPendingRewardsFor(address addr) external view returns (uint256 rewards);\\n\\n  /**\\n   * @notice Get the alpha parameter for the cobb douglas function. Will always be in (0,1).\\n   * @return numerator numerator for the alpha param\\n   * @return denominator denominator for the alpha param\\n   */\\n  function alpha() external view returns (uint128 numerator, uint128 denominator);\\n}\\n\",\"keccak256\":\"0x56bfc0d3ed5f532e3f36387d705f047252ba3cbeb8374e4bc51ed59a68197a33\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipOrchestrator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\n\\nimport {Context} from \\\"../cake/Context.sol\\\";\\n\\nstruct CapitalDeposit {\\n  /// Address of the asset being deposited\\n  /// @dev must be supported in CapitalAssets.sol\\n  address assetAddress;\\n  /// Id of the nft\\n  uint256 id;\\n}\\n\\nstruct Deposit {\\n  /// Amount of gfi to deposit\\n  uint256 gfi;\\n  /// List of capital deposits\\n  CapitalDeposit[] capitalDeposits;\\n}\\n\\nstruct DepositResult {\\n  uint256 membershipId;\\n  uint256 gfiPositionId;\\n  uint256[] capitalPositionIds;\\n}\\n\\nstruct ERC20Withdrawal {\\n  uint256 id;\\n  uint256 amount;\\n}\\n\\nstruct Withdrawal {\\n  /// List of gfi token ids to withdraw\\n  ERC20Withdrawal[] gfiPositions;\\n  /// List of capital token ids to withdraw\\n  uint256[] capitalPositions;\\n}\\n\\n/**\\n * @title MembershipOrchestrator\\n * @notice Externally facing gateway to all Goldfinch membership functionality.\\n * @author Goldfinch\\n */\\ninterface IMembershipOrchestrator {\\n  /**\\n   * @notice Deposit multiple assets defined in `multiDeposit`. Assets can include GFI, Staked Fidu,\\n   *  and others.\\n   * @param deposit struct describing all the assets to deposit\\n   * @return ids all of the ids of the created depoits, in the same order as deposit. If GFI is\\n   *  present, it will be the first id.\\n   */\\n  function deposit(Deposit calldata deposit) external returns (DepositResult memory);\\n\\n  /**\\n   * @notice Withdraw multiple assets defined in `multiWithdraw`. Assets can be GFI or capital\\n   *  positions ids. Caller must have been permitted to act upon all of the positions.\\n   * @param withdrawal all of the GFI and Capital ids to withdraw\\n   */\\n  function withdraw(Withdrawal calldata withdrawal) external;\\n\\n  /**\\n   * @notice Collect all membership rewards for the caller.\\n   * @return how many rewards were collected and sent to caller\\n   */\\n  function collectRewards() external returns (uint256);\\n\\n  /**\\n   * @notice Check how many rewards are claimable at this moment in time for caller.\\n   * @param addr the address to check claimable rewards for\\n   * @return how many rewards could be claimed by a call to `collectRewards`\\n   */\\n  function claimableRewards(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Check the voting power of a given address\\n   * @param addr the address to check the voting power of\\n   * @return the voting power\\n   */\\n  function votingPower(address addr) external view returns (uint256);\\n\\n  /**\\n   * @notice Get all GFI in Membership held by `addr`. This returns the current eligible amount and the\\n   *  total amount of GFI.\\n   * @param addr the owner\\n   * @return eligibleAmount how much GFI is currently eligible for rewards\\n   * @return totalAmount how much GFI is currently eligible for rewards\\n   */\\n  function totalGFIHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get all capital, denominated in USDC, in Membership held by `addr`. This returns the current\\n   *  eligible amount and the total USDC value of capital.\\n   * @param addr the owner\\n   * @return eligibleAmount how much USDC of capital is currently eligible for rewards\\n   * @return totalAmount how much  USDC of capital is currently eligible for rewards\\n   */\\n  function totalCapitalHeldBy(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount);\\n\\n  /**\\n   * @notice Get the member score of `addr`\\n   * @param addr the owner\\n   * @return eligibleScore the currently eligible score\\n   * @return totalScore the total score that will be eligible next epoch\\n   *\\n   * @dev if eligibleScore == totalScore then there are no changes between now and the next epoch\\n   */\\n  function memberScoreOf(address addr) external view returns (uint256 eligibleScore, uint256 totalScore);\\n\\n  /**\\n   * @notice Estimate rewards for a given epoch. For epochs at or before lastFinalizedEpoch\\n   *  this will be the fixed, accurate reward for the epoch. For the current and other\\n   *  non-finalized epochs, this will be the value as if the epoch were finalized in that\\n   *  moment.\\n   * @param epoch epoch to estimate the rewards of\\n   * @return rewards associated with `epoch`\\n   */\\n  function estimateRewardsFor(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Calculate what the Membership Score would be if a `gfi` amount of GFI and `capital` amount\\n   *  of Capital denominated in USDC were deposited.\\n   * @param gfi amount of GFI to estimate with\\n   * @param capital amount of capital to estimate with, denominated in USDC\\n   * @return score the resulting score\\n   */\\n  function calculateMemberScore(uint256 gfi, uint256 capital) external view returns (uint256 score);\\n\\n  /**\\n   * @notice Get the sum of all member scores that are currently eligible and that will be eligible next epoch\\n   * @return eligibleTotal sum of all member scores that are currently eligible\\n   * @return nextEpochTotal sum of all member scores that will be eligible next epoch\\n   */\\n  function totalMemberScores() external view returns (uint256 eligibleTotal, uint256 nextEpochTotal);\\n\\n  /**\\n   * @notice Estimate the score for an existing member, given some changes in GFI and capital\\n   * @param memberAddress the member's address\\n   * @param gfi the change in gfi holdings, denominated in GFI\\n   * @param capital the change in gfi holdings, denominated in USDC\\n   * @return score resulting score for the member given the GFI and capital changes\\n   */\\n  function estimateMemberScore(\\n    address memberAddress,\\n    int256 gfi,\\n    int256 capital\\n  ) external view returns (uint256 score);\\n\\n  /// @notice Finalize all unfinalized epochs. Causes the reserve splitter to distribute\\n  ///  if there are unfinalized epochs so all possible rewards are distributed.\\n  function finalizeEpochs() external;\\n}\\n\",\"keccak256\":\"0xc231b961b7ad5e98e45adcc355dd7d3f6f4dd5855486fba35d6f3ef466cbdee0\",\"license\":\"MIT\"},\"contracts/interfaces/IMembershipVault.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC721Upgradeable.sol\\\";\\n\\nstruct Position {\\n  // address owning the position\\n  address owner;\\n  // how much of the position is eligible as of checkpointEpoch\\n  uint256 eligibleAmount;\\n  // how much of the postion is eligible the epoch after checkpointEpoch\\n  uint256 nextEpochAmount;\\n  // when the position was first created\\n  uint256 createdTimestamp;\\n  // epoch of the last checkpoint\\n  uint256 checkpointEpoch;\\n}\\n\\n/**\\n * @title IMembershipVault\\n * @notice Track assets held by owners in a vault, as well as the total held in the vault. Assets\\n *  are not accounted for until the next epoch for MEV protection.\\n * @author Goldfinch\\n */\\ninterface IMembershipVault is IERC721Upgradeable {\\n  /**\\n   * @notice Emitted when an owner has adjusted their holdings in a vault\\n   * @param owner the owner increasing their holdings\\n   * @param eligibleAmount the new eligible amount\\n   * @param nextEpochAmount the new next epoch amount\\n   */\\n  event AdjustedHoldings(address indexed owner, uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Emitted when the total within the vault has changed\\n   * @param eligibleAmount new current amount\\n   * @param nextEpochAmount new next epoch amount\\n   */\\n  event VaultTotalUpdate(uint256 eligibleAmount, uint256 nextEpochAmount);\\n\\n  /**\\n   * @notice Get the current value of `owner`. This changes depending on the current\\n   *  block.timestamp as increased holdings are not accounted for until the subsequent epoch.\\n   * @param owner address owning the positions\\n   * @return sum of all positions held by an address\\n   */\\n  function currentValueOwnedBy(address owner) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of block.timestamp\\n   * @return total value in the vault as of block.timestamp\\n   */\\n  function currentTotal() external view returns (uint256);\\n\\n  /**\\n   * @notice Get the total value in the vault as of epoch\\n   * @return total value in the vault as of epoch\\n   */\\n  function totalAtEpoch(uint256 epoch) external view returns (uint256);\\n\\n  /**\\n   * @notice Get the position owned by `owner`\\n   * @return position owned by `owner`\\n   */\\n  function positionOwnedBy(address owner) external view returns (Position memory);\\n\\n  /**\\n   * @notice Record an adjustment in holdings. Eligible assets will update this epoch and\\n   *  total assets will become eligible the subsequent epoch.\\n   * @param owner the owner to checkpoint\\n   * @param eligibleAmount amount of points to apply to the current epoch\\n   * @param nextEpochAmount amount of points to apply to the next epoch\\n   * @return id of the position\\n   */\\n  function adjustHoldings(\\n    address owner,\\n    uint256 eligibleAmount,\\n    uint256 nextEpochAmount\\n  ) external returns (uint256);\\n\\n  /**\\n   * @notice Checkpoint a specific owner & the vault total\\n   * @param owner the owner to checkpoint\\n   *\\n   * @dev to collect rewards, this must be called before `increaseHoldings` or\\n   *  `decreaseHoldings`. Those functions must call checkpoint internally\\n   *  so the historical data will be lost otherwise.\\n   */\\n  function checkpoint(address owner) external;\\n}\\n\",\"keccak256\":\"0x5979e109a0a813e0db1de7167625a77f35dab12d184d2eedf1be7ad9706974f7\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolTokens.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./openzeppelin/IERC721.sol\\\";\\n\\ninterface IPoolTokens is IERC721 {\\n  event TokenMinted(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    uint256 tranche\\n  );\\n\\n  event TokenRedeemed(\\n    address indexed owner,\\n    address indexed pool,\\n    uint256 indexed tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed,\\n    uint256 tranche\\n  );\\n  event TokenBurned(address indexed owner, address indexed pool, uint256 indexed tokenId);\\n\\n  struct TokenInfo {\\n    address pool;\\n    uint256 tranche;\\n    uint256 principalAmount;\\n    uint256 principalRedeemed;\\n    uint256 interestRedeemed;\\n  }\\n\\n  struct MintParams {\\n    uint256 principalAmount;\\n    uint256 tranche;\\n  }\\n\\n  function mint(MintParams calldata params, address to) external returns (uint256);\\n\\n  function redeem(\\n    uint256 tokenId,\\n    uint256 principalRedeemed,\\n    uint256 interestRedeemed\\n  ) external;\\n\\n  function withdrawPrincipal(uint256 tokenId, uint256 principalAmount) external;\\n\\n  function burn(uint256 tokenId) external;\\n\\n  function onPoolCreated(address newPool) external;\\n\\n  function getTokenInfo(uint256 tokenId) external view returns (TokenInfo memory);\\n\\n  function validPool(address sender) external view returns (bool);\\n\\n  function isApprovedOrOwner(address spender, uint256 tokenId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x9569823f1e5647f6a627035a341dee918ef58f8b1faefa2a9fd47e75c1f1420f\",\"license\":\"MIT\"},\"contracts/interfaces/IRouter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.16;\\n\\n/// @title IRouter\\n/// @author landakram\\n/// @notice This contract provides service discovery for contracts using the cake framework.\\n///   It can be used in conjunction with the convenience methods defined in the `Routing.Context`\\n///   and `Routing.Keys` libraries.\\ninterface IRouter {\\n  event SetContract(bytes4 indexed key, address indexed addr);\\n\\n  /// @notice Associate a routing key to a contract address\\n  /// @dev This function is only callable by the Router admin\\n  /// @param key A routing key (defined in the `Routing.Keys` libary)\\n  /// @param addr A contract address\\n  function setContract(bytes4 key, address addr) external;\\n}\\n\",\"keccak256\":\"0xe2a04ffb3198fa9de6b8252e1c406eff3dfc0bf7555e2d420bf5e87925fa4d43\",\"license\":\"MIT\"},\"contracts/interfaces/ISeniorPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ITranchedPool.sol\\\";\\n\\nabstract contract ISeniorPool {\\n  uint256 public sharePrice;\\n  uint256 public totalLoansOutstanding;\\n  uint256 public totalWritedowns;\\n\\n  function deposit(uint256 amount) external virtual returns (uint256 depositShares);\\n\\n  function depositWithPermit(\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 depositShares);\\n\\n  function withdraw(uint256 usdcAmount) external virtual returns (uint256 amount);\\n\\n  function withdrawInFidu(uint256 fiduAmount) external virtual returns (uint256 amount);\\n\\n  function sweepToCompound() public virtual;\\n\\n  function sweepFromCompound() public virtual;\\n\\n  function invest(ITranchedPool pool) public virtual;\\n\\n  function estimateInvestment(ITranchedPool pool) public view virtual returns (uint256);\\n\\n  function redeem(uint256 tokenId) public virtual;\\n\\n  function writedown(uint256 tokenId) public virtual;\\n\\n  function calculateWritedown(uint256 tokenId) public view virtual returns (uint256 writedownAmount);\\n\\n  function assets() public view virtual returns (uint256);\\n\\n  function getNumShares(uint256 amount) public view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x529b3e34b03c6400e6cd8da7683b6d0daf1c8694dbbff889bd05f1a0b5923e9b\",\"license\":\"MIT\"},\"contracts/interfaces/IStakingRewards.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.12;\\n\\npragma experimental ABIEncoderV2;\\n\\nimport {IERC721} from \\\"./openzeppelin/IERC721.sol\\\";\\nimport {IERC721Metadata} from \\\"./openzeppelin/IERC721Metadata.sol\\\";\\nimport {IERC721Enumerable} from \\\"./openzeppelin/IERC721Enumerable.sol\\\";\\n\\ninterface IStakingRewards is IERC721, IERC721Metadata, IERC721Enumerable {\\n  function getPosition(uint256 tokenId) external view returns (StakedPosition memory position);\\n\\n  function unstake(uint256 tokenId, uint256 amount) external;\\n\\n  function addToStake(uint256 tokenId, uint256 amount) external;\\n\\n  function stakedBalanceOf(uint256 tokenId) external view returns (uint256);\\n\\n  function depositToCurveAndStakeFrom(\\n    address nftRecipient,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount\\n  ) external;\\n\\n  function kick(uint256 tokenId) external;\\n\\n  function accumulatedRewardsPerToken() external view returns (uint256);\\n\\n  function lastUpdateTime() external view returns (uint256);\\n\\n  /* ========== EVENTS ========== */\\n\\n  event RewardAdded(uint256 reward);\\n  event Staked(\\n    address indexed user,\\n    uint256 indexed tokenId,\\n    uint256 amount,\\n    StakedPositionType positionType,\\n    uint256 baseTokenExchangeRate\\n  );\\n  event DepositedAndStaked(address indexed user, uint256 depositedAmount, uint256 indexed tokenId, uint256 amount);\\n  event DepositedToCurve(address indexed user, uint256 fiduAmount, uint256 usdcAmount, uint256 tokensReceived);\\n  event DepositedToCurveAndStaked(\\n    address indexed user,\\n    uint256 fiduAmount,\\n    uint256 usdcAmount,\\n    uint256 indexed tokenId,\\n    uint256 amount\\n  );\\n  event Unstaked(address indexed user, uint256 indexed tokenId, uint256 amount, StakedPositionType positionType);\\n  event UnstakedMultiple(address indexed user, uint256[] tokenIds, uint256[] amounts);\\n  event UnstakedAndWithdrew(address indexed user, uint256 usdcReceivedAmount, uint256 indexed tokenId, uint256 amount);\\n  event UnstakedAndWithdrewMultiple(\\n    address indexed user,\\n    uint256 usdcReceivedAmount,\\n    uint256[] tokenIds,\\n    uint256[] amounts\\n  );\\n  event RewardPaid(address indexed user, uint256 indexed tokenId, uint256 reward);\\n  event RewardsParametersUpdated(\\n    address indexed who,\\n    uint256 targetCapacity,\\n    uint256 minRate,\\n    uint256 maxRate,\\n    uint256 minRateAtPercent,\\n    uint256 maxRateAtPercent\\n  );\\n  event EffectiveMultiplierUpdated(address indexed who, StakedPositionType positionType, uint256 multiplier);\\n}\\n\\n/// @notice Indicates which ERC20 is staked\\nenum StakedPositionType {\\n  Fidu,\\n  CurveLP\\n}\\n\\nstruct Rewards {\\n  uint256 totalUnvested;\\n  uint256 totalVested;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this was used in the case of slashing.\\n  //   For non-vesting positions, this is unused.\\n  uint256 totalPreviouslyVested;\\n  uint256 totalClaimed;\\n  uint256 startTime;\\n  // @dev DEPRECATED (definition kept for storage slot)\\n  //   For legacy vesting positions, this is the endTime of the vesting.\\n  //   For non-vesting positions, this is 0.\\n  uint256 endTime;\\n}\\n\\nstruct StakedPosition {\\n  // @notice Staked amount denominated in `stakingToken().decimals()`\\n  uint256 amount;\\n  // @notice Struct describing rewards owed with vesting\\n  Rewards rewards;\\n  // @notice Multiplier applied to staked amount when locking up position\\n  uint256 leverageMultiplier;\\n  // @notice Time in seconds after which position can be unstaked\\n  uint256 lockedUntil;\\n  // @notice Type of the staked position\\n  StakedPositionType positionType;\\n  // @notice Multiplier applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeEffectiveMultiplier()`, which correctly handles old staked positions.\\n  uint256 unsafeEffectiveMultiplier;\\n  // @notice Exchange rate applied to staked amount to denominate in `baseStakingToken().decimals()`\\n  // @dev This field should not be used directly; it may be 0 for staked positions created prior to GIP-1.\\n  //  If you need this field, use `safeBaseTokenExchangeRate()`, which correctly handles old staked positions.\\n  uint256 unsafeBaseTokenExchangeRate;\\n}\\n\",\"keccak256\":\"0xb001875f3e7a6414f8e72cf25afdd30cd949fd2b0a219a4778b8027ef1d26667\",\"license\":\"MIT\"},\"contracts/interfaces/ITranchedPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport {IV2CreditLine} from \\\"./IV2CreditLine.sol\\\";\\n\\nabstract contract ITranchedPool {\\n  IV2CreditLine public creditLine;\\n  uint256 public createdAt;\\n  enum Tranches {\\n    Reserved,\\n    Senior,\\n    Junior\\n  }\\n\\n  struct TrancheInfo {\\n    uint256 id;\\n    uint256 principalDeposited;\\n    uint256 principalSharePrice;\\n    uint256 interestSharePrice;\\n    uint256 lockedUntil;\\n  }\\n\\n  struct PoolSlice {\\n    TrancheInfo seniorTranche;\\n    TrancheInfo juniorTranche;\\n    uint256 totalInterestAccrued;\\n    uint256 principalDeployed;\\n  }\\n\\n  function initialize(\\n    address _config,\\n    address _borrower,\\n    uint256 _juniorFeePercent,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays,\\n    uint256 _fundableAt,\\n    uint256[] calldata _allowedUIDTypes\\n  ) public virtual;\\n\\n  function getTranche(uint256 tranche) external view virtual returns (TrancheInfo memory);\\n\\n  function pay(uint256 amount) external virtual;\\n\\n  function poolSlices(uint256 index) external view virtual returns (PoolSlice memory);\\n\\n  function lockJuniorCapital() external virtual;\\n\\n  function lockPool() external virtual;\\n\\n  function initializeNextSlice(uint256 _fundableAt) external virtual;\\n\\n  function totalJuniorDeposits() external view virtual returns (uint256);\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function setFundableAt(uint256 timestamp) external virtual;\\n\\n  function deposit(uint256 tranche, uint256 amount) external virtual returns (uint256 tokenId);\\n\\n  function assess() external virtual;\\n\\n  function depositWithPermit(\\n    uint256 tranche,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external virtual returns (uint256 tokenId);\\n\\n  function availableToWithdraw(uint256 tokenId)\\n    external\\n    view\\n    virtual\\n    returns (uint256 interestRedeemable, uint256 principalRedeemable);\\n\\n  function withdraw(uint256 tokenId, uint256 amount)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMax(uint256 tokenId)\\n    external\\n    virtual\\n    returns (uint256 interestWithdrawn, uint256 principalWithdrawn);\\n\\n  function withdrawMultiple(uint256[] calldata tokenIds, uint256[] calldata amounts) external virtual;\\n\\n  function numSlices() external view virtual returns (uint256);\\n}\\n\",\"keccak256\":\"0x7a21d304a7ba635f4a074488d152c62c6b8b442cc5a5ad85a454621f4baec659\",\"license\":\"MIT\"},\"contracts/interfaces/IV2CreditLine.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./ICreditLine.sol\\\";\\n\\nabstract contract IV2CreditLine is ICreditLine {\\n  function principal() external view virtual returns (uint256);\\n\\n  function totalInterestAccrued() external view virtual returns (uint256);\\n\\n  function termStartTime() external view virtual returns (uint256);\\n\\n  function setLimit(uint256 newAmount) external virtual;\\n\\n  function setMaxLimit(uint256 newAmount) external virtual;\\n\\n  function setBalance(uint256 newBalance) external virtual;\\n\\n  function setPrincipal(uint256 _principal) external virtual;\\n\\n  function setTotalInterestAccrued(uint256 _interestAccrued) external virtual;\\n\\n  function drawdown(uint256 amount) external virtual;\\n\\n  function assess()\\n    external\\n    virtual\\n    returns (\\n      uint256,\\n      uint256,\\n      uint256\\n    );\\n\\n  function initialize(\\n    address _config,\\n    address owner,\\n    address _borrower,\\n    uint256 _limit,\\n    uint256 _interestApr,\\n    uint256 _paymentPeriodInDays,\\n    uint256 _termInDays,\\n    uint256 _lateFeeApr,\\n    uint256 _principalGracePeriodInDays\\n  ) public virtual;\\n\\n  function setTermEndTime(uint256 newTermEndTime) external virtual;\\n\\n  function setNextDueTime(uint256 newNextDueTime) external virtual;\\n\\n  function setInterestOwed(uint256 newInterestOwed) external virtual;\\n\\n  function setPrincipalOwed(uint256 newPrincipalOwed) external virtual;\\n\\n  function setInterestAccruedAsOf(uint256 newInterestAccruedAsOf) external virtual;\\n\\n  function setWritedownAmount(uint256 newWritedownAmount) external virtual;\\n\\n  function setLastFullPaymentTime(uint256 newLastFullPaymentTime) external virtual;\\n\\n  function setLateFeeApr(uint256 newLateFeeApr) external virtual;\\n}\\n\",\"keccak256\":\"0xc72be7462ade69ec2d4bb18344cfe1c8b4659bd68314cef013aa5616bfe8f607\",\"license\":\"MIT\"},\"contracts/interfaces/openzeppelin/IERC165.sol\":{\"content\":\"pragma solidity >=0.6.0;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbbdb8f6dfaecd47a0d65bee707877d6974a0e0da6c02403ad5ce00590bd97497\"},\"contracts/interfaces/openzeppelin/IERC721.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >= & reference other >= pragma interfaces.\\n// NOTE: Modified to reference our updated pragma version of IERC165\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n  /**\\n   * @dev Returns the number of NFTs in ``owner``'s account.\\n   */\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  /**\\n   * @dev Returns the owner of the NFT specified by `tokenId`.\\n   */\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   *\\n   *\\n   * Requirements:\\n   * - `from`, `to` cannot be zero.\\n   * - `tokenId` must be owned by `from`.\\n   * - If the caller is not `from`, it must be have been allowed to move this\\n   * NFT by either {approve} or {setApprovalForAll}.\\n   */\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  /**\\n   * @dev Transfers a specific NFT (`tokenId`) from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Requirements:\\n   * - If the caller is not `from`, it must be approved to move this NFT by\\n   * either {approve} or {setApprovalForAll}.\\n   */\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId\\n  ) external;\\n\\n  function approve(address to, uint256 tokenId) external;\\n\\n  function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n  function setApprovalForAll(address operator, bool _approved) external;\\n\\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n  function safeTransferFrom(\\n    address from,\\n    address to,\\n    uint256 tokenId,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x2527635bd6ab0d348f5f7d325ef2241a544586bb85dd806053adf1cc409293e5\"},\"contracts/interfaces/openzeppelin/IERC721Enumerable.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\\n\\n  function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0x7fd709ba4093899fc4593cb1413132e127773a349a8aef9ce234d62fa36b5fca\"},\"contracts/interfaces/openzeppelin/IERC721Metadata.sol\":{\"content\":\"pragma solidity >=0.6.2;\\n\\n// This file copied from OZ, but with the version pragma updated to use >=.\\n\\nimport \\\"./IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x56c56c47d03d0ea452a13842ad2e3e5b81b3689c484efd35a48f3977e9b929d8\"},\"contracts/library/Arrays.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary Arrays {\\n  /**\\n   * @notice Removes an item from an array and replaces it with the (previously) last element in the array so\\n   *  there are no empty spaces. Assumes that `array` is not empty and index is valid.\\n   * @param array the array to remove from\\n   * @param index index of the item to remove\\n   * @return newLength length of the resulting array\\n   * @return replaced whether or not the index was replaced. Only false if the removed item was the last item\\n   *  in the array.\\n   */\\n  function reorderingRemove(uint256[] storage array, uint256 index)\\n    internal\\n    returns (uint256 newLength, bool replaced)\\n  {\\n    newLength = array.length - 1;\\n    replaced = newLength != index;\\n\\n    if (replaced) {\\n      array[index] = array[newLength];\\n    }\\n\\n    array.pop();\\n  }\\n}\\n\",\"keccak256\":\"0xb29bd56a8fa3950715a342545ca0d27a4f6ed758dc776aac375c615998251dd8\",\"license\":\"MIT\"},\"contracts/protocol/core/membership/Epochs.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nlibrary Epochs {\\n  uint256 internal constant EPOCH_SECONDS = 7 days;\\n\\n  /**\\n   * @notice Get the epoch containing the timestamp `s`\\n   * @param s the timestamp\\n   * @return corresponding epoch\\n   */\\n  function fromSeconds(uint256 s) internal pure returns (uint256) {\\n    return s / EPOCH_SECONDS;\\n  }\\n\\n  /**\\n   * @notice Get the current epoch for the block.timestamp\\n   * @return current epoch\\n   */\\n  function current() internal view returns (uint256) {\\n    return fromSeconds(block.timestamp);\\n  }\\n\\n  /**\\n   * @notice Get the start timestamp for the current epoch\\n   * @return current epoch start timestamp\\n   */\\n  function currentEpochStartTimestamp() internal view returns (uint256) {\\n    return startOf(current());\\n  }\\n\\n  /**\\n   * @notice Get the previous epoch given block.timestamp\\n   * @return previous epoch\\n   */\\n  function previous() internal view returns (uint256) {\\n    return current() - 1;\\n  }\\n\\n  /**\\n   * @notice Get the next epoch given block.timestamp\\n   * @return next epoch\\n   */\\n  function next() internal view returns (uint256) {\\n    return current() + 1;\\n  }\\n\\n  /**\\n   * @notice Get the Unix timestamp of the start of `epoch`\\n   * @param epoch the epoch\\n   * @return unix timestamp\\n   */\\n  function startOf(uint256 epoch) internal pure returns (uint256) {\\n    return epoch * EPOCH_SECONDS;\\n  }\\n}\\n\",\"keccak256\":\"0xa1d08c0e15d503ca9fa94d6633109cfc221fd31b0a8889685c8c3582efcd758b\",\"license\":\"MIT\"},\"contracts/protocol/core/membership/GFILedger.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/interfaces/IERC20Upgradeable.sol\\\";\\n// solhint-disable-next-line max-line-length\\nimport {SafeERC20Upgradeable as SafeERC20} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\n\\nimport {Context} from \\\"../../../cake/Context.sol\\\";\\nimport {Base} from \\\"../../../cake/Base.sol\\\";\\nimport \\\"../../../cake/Routing.sol\\\" as Routing;\\n\\nimport {Arrays} from \\\"../../../library/Arrays.sol\\\";\\nimport {UserEpochTotals, UserEpochTotal} from \\\"./UserEpochTotals.sol\\\";\\n\\nimport \\\"../../../interfaces/IGFILedger.sol\\\";\\n\\nusing Routing.Context for Context;\\nusing UserEpochTotals for UserEpochTotal;\\nusing Arrays for uint256[];\\nusing SafeERC20 for IERC20Upgradeable;\\n\\n/**\\n * @title GFILedger\\n * @notice Track GFI held by owners and ensure the GFI has been accounted for.\\n * @author Goldfinch\\n */\\ncontract GFILedger is IGFILedger, Base {\\n  /// Thrown when depositing zero GFI for a position\\n  error ZeroDepositAmount();\\n  /// Thrown when withdrawing an invalid amount for a position\\n  error InvalidWithdrawAmount(uint256 requested, uint256 max);\\n  /// Thrown when depositing from address(0)\\n  error InvalidOwnerIndex();\\n  /// Thrown when querying token supply with an index greater than the supply\\n  error IndexGreaterThanTokenSupply();\\n\\n  // All positions in the ledger\\n  mapping(uint256 => Position) public positions;\\n\\n  // Which positions an address owns\\n  mapping(address => uint256[]) private owners;\\n\\n  /// Total held by each user, while being aware of the deposit epoch\\n  mapping(address => UserEpochTotal) private totals;\\n\\n  // Most recent position minted\\n  uint256 private positionCounter;\\n\\n  /// @notice Construct the contract\\n  constructor(Context _context) Base(_context) {}\\n\\n  /// @inheritdoc IGFILedger\\n  function deposit(address owner, uint256 amount)\\n    external\\n    onlyOperator(Routing.Keys.MembershipOrchestrator)\\n    returns (uint256 positionId)\\n  {\\n    if (amount == 0) {\\n      revert ZeroDepositAmount();\\n    }\\n    positionId = _mintPosition(owner, amount);\\n\\n    totals[owner].recordIncrease(amount);\\n\\n    context.gfi().safeTransferFrom(address(context.membershipOrchestrator()), address(this), amount);\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function withdraw(uint256 positionId) external onlyOperator(Routing.Keys.MembershipOrchestrator) returns (uint256) {\\n    return _withdraw(positionId);\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function withdraw(uint256 positionId, uint256 amount)\\n    external\\n    onlyOperator(Routing.Keys.MembershipOrchestrator)\\n    returns (uint256)\\n  {\\n    Position memory position = positions[positionId];\\n\\n    if (amount > position.amount) revert InvalidWithdrawAmount(amount, position.amount);\\n    if (amount == position.amount) return _withdraw(positionId);\\n\\n    positions[positionId].amount -= amount;\\n    totals[position.owner].recordDecrease(amount, position.depositTimestamp);\\n\\n    context.gfi().safeTransfer(position.owner, amount);\\n\\n    emit GFIWithdrawal({\\n      owner: position.owner,\\n      positionId: positionId,\\n      withdrawnAmount: amount,\\n      remainingAmount: position.amount - amount,\\n      depositTimestamp: position.depositTimestamp\\n    });\\n\\n    return amount;\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function balanceOf(address addr) external view returns (uint256 balance) {\\n    return owners[addr].length;\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function ownerOf(uint256 positionId) external view returns (address) {\\n    return positions[positionId].owner;\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function totalsOf(address addr) external view returns (uint256 eligibleAmount, uint256 totalAmount) {\\n    return totals[addr].getTotals();\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function totalSupply() public view returns (uint256) {\\n    return positionCounter;\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256) {\\n    if (index >= owners[owner].length) revert InvalidOwnerIndex();\\n\\n    return owners[owner][index];\\n  }\\n\\n  /// @inheritdoc IGFILedger\\n  function tokenByIndex(uint256 index) external view returns (uint256) {\\n    if (index >= totalSupply()) revert IndexGreaterThanTokenSupply();\\n\\n    return index + 1;\\n  }\\n\\n  //////////////////////////////////////////////////////////////////\\n  // Private\\n\\n  function _mintPosition(address owner, uint256 amount) private returns (uint256 positionId) {\\n    positionCounter++;\\n\\n    positionId = positionCounter;\\n\\n    positions[positionId] = Position({\\n      owner: owner,\\n      ownedIndex: owners[owner].length,\\n      amount: amount,\\n      depositTimestamp: block.timestamp\\n    });\\n\\n    owners[owner].push(positionId);\\n\\n    emit GFIDeposit({owner: owner, positionId: positionId, amount: amount});\\n  }\\n\\n  function _withdraw(uint256 positionId) private returns (uint256) {\\n    Position memory position = positions[positionId];\\n    delete positions[positionId];\\n\\n    uint256[] storage ownersList = owners[position.owner];\\n    (, bool replaced) = ownersList.reorderingRemove(position.ownedIndex);\\n    if (replaced) {\\n      positions[ownersList[position.ownedIndex]].ownedIndex = position.ownedIndex;\\n    }\\n\\n    totals[position.owner].recordDecrease(position.amount, position.depositTimestamp);\\n\\n    context.gfi().safeTransfer(position.owner, position.amount);\\n\\n    emit GFIWithdrawal({\\n      owner: position.owner,\\n      positionId: positionId,\\n      withdrawnAmount: position.amount,\\n      remainingAmount: 0,\\n      depositTimestamp: position.depositTimestamp\\n    });\\n\\n    return position.amount;\\n  }\\n}\\n\",\"keccak256\":\"0x88ae08ff92609989526e96ad227ea0404c13fcc8bb319f8531dfdba281adfef5\",\"license\":\"MIT\"},\"contracts/protocol/core/membership/UserEpochTotals.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.16;\\n\\nimport {Epochs} from \\\"./Epochs.sol\\\";\\n\\n/// @dev Epoch Awareness\\n/// The Membership system relies on an epoch structure to incentivize economic behavior. Deposits\\n/// are tracked by epoch and only count toward yield enhancements if they have been present for\\n/// an entire epoch. This means positions have a specific lifetime:\\n/// 1. Deposit Epoch - Positions are in the membership system but do not count for rewards as they\\n///      were not in since the beginning of the epoch. Deposits are externally triggered.\\n/// 2. Eligible Epoch - Positions are in the membership system and count for rewards as they have been\\n///      present the entire epoch.\\n/// 3. Withdrawal Epoch - Positions are no longer in the membership system and forfeit their rewards\\n///      for the withdrawal epoch. Rewards are forfeited as the position was not present for the\\n///      entire epoch when withdrawn. Withdrawals are externally triggered.\\n///\\n/// All of these deposits' value is summed together to calculate the yield enhancement. A naive\\n/// approach is, for every summation query, iterate over all deposits and check if they were deposited\\n/// in the current epoch (so case (1)) or in a previous epoch (so case (2)). This has a high gas\\n/// cost, so we use another approach: UserEpochTotal.\\n///\\n/// UserEpochTotal is the total of the user's deposits as of its lastEpochUpdate- the last epoch that\\n/// the total was updated in. For that epoch, it tracks:\\n/// 1. Eligible Amount - The sum of deposits that are in their Eligible Epoch for the current epoch\\n/// 2. Total Amount - The sum of deposits that will be in their Eligible Epoch for the next epoch\\n///\\n/// It is not necessary to track previous epochs as deposits in those will already be eligible, or they\\n/// will have been withdrawn and already affected the eligible amount.\\n///\\n/// It is also unnecessary to track future epochs beyond the next one. Any deposit in the current epoch\\n/// will become eligible in the next epoch. It is not possible to have a deposit (or withdrawal) take\\n/// effect any further in the future.\\n\\nstruct UserEpochTotal {\\n  /// Total amount that will be eligible for membership, after `checkpointedAt` epoch\\n  uint256 totalAmount;\\n  /// Amount eligible for membership, as of `checkpointedAt` epoch\\n  uint256 eligibleAmount;\\n  /// Last epoch the total was checkpointed at\\n  uint256 checkpointedAt;\\n}\\n\\nlibrary UserEpochTotals {\\n  error InvalidDepositEpoch(uint256 epoch);\\n\\n  /// @notice Record an increase of `amount` in the `total`. This is counted toward the\\n  ///  nextAmount as deposits must be present for an entire epoch to be valid.\\n  /// @param total storage pointer to the UserEpochTotal\\n  /// @param amount amount to increase the total by\\n  function recordIncrease(UserEpochTotal storage total, uint256 amount) internal {\\n    _checkpoint(total);\\n\\n    total.totalAmount += amount;\\n  }\\n\\n  /// @notice Record a decrease of `amount` in the `total`. Depending on the `depositTimestamp`\\n  ///  this will withdraw from the total's currentAmount (if it's withdrawn from an already valid deposit)\\n  ///  or from the total's nextAmount (if it's withdrawn from a deposit this epoch).\\n  /// @param total storage pointer to the UserEpochTotal\\n  /// @param amount amount to decrease the total by\\n  /// @param depositTimestamp timestamp of the deposit associated with `amount`\\n  function recordDecrease(\\n    UserEpochTotal storage total,\\n    uint256 amount,\\n    uint256 depositTimestamp\\n  ) internal {\\n    uint256 depositEpoch = Epochs.fromSeconds(depositTimestamp);\\n    if (depositEpoch > Epochs.current()) revert InvalidDepositEpoch(depositEpoch);\\n\\n    _checkpoint(total);\\n\\n    total.totalAmount -= amount;\\n\\n    if (depositEpoch < Epochs.current()) {\\n      // If this was deposited earlier, then it would have been promoted in _checkpoint and must be removed.\\n      total.eligibleAmount -= amount;\\n    }\\n  }\\n\\n  /// @notice Get the up-to-date current and next amount for the `_total`. UserEpochTotals\\n  ///  may have a lastEpochUpdate of long ago. This returns the current and next amounts as if it had\\n  ///  been checkpointed just now.\\n  /// @param _total storage pointer to the UserEpochTotal\\n  /// @return current the currentAmount of the UserEpochTotal\\n  /// @return next the nextAmount of the UserEpochTotal\\n  function getTotals(UserEpochTotal storage _total) internal view returns (uint256 current, uint256 next) {\\n    UserEpochTotal memory total = _total;\\n    if (Epochs.current() == total.checkpointedAt) {\\n      return (total.eligibleAmount, total.totalAmount);\\n    }\\n\\n    return (total.totalAmount, total.totalAmount);\\n  }\\n\\n  //////////////////////////////////////////////////////////////////\\n  // Private\\n\\n  function _checkpoint(UserEpochTotal storage total) private {\\n    // Only promote the total amount if we've moved to the next epoch\\n    // after the last checkpoint.\\n    if (Epochs.current() <= total.checkpointedAt) return;\\n\\n    total.eligibleAmount = total.totalAmount;\\n\\n    total.checkpointedAt = Epochs.current();\\n  }\\n}\\n\",\"keccak256\":\"0x70a295c14e733bad49464778b73e6a998529d453802096c2e43545c9fb64d3c1\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b506040516112f63803806112f683398101604081905261002f91610040565b6001600160a01b0316608052610070565b60006020828403121561005257600080fd5b81516001600160a01b038116811461006957600080fd5b9392505050565b60805161124f6100a7600039600081816103fb0152818161051201528181610546015281816107290152610bd8015261124f6000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c806347e7ef241161006657806347e7ef241461011b5780634f6ccce71461012e5780636352211e1461014157806370a082311461018257806399fbab88146101ab57600080fd5b806318160ddd146100a35780632e1a7d4d146100ba5780632f745c59146100cd578063427d7432146100e0578063441a3e7014610108575b600080fd5b6003545b6040519081526020015b60405180910390f35b6100a76100c8366004610ff3565b610214565b6100a76100db366004611024565b61023f565b6100f36100ee366004611050565b6102b5565b604080519283526020830191909152016100b1565b6100a761011636600461106d565b6102e1565b6100a7610129366004611024565b61049f565b6100a761013c366004610ff3565b610584565b61016a61014f366004610ff3565b6000908152602081905260409020546001600160a01b031690565b6040516001600160a01b0390911681526020016100b1565b6100a7610190366004611050565b6001600160a01b031660009081526001602052604090205490565b6101ea6101b9366004610ff3565b60006020819052908152604090208054600182015460028301546003909301546001600160a01b0390921692909184565b604080516001600160a01b03909516855260208501939093529183015260608201526080016100b1565b60006000805160206111fa83398151915261022f81336105b9565b6102388361061c565b9392505050565b6001600160a01b038216600090815260016020526040812054821061027757604051638f832b9b60e01b815260040160405180910390fd5b6001600160a01b03831660009081526001602052604090208054839081106102a1576102a161108f565b906000526020600020015490505b92915050565b6001600160a01b038116600090815260026020526040812081906102d8906107b6565b91509150915091565b60006000805160206111fa8339815191526102fc81336105b9565b60008481526020818152604091829020825160808101845281546001600160a01b0316815260018201549281019290925260028101549282018390526003015460608201529084111561037c57838160400151604051637d12377b60e11b8152600401610373929190918252602082015260400190565b60405180910390fd5b80604001518403610398576103908561061c565b925050610498565b600085815260208190526040812060020180548692906103b99084906110bb565b9091555050606081015181516001600160a01b031660009081526002602052604090206103e7918690610807565b805161043090856104206001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016610891565b6001600160a01b03169190610981565b8481600001516001600160a01b03167ff6763bd8d37738b3bf0660478688894b97ecb4b42b87cb9edcb99022070fa54e8687856040015161047191906110bb565b606086810151604080519485526020850193909352838301529051918290030190a3839250505b5092915050565b60006000805160206111fa8339815191526104ba81336105b9565b826000036104db5760405163078e1d8560e01b815260040160405180910390fd5b6104e584846109e9565b6001600160a01b038516600090815260026020526040902090925061050a9084610acf565b61049861053f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610af5565b30856105737f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610891565b6001600160a01b0316929190610b92565b600061058f60035490565b82106105ae57604051633f7ee38f60e11b815260040160405180910390fd5b6102af8260016110ce565b6001600160a01b0381166105e05760405163d92e233d60e01b815260040160405180910390fd5b6105ea8282610bca565b6106185760405163889a56bb60e01b81523060048201526001600160a01b0382166024820152604401610373565b5050565b600081815260208181526040808320815160808101835281546001600160a01b03808216835260018085018054858901908152600287018054878a015260038801805460608901528c8c528b8b526001600160a01b031990961690975590899055948890559187905582511686529093529083209051839061069f908390610cd5565b91505080156106e7578260200151600080848660200151815481106106c6576106c661108f565b90600052602060002001548152602001908152602001600020600101819055505b604080840151606085015185516001600160a01b0316600090815260026020529290922061071792909190610807565b610756836000015184604001516104207f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610891565b825160408085015160608087015183519283526000602084015282840152915188936001600160a01b0316927ff6763bd8d37738b3bf0660478688894b97ecb4b42b87cb9edcb99022070fa54e928290030190a350506040015192915050565b60408051606081018252825481526001830154602082015260028301549181018290526000918291906107e7610d5e565b036107fd57602081015190519094909350915050565b5193849350915050565b600061081282610d6e565b905061081c610d5e565b81111561083f57604051632029102760e21b815260048101829052602401610373565b61084884610d7d565b8284600001600082825461085c91906110bb565b9091555061086a9050610d5e565b81101561088b578284600101600082825461088591906110bb565b90915550505b50505050565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f591906110e1565b6001600160a01b0316630c0450127f6fdcaa094af96c56039c701c590da2284d9e0c364f2dd8ee7d43419f0eefd2936040518263ffffffff1660e01b815260040161094091906110fe565b602060405180830381865afa15801561095d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102af91906110e1565b6040516001600160a01b0383166024820152604481018290526109e490849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152610da9565b505050565b60038054600091826109fa83611113565b909155505060038054604080516080810182526001600160a01b0380881680835260008181526001602081815286832080548288019081528789018d81524260608a019081528b87528685528a872099518a5499166001600160a01b0319909916989098178955905188850155516002880155945195909801949094558387528254938401835591825294902001829055519092508291907f536047b5fc46f9ae12405dac5cdd00128e0ca662a5d3faedb714aaf8a69f5c9190610ac19086815260200190565b60405180910390a392915050565b610ad882610d7d565b80826000016000828254610aec91906110ce565b90915550505050565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b35573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b5991906110e1565b6001600160a01b0316630c0450126000805160206111fa8339815191526040518263ffffffff1660e01b815260040161094091906110fe565b6040516001600160a01b038085166024830152831660448201526064810182905261088b9085906323b872dd60e01b906084016109ad565b6000816001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c5891906110e1565b6001600160a01b0316630c045012856040518263ffffffff1660e01b8152600401610c8391906110fe565b602060405180830381865afa158015610ca0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cc491906110e1565b6001600160a01b0316149392505050565b81546000908190610ce8906001906110bb565b915050818114801590610d3157838281548110610d0757610d0761108f565b9060005260206000200154848481548110610d2457610d2461108f565b6000918252602090912001555b83805480610d4157610d4161112c565b600190038181906000526020600020016000905590559250929050565b6000610d6942610d6e565b905090565b60006102af62093a8083611142565b8060020154610d8a610d5e565b11610d925750565b80546001820155610da1610d5e565b600290910155565b6000610dfe826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316610e7b9092919063ffffffff16565b8051909150156109e45780806020019051810190610e1c9190611164565b6109e45760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610373565b6060610e8a8484600085610e92565b949350505050565b606082471015610ef35760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610373565b843b610f415760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610373565b600080866001600160a01b03168587604051610f5d91906111aa565b60006040518083038185875af1925050503d8060008114610f9a576040519150601f19603f3d011682016040523d82523d6000602084013e610f9f565b606091505b5091509150610faf828286610fba565b979650505050505050565b60608315610fc9575081610238565b825115610fd95782518084602001fd5b8160405162461bcd60e51b815260040161037391906111c6565b60006020828403121561100557600080fd5b5035919050565b6001600160a01b038116811461102157600080fd5b50565b6000806040838503121561103757600080fd5b82356110428161100c565b946020939093013593505050565b60006020828403121561106257600080fd5b81356102388161100c565b6000806040838503121561108057600080fd5b50508035926020909101359150565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b818103818111156102af576102af6110a5565b808201808211156102af576102af6110a5565b6000602082840312156110f357600080fd5b81516102388161100c565b6001600160e01b031991909116815260200190565b600060018201611125576111256110a5565b5060010190565b634e487b7160e01b600052603160045260246000fd5b60008261115f57634e487b7160e01b600052601260045260246000fd5b500490565b60006020828403121561117657600080fd5b8151801515811461023857600080fd5b60005b838110156111a1578181015183820152602001611189565b50506000910152565b600082516111bc818460208701611186565b9190910192915050565b60208152600082518060208401526111e5816040850160208701611186565b601f01601f1916919091016040019291505056fe9e45de9588e74df19c5f35dd4ddf9c698e7a3e36b4004fd44cb75621507d7092a2646970667358221220f6f499f971eaef492b58bc3ae4c2c0af68c2861599098be36a64020deacdbe4c64736f6c63430008100033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c806347e7ef241161006657806347e7ef241461011b5780634f6ccce71461012e5780636352211e1461014157806370a082311461018257806399fbab88146101ab57600080fd5b806318160ddd146100a35780632e1a7d4d146100ba5780632f745c59146100cd578063427d7432146100e0578063441a3e7014610108575b600080fd5b6003545b6040519081526020015b60405180910390f35b6100a76100c8366004610ff3565b610214565b6100a76100db366004611024565b61023f565b6100f36100ee366004611050565b6102b5565b604080519283526020830191909152016100b1565b6100a761011636600461106d565b6102e1565b6100a7610129366004611024565b61049f565b6100a761013c366004610ff3565b610584565b61016a61014f366004610ff3565b6000908152602081905260409020546001600160a01b031690565b6040516001600160a01b0390911681526020016100b1565b6100a7610190366004611050565b6001600160a01b031660009081526001602052604090205490565b6101ea6101b9366004610ff3565b60006020819052908152604090208054600182015460028301546003909301546001600160a01b0390921692909184565b604080516001600160a01b03909516855260208501939093529183015260608201526080016100b1565b60006000805160206111fa83398151915261022f81336105b9565b6102388361061c565b9392505050565b6001600160a01b038216600090815260016020526040812054821061027757604051638f832b9b60e01b815260040160405180910390fd5b6001600160a01b03831660009081526001602052604090208054839081106102a1576102a161108f565b906000526020600020015490505b92915050565b6001600160a01b038116600090815260026020526040812081906102d8906107b6565b91509150915091565b60006000805160206111fa8339815191526102fc81336105b9565b60008481526020818152604091829020825160808101845281546001600160a01b0316815260018201549281019290925260028101549282018390526003015460608201529084111561037c57838160400151604051637d12377b60e11b8152600401610373929190918252602082015260400190565b60405180910390fd5b80604001518403610398576103908561061c565b925050610498565b600085815260208190526040812060020180548692906103b99084906110bb565b9091555050606081015181516001600160a01b031660009081526002602052604090206103e7918690610807565b805161043090856104206001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016610891565b6001600160a01b03169190610981565b8481600001516001600160a01b03167ff6763bd8d37738b3bf0660478688894b97ecb4b42b87cb9edcb99022070fa54e8687856040015161047191906110bb565b606086810151604080519485526020850193909352838301529051918290030190a3839250505b5092915050565b60006000805160206111fa8339815191526104ba81336105b9565b826000036104db5760405163078e1d8560e01b815260040160405180910390fd5b6104e584846109e9565b6001600160a01b038516600090815260026020526040902090925061050a9084610acf565b61049861053f7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610af5565b30856105737f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610891565b6001600160a01b0316929190610b92565b600061058f60035490565b82106105ae57604051633f7ee38f60e11b815260040160405180910390fd5b6102af8260016110ce565b6001600160a01b0381166105e05760405163d92e233d60e01b815260040160405180910390fd5b6105ea8282610bca565b6106185760405163889a56bb60e01b81523060048201526001600160a01b0382166024820152604401610373565b5050565b600081815260208181526040808320815160808101835281546001600160a01b03808216835260018085018054858901908152600287018054878a015260038801805460608901528c8c528b8b526001600160a01b031990961690975590899055948890559187905582511686529093529083209051839061069f908390610cd5565b91505080156106e7578260200151600080848660200151815481106106c6576106c661108f565b90600052602060002001548152602001908152602001600020600101819055505b604080840151606085015185516001600160a01b0316600090815260026020529290922061071792909190610807565b610756836000015184604001516104207f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316610891565b825160408085015160608087015183519283526000602084015282840152915188936001600160a01b0316927ff6763bd8d37738b3bf0660478688894b97ecb4b42b87cb9edcb99022070fa54e928290030190a350506040015192915050565b60408051606081018252825481526001830154602082015260028301549181018290526000918291906107e7610d5e565b036107fd57602081015190519094909350915050565b5193849350915050565b600061081282610d6e565b905061081c610d5e565b81111561083f57604051632029102760e21b815260048101829052602401610373565b61084884610d7d565b8284600001600082825461085c91906110bb565b9091555061086a9050610d5e565b81101561088b578284600101600082825461088591906110bb565b90915550505b50505050565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108d1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f591906110e1565b6001600160a01b0316630c0450127f6fdcaa094af96c56039c701c590da2284d9e0c364f2dd8ee7d43419f0eefd2936040518263ffffffff1660e01b815260040161094091906110fe565b602060405180830381865afa15801561095d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102af91906110e1565b6040516001600160a01b0383166024820152604481018290526109e490849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152610da9565b505050565b60038054600091826109fa83611113565b909155505060038054604080516080810182526001600160a01b0380881680835260008181526001602081815286832080548288019081528789018d81524260608a019081528b87528685528a872099518a5499166001600160a01b0319909916989098178955905188850155516002880155945195909801949094558387528254938401835591825294902001829055519092508291907f536047b5fc46f9ae12405dac5cdd00128e0ca662a5d3faedb714aaf8a69f5c9190610ac19086815260200190565b60405180910390a392915050565b610ad882610d7d565b80826000016000828254610aec91906110ce565b90915550505050565b6000816001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b35573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b5991906110e1565b6001600160a01b0316630c0450126000805160206111fa8339815191526040518263ffffffff1660e01b815260040161094091906110fe565b6040516001600160a01b038085166024830152831660448201526064810182905261088b9085906323b872dd60e01b906084016109ad565b6000816001600160a01b03167f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663f887ea406040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c34573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c5891906110e1565b6001600160a01b0316630c045012856040518263ffffffff1660e01b8152600401610c8391906110fe565b602060405180830381865afa158015610ca0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cc491906110e1565b6001600160a01b0316149392505050565b81546000908190610ce8906001906110bb565b915050818114801590610d3157838281548110610d0757610d0761108f565b9060005260206000200154848481548110610d2457610d2461108f565b6000918252602090912001555b83805480610d4157610d4161112c565b600190038181906000526020600020016000905590559250929050565b6000610d6942610d6e565b905090565b60006102af62093a8083611142565b8060020154610d8a610d5e565b11610d925750565b80546001820155610da1610d5e565b600290910155565b6000610dfe826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316610e7b9092919063ffffffff16565b8051909150156109e45780806020019051810190610e1c9190611164565b6109e45760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610373565b6060610e8a8484600085610e92565b949350505050565b606082471015610ef35760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b6064820152608401610373565b843b610f415760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610373565b600080866001600160a01b03168587604051610f5d91906111aa565b60006040518083038185875af1925050503d8060008114610f9a576040519150601f19603f3d011682016040523d82523d6000602084013e610f9f565b606091505b5091509150610faf828286610fba565b979650505050505050565b60608315610fc9575081610238565b825115610fd95782518084602001fd5b8160405162461bcd60e51b815260040161037391906111c6565b60006020828403121561100557600080fd5b5035919050565b6001600160a01b038116811461102157600080fd5b50565b6000806040838503121561103757600080fd5b82356110428161100c565b946020939093013593505050565b60006020828403121561106257600080fd5b81356102388161100c565b6000806040838503121561108057600080fd5b50508035926020909101359150565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b818103818111156102af576102af6110a5565b808201808211156102af576102af6110a5565b6000602082840312156110f357600080fd5b81516102388161100c565b6001600160e01b031991909116815260200190565b600060018201611125576111256110a5565b5060010190565b634e487b7160e01b600052603160045260246000fd5b60008261115f57634e487b7160e01b600052601260045260246000fd5b500490565b60006020828403121561117657600080fd5b8151801515811461023857600080fd5b60005b838110156111a1578181015183820152602001611189565b50506000910152565b600082516111bc818460208701611186565b9190910192915050565b60208152600082518060208401526111e5816040850160208701611186565b601f01601f1916919091016040019291505056fe9e45de9588e74df19c5f35dd4ddf9c698e7a3e36b4004fd44cb75621507d7092a2646970667358221220f6f499f971eaef492b58bc3ae4c2c0af68c2861599098be36a64020deacdbe4c64736f6c63430008100033",
  "devdoc": {
    "author": "Goldfinch",
    "kind": "dev",
    "methods": {
      "balanceOf(address)": {
        "params": {
          "addr": "address"
        },
        "returns": {
          "balance": "positions held by address"
        }
      },
      "deposit(address,uint256)": {
        "params": {
          "amount": "how much was deposited",
          "owner": "address to account for the deposit"
        },
        "returns": {
          "positionId": "how much was deposited"
        }
      },
      "ownerOf(uint256)": {
        "params": {
          "positionId": "id of the position"
        },
        "returns": {
          "_0": "owner of the position"
        }
      },
      "tokenByIndex(uint256)": {
        "details": "Returns a position ID at a given `index` of all the positions stored by the contract.use with {totalSupply} to enumerate all positions",
        "params": {
          "index": "index to get the position ID at"
        },
        "returns": {
          "_0": "token id"
        }
      },
      "tokenOfOwnerByIndex(address,uint256)": {
        "details": "use with {balanceOf} to enumerate all of `owner`'s positions",
        "params": {
          "index": "index of the owner's balance to get the position ID of",
          "owner": "owner of the positions"
        },
        "returns": {
          "_0": "position id"
        }
      },
      "totalSupply()": {
        "returns": {
          "_0": "number of positions in the ledger"
        }
      },
      "totalsOf(address)": {
        "details": "this is used by Membership to determine how much is eligible in  the current epoch vs the next epoch.",
        "returns": {
          "eligibleAmount": "GFI amount of positions eligible for rewards",
          "totalAmount": "total GFI amount of positions"
        }
      },
      "withdraw(uint256)": {
        "params": {
          "positionId": "id of the position"
        },
        "returns": {
          "_0": "how much was withdrawn"
        }
      },
      "withdraw(uint256,uint256)": {
        "params": {
          "amount": "how much to withdraw",
          "positionId": "id of the position"
        },
        "returns": {
          "_0": "how much was withdrawn"
        }
      }
    },
    "title": "GFILedger",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "IndexGreaterThanTokenSupply()": [
        {
          "notice": "Thrown when querying token supply with an index greater than the supply"
        }
      ],
      "InvalidOwnerIndex()": [
        {
          "notice": "Thrown when depositing from address(0)"
        }
      ],
      "InvalidWithdrawAmount(uint256,uint256)": [
        {
          "notice": "Thrown when withdrawing an invalid amount for a position"
        }
      ],
      "ZeroDepositAmount()": [
        {
          "notice": "Thrown when depositing zero GFI for a position"
        }
      ]
    },
    "events": {
      "GFIDeposit(address,uint256,uint256)": {
        "notice": "Emitted when a new GFI deposit has been made"
      },
      "GFIWithdrawal(address,uint256,uint256,uint256,uint256)": {
        "notice": "Emitted when a new GFI withdrawal has been made. If the remaining amount is 0, the position has bee removed"
      }
    },
    "kind": "user",
    "methods": {
      "balanceOf(address)": {
        "notice": "Get the number of GFI positions held by an address"
      },
      "constructor": {
        "notice": "Construct the contract"
      },
      "deposit(address,uint256)": {
        "notice": "Account for a new deposit by the owner."
      },
      "ownerOf(uint256)": {
        "notice": "Get the owner of a given position."
      },
      "tokenOfOwnerByIndex(address,uint256)": {
        "notice": "Returns a position ID owned by `owner` at a given `index` of its position list"
      },
      "totalSupply()": {
        "notice": "Total number of positions in the ledger"
      },
      "totalsOf(address)": {
        "notice": "Get amount of GFI of `owner`s positions, reporting what is currently  eligible and the total amount."
      },
      "withdraw(uint256)": {
        "notice": "Account for a new withdraw by the owner."
      },
      "withdraw(uint256,uint256)": {
        "notice": "Account for a new withdraw by the owner."
      }
    },
    "notice": "Track GFI held by owners and ensure the GFI has been accounted for.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11306,
        "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
        "label": "positions",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_struct(Position)6345_storage)"
      },
      {
        "astId": 11311,
        "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
        "label": "owners",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_array(t_uint256)dyn_storage)"
      },
      {
        "astId": 11317,
        "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
        "label": "totals",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_struct(UserEpochTotal)13995_storage)"
      },
      {
        "astId": 11319,
        "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
        "label": "positionCounter",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)dyn_storage": {
        "base": "t_uint256",
        "encoding": "dynamic_array",
        "label": "uint256[]",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_array(t_uint256)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256[])",
        "numberOfBytes": "32",
        "value": "t_array(t_uint256)dyn_storage"
      },
      "t_mapping(t_address,t_struct(UserEpochTotal)13995_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct UserEpochTotal)",
        "numberOfBytes": "32",
        "value": "t_struct(UserEpochTotal)13995_storage"
      },
      "t_mapping(t_uint256,t_struct(Position)6345_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct IGFILedger.Position)",
        "numberOfBytes": "32",
        "value": "t_struct(Position)6345_storage"
      },
      "t_struct(Position)6345_storage": {
        "encoding": "inplace",
        "label": "struct IGFILedger.Position",
        "members": [
          {
            "astId": 6338,
            "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
            "label": "owner",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 6340,
            "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
            "label": "ownedIndex",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 6342,
            "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
            "label": "amount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 6344,
            "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
            "label": "depositTimestamp",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(UserEpochTotal)13995_storage": {
        "encoding": "inplace",
        "label": "struct UserEpochTotal",
        "members": [
          {
            "astId": 13988,
            "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
            "label": "totalAmount",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 13991,
            "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
            "label": "eligibleAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 13994,
            "contract": "contracts/protocol/core/membership/GFILedger.sol:GFILedger",
            "label": "checkpointedAt",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "96"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}