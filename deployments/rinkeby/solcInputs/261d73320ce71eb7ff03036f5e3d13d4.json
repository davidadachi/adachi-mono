{
  "language": "Solidity",
  "sources": {
    "contracts/test/TestForwarder.sol": {
      "content": "// SPDX-License-Identifier:MIT\npragma solidity ^0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\n// Taken from  https://github.com/opengsn/forwarder/blob/master/contracts/Forwarder.sol and adapted to work locally\n// Main change is removing interface inheritance and adding a some debugging niceities\ncontract TestForwarder {\n  using ECDSA for bytes32;\n\n  struct ForwardRequest {\n    address from;\n    address to;\n    uint256 value;\n    uint256 gas;\n    uint256 nonce;\n    bytes data;\n  }\n\n  string public constant GENERIC_PARAMS = \"address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data\";\n\n  string\n    public constant EIP712_DOMAIN_TYPE = \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"; // solhint-disable-line max-line-length\n\n  mapping(bytes32 => bool) public typeHashes;\n  mapping(bytes32 => bool) public domains;\n\n  // Nonces of senders, used to prevent replay attacks\n  mapping(address => uint256) private nonces;\n\n  // solhint-disable-next-line no-empty-blocks\n  receive() external payable {}\n\n  function getNonce(address from) public view returns (uint256) {\n    return nonces[from];\n  }\n\n  constructor() public {\n    string memory requestType = string(abi.encodePacked(\"ForwardRequest(\", GENERIC_PARAMS, \")\"));\n    registerRequestTypeInternal(requestType);\n  }\n\n  function verify(\n    ForwardRequest memory req,\n    bytes32 domainSeparator,\n    bytes32 requestTypeHash,\n    bytes calldata suffixData,\n    bytes calldata sig\n  ) external view {\n    _verifyNonce(req);\n    _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n  }\n\n  function execute(\n    ForwardRequest memory req,\n    bytes32 domainSeparator,\n    bytes32 requestTypeHash,\n    bytes calldata suffixData,\n    bytes calldata sig\n  ) external payable returns (bool success, bytes memory ret) {\n    _verifyNonce(req);\n    _verifySig(req, domainSeparator, requestTypeHash, suffixData, sig);\n    _updateNonce(req);\n\n    // solhint-disable-next-line avoid-low-level-calls\n    (success, ret) = req.to.call{gas: req.gas, value: req.value}(abi.encodePacked(req.data, req.from));\n    // Added by Goldfinch for debugging\n    if (!success) {\n      require(success, string(ret));\n    }\n    if (address(this).balance > 0) {\n      //can't fail: req.from signed (off-chain) the request, so it must be an EOA...\n      payable(req.from).transfer(address(this).balance);\n    }\n    return (success, ret);\n  }\n\n  function _verifyNonce(ForwardRequest memory req) internal view {\n    require(nonces[req.from] == req.nonce, \"nonce mismatch\");\n  }\n\n  function _updateNonce(ForwardRequest memory req) internal {\n    nonces[req.from]++;\n  }\n\n  function registerRequestType(string calldata typeName, string calldata typeSuffix) external {\n    for (uint256 i = 0; i < bytes(typeName).length; i++) {\n      bytes1 c = bytes(typeName)[i];\n      require(c != \"(\" && c != \")\", \"invalid typename\");\n    }\n\n    string memory requestType = string(abi.encodePacked(typeName, \"(\", GENERIC_PARAMS, \",\", typeSuffix));\n    registerRequestTypeInternal(requestType);\n  }\n\n  function registerDomainSeparator(string calldata name, string calldata version) external {\n    uint256 chainId;\n    /* solhint-disable-next-line no-inline-assembly */\n    assembly {\n      chainId := chainid()\n    }\n\n    bytes memory domainValue = abi.encode(\n      keccak256(bytes(EIP712_DOMAIN_TYPE)),\n      keccak256(bytes(name)),\n      keccak256(bytes(version)),\n      chainId,\n      address(this)\n    );\n\n    bytes32 domainHash = keccak256(domainValue);\n\n    domains[domainHash] = true;\n    emit DomainRegistered(domainHash, domainValue);\n  }\n\n  function registerRequestTypeInternal(string memory requestType) internal {\n    bytes32 requestTypehash = keccak256(bytes(requestType));\n    typeHashes[requestTypehash] = true;\n    emit RequestTypeRegistered(requestTypehash, requestType);\n  }\n\n  event DomainRegistered(bytes32 indexed domainSeparator, bytes domainValue);\n\n  event RequestTypeRegistered(bytes32 indexed typeHash, string typeStr);\n\n  function _verifySig(\n    ForwardRequest memory req,\n    bytes32 domainSeparator,\n    bytes32 requestTypeHash,\n    bytes memory suffixData,\n    bytes memory sig\n  ) internal view {\n    require(domains[domainSeparator], \"unregistered domain separator\");\n    require(typeHashes[requestTypeHash], \"unregistered request typehash\");\n    bytes32 digest = keccak256(\n      abi.encodePacked(\"\\x19\\x01\", domainSeparator, keccak256(_getEncoded(req, requestTypeHash, suffixData)))\n    );\n    require(digest.recover(sig) == req.from, \"signature mismatch\");\n  }\n\n  function _getEncoded(\n    ForwardRequest memory req,\n    bytes32 requestTypeHash,\n    bytes memory suffixData\n  ) public pure returns (bytes memory) {\n    return\n      abi.encodePacked(\n        requestTypeHash,\n        abi.encode(req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)),\n        suffixData\n      );\n  }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        require(uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0, \"ECDSA: invalid signature 's' value\");\n        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}